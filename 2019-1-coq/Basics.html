<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Basics</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href="https://github.com/hengxin/problem-solving-class-coq">
<img src="common/media/image/sf_logo_sm.png"></a>
<br><span class="booktitleinheader">Volume 1: 逻辑基础</span><br><br>
<ul id="menu">
   <a href="toc.html"><li class="section_name">目录</li></a>
   <a href="deps.html"><li class="section_name">路线</li></a>
</ul>
</div>


<div id="main">

<h1 class="libtitle">Library Basics</h1>

<div class="code code-tight">
</div>

<div class="doc">
<a name="lab19"></a><h1 class="section">数据类型与自然数 (Data Types and Naturals)</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> 请勿公开发布习题解答

</li>
<li> 有问题请在 http://problemoverflow.top/ 提问

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab20"></a><h1 class="section">引言</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  '算法 + 数据结构 = 程序' 
  (Algorithms + Data Structures = Programs) by Niklaus Wirth.

<div class="paragraph"> </div>

  如果说算法是一张食谱，那么数据就是食材。
  所谓'巧妇难为无米之炊'，没有数据，算法就无用武之地。
  正如食材各式各样，数据也有各种 <b>类型</b>
  (在本教材中，我们使用数据类型的说法，而不是数据结构)。

<div class="paragraph"> </div>

  数据类型包含两部分含义： 
<ul class="doclist">
<li> 数据 (也称 <b>值</b>) 构成的集合； 

</li>
<li> 定义在这些数据上的操作。

</li>
</ul>

<div class="paragraph"> </div>

  比如自然数是一种数据类型，它的数据集合是 {0, 1, 2, ...}，
  它允许的操作包括前驱、后继、加法、减法 (受限的减法)、乘法、幂运算等。

<div class="paragraph"> </div>

  同样重要的是，自然数作为一种数据类型，它 <b>不包括</b> -1、0.5、2/3、e 等数据，
  也<b>不支持</b>除法、拼接、旋转等操作。

<div class="paragraph"> </div>

  在程序设计语言里， <b>类型检查</b> (Type Checking) 的工作就是检查：
<ul class="doclist">
<li> 是否使用了无效的 (invalid) 数据； 

</li>
<li> 是否进行了非法的 (unsupported) 操作。

</li>
</ul>

<div class="paragraph"> </div>

  本章介绍如何在 Coq (内置的 <b>Gallina</b> 程序设计语言) 中定义数据类型。
  同时，本章还将介绍如何在 Coq 中做证明。
  我们以自然数数据类型为例。

</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab21"></a><h1 class="section">数据与函数</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  Coq 的标准库 (Standard Library) 中内置了一些常用的数据类型，
  比如布尔类型、自然数、列表、散列表等。

<div class="paragraph"> </div>

  要定义一个数据类型，我们需要：
<ul class="doclist">
<li> 定义数据集合

</li>
<li> 定义操作

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab22"></a><h2 class="section">枚举类型</h2>

</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab23"></a><h3 class="section">一周七日</h3>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  以下声明 (Declaration) 定义了一个名为 <span class="inlinecode"><span class="id" type="var">day</span></span> 的数据类型。
  它的数据构成的集合为 {<span class="inlinecode"><span class="id" type="var">monday</span></span>, <span class="inlinecode"><span class="id" type="var">tuesday</span></span>, <span class="inlinecode"><span class="id" type="var">wednesday</span></span>, 
  <span class="inlinecode"><span class="id" type="var">thursday</span></span>, <span class="inlinecode"><span class="id" type="var">friday</span></span>, <span class="inlinecode"><span class="id" type="var">saturday</span></span>, <span class="inlinecode"><span class="id" type="var">sunday</span></span>}。
  <span class="inlinecode"><span class="id" type="var">day</span></span> 是 <b>枚举</b> (Enumerate) 数据类型，
  因为我们直接在定义中一一列举了它包含的值。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">day</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">monday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">tuesday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">wednesday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">thursday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">friday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">saturday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">sunday</span>.<br/>

<br/>
</div>

<div class="doc">
  下面，我们定义一个名为 <span class="inlinecode"><span class="id" type="var">next_day</span></span> 的操作，也称为函数。
  该操作接受一个类型为 <span class="inlinecode"><span class="id" type="var">day</span></span> 的数据 <span class="inlinecode"><span class="id" type="var">d</span></span> (称为<b>参数</b> (parameter))，
  返回一个类型为 <span class="inlinecode"><span class="id" type="var">day</span></span> 的数据 (称为<b>返回值</b> (return value))。 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">next_day</span> (<span class="id" type="var">d</span>:<span class="id" type="var">day</span>) : <span class="id" type="var">day</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">d</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">monday</span>    =&gt; <span class="id" type="var">tuesday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">tuesday</span>   =&gt; <span class="id" type="var">wednesday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">wednesday</span> =&gt; <span class="id" type="var">thursday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">thursday</span>  =&gt; <span class="id" type="var">friday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">friday</span>    =&gt; <span class="id" type="var">saturday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">saturday</span>  =&gt; <span class="id" type="var">sunday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">sunday</span>    =&gt; <span class="id" type="var">monday</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">next_day</span></span> <span class="inlinecode"><span class="id" type="var">saturday</span></span> 的结果应该是 <span class="inlinecode"><span class="id" type="var">sunday</span></span>。
  我们可以用 <span class="inlinecode"><span class="id" type="keyword">Compute</span></span> 指令查看该结果。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Compute</span> (<span class="id" type="var">next_day</span> <span class="id" type="var">saturday</span>).<br/>

<br/>
</div>

<div class="doc">
  <span class="inlinecode">(<span class="id" type="var">next_day</span></span> <span class="inlinecode">(<span class="id" type="var">next_day</span></span> <span class="inlinecode"><span class="id" type="var">saturday</span>))</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" type="var">next_day</span></span> <span class="inlinecode"><span class="id" type="var">sunday</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">monday</span>.</span> Sad!

</div>
<div class="code code-tight">
<span class="id" type="keyword">Compute</span> (<span class="id" type="var">next_day</span> (<span class="id" type="var">next_day</span> <span class="id" type="var">saturday</span>)).<br/>

<br/>
</div>

<div class="doc">
第二，我们通过单元测试 (Unit Test) 检验函数。
  下面的 <span class="inlinecode"><span class="id" type="keyword">Example</span></span> 定义了一个断言 (Assertioin):
  <span class="inlinecode"><span class="id" type="var">saturday</span></span> 的明天的明天是 <span class="inlinecode"><span class="id" type="var">monday</span></span>。
  我们还给这个断言起了个名字： <span class="inlinecode"><span class="id" type="var">time_files</span></span>。
  以后，我们可以使用 <span class="inlinecode"><span class="id" type="var">time_files</span></span> 引用该断言。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <span class="id" type="var">time_flies</span>:<br/>
&nbsp;&nbsp;(<span class="id" type="var">next_day</span> (<span class="id" type="var">next_day</span> <span class="id" type="var">saturday</span>)) = <span class="id" type="var">monday</span>.<br/>

<br/>
</div>

<div class="doc">
  我们需要 <b>证明</b> 该断言是真的。
  证明很简单，分为两步：

<div class="paragraph"> </div>

  证明：
<ul class="doclist">
<li> 化简。等号左边的 <span class="inlinecode">(<span class="id" type="var">next_day</span></span> <span class="inlinecode">(<span class="id" type="var">next_day</span></span> <span class="inlinecode"><span class="id" type="var">saturday</span>))</span> 可以化简为 <span class="inlinecode"><span class="id" type="var">monday</span></span>。

</li>
<li> 相同性判断。等号左边的 <span class="inlinecode"><span class="id" type="var">monday</span></span> 与 等号右边的 <span class="inlinecode"><span class="id" type="var">monday</span></span> 相同。

</li>
</ul>
  证毕。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  Coq 是 <b>交互式定理证明</b> (Interactive Theorem Proving; ITP) 工具，
  也称为 <b>证明助手</b> (Proof Assistant)。

<div class="paragraph"> </div>

  要想使用 Coq 证明某个定理，你需要：
<ul class="doclist">
<li> 清楚该定理的证明过程

</li>
<li> 清楚 Coq 支持的证明策略 (Proof Tactics)

</li>
<li> 将证明过程翻译成 Coq 支持的证明策略

</li>
</ul>

<div class="paragraph"> </div>

  比如上例中的 <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> 表示化简，<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 判断相同性。
  <span class="inlinecode"><span class="id" type="keyword">Proof</span></span> 表示证明开始，<span class="inlinecode"><span class="id" type="keyword">Qed</span></span> 表示证毕 (哇，多么美妙的词语)。

</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab24"></a><h3 class="section">布尔类型</h3>

<div class="paragraph"> </div>

 下面的声明定义了布尔类型 <span class="inlinecode"><span class="id" type="var">bool</span></span>，它包含两个值 <span class="inlinecode"><span class="id" type="var">true</span></span> 与 <span class="inlinecode"><span class="id" type="var">false</span></span>。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">bool</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  常用的布尔函数包括： <span class="inlinecode"><span class="id" type="var">negb</span></span> (取反)； <span class="inlinecode"><span class="id" type="var">andb</span></span> (并且)； <span class="inlinecode"><span class="id" type="var">orb</span></span> (或者)。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">negb</span> (<span class="id" type="var">b</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">andb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> =&gt; <span class="id" type="var">b2</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">orb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> =&gt; <span class="id" type="var">b2</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  我们以 <span class="inlinecode"><span class="id" type="var">orb</span></span> 为例进行“单元测试”与证明。
  这四个测试用例实际上构成了 <span class="inlinecode"><span class="id" type="var">orb</span></span> 的真值表 (Truth Table)。

<div class="paragraph"> </div>

  注意： <span class="inlinecode"><span class="id" type="var">orb</span></span> 函数接受两个 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的参数。
  <span class="inlinecode"><span class="id" type="var">orb</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> <span class="inlinecode"><span class="id" type="var">false</span></span> 表示将函数 <span class="inlinecode"><span class="id" type="var">orb</span></span> 应用 (Apply) 到参数 <span class="inlinecode"><span class="id" type="var">true</span></span> 与 <span class="inlinecode"><span class="id" type="var">false</span></span> 上。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb1</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb2</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">false</span> <span class="id" type="var">false</span>) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb3</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span>)  = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb4</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">true</span>  <span class="id" type="var">true</span>)  = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们可以使用 <span class="inlinecode"><span class="id" type="var">Natation</span></span> 为布尔函数引入更常见的符号。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> &quot;x &amp;&amp; y" := (<span class="id" type="var">andb</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>).<br/>
<span class="id" type="keyword">Notation</span> &quot;x || y" := (<span class="id" type="var">orb</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>).<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb5</span>:  <span class="id" type="var">false</span> || <span class="id" type="var">false</span> || <span class="id" type="var">true</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab25"></a><h4 class="section">练习：1 星, standard (nandb)</h4>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  要想熟练使用 Coq，不做练习是不可能的。

<div class="paragraph"> </div>

  现在，你需要定义一个布尔函数 <span class="inlinecode"><span class="id" type="var">nandb</span></span>:
  只有当两个参数都是 <span class="inlinecode"><span class="id" type="var">true</span></span> 时，它才返回 <span class="inlinecode"><span class="id" type="var">false</span></span>;
  否则，它返回 <span class="inlinecode"><span class="id" type="var">true</span></span>。
  你可以使用之前定义过的布尔函数 <span class="inlinecode"><span class="id" type="var">negb</span></span>、<span class="inlinecode"><span class="id" type="var">andb</span></span>、<span class="inlinecode"><span class="id" type="var">orb</span></span>。

<div class="paragraph"> </div>

  指令 <span class="inlinecode"><span class="id" type="var">Admitted</span></span> 是证明中的占位符。
  你的任务就是将它替换成真正的证明。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">nandb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;. <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb1</span>: (<span class="id" type="var">nandb</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb2</span>: (<span class="id" type="var">nandb</span> <span class="id" type="var">false</span> <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb3</span>: (<span class="id" type="var">nandb</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span>) = <span class="id" type="var">true</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb4</span>: (<span class="id" type="var">nandb</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span>) = <span class="id" type="var">false</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab26"></a><h2 class="section">类型</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  Coq 中的每个表达式都有类型。我们可以使用 <span class="inlinecode"><span class="id" type="keyword">Check</span></span> 指令查看表达式的类型。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">negb</span> <span class="id" type="var">true</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  Coq (内置的 <b>Gallina</b> ) 是 <b>函数式</b> (Functional) 程序设计语言。
  在函数式程序设计语言中，函数也是数据，也有类型。
  更多关于函数式程序设计的内容，我们会在后续课程与 Coq 教材中学习。

<div class="paragraph"> </div>

  函数 <span class="inlinecode"><span class="id" type="var">negb</span></span> 的类型是 <b>函数类型</b> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span></span>。
  这是由 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型构成的复合类型，
  它告诉我们： <span class="inlinecode"><span class="id" type="var">negb</span></span> 是一个函数，它接受一个 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的参数，
  返回一个 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的值。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">negb</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  类似地，<span class="inlinecode"><span class="id" type="var">andb</span></span> 的类型是 <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span></span>，
  它告诉我们：<span class="inlinecode"><span class="id" type="var">andb</span></span> 是一个函数，它接受两个 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的参数，
  返回一个 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的值。

<div class="paragraph"> </div>

  关于 <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> 的另一种“更函数式的”理解方式，
  我们将在函数式程序设计章节中介绍。
  此处仅简单提及。
  实际上，<span class="inlinecode">-&gt;</span> 运算符是右结合的。
  也就是说，<span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> 实际上是 <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span>)</span>。
  它告诉我们：<span class="inlinecode"><span class="id" type="var">andb</span></span> 是一个函数，它接受一个 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的参数，
  返回一个类型为 <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> 的函数 
  (没错，在函数式程序设计中，函数可以作为返回值。是不是很优雅？)。
  这个返回的函数又可以接受一个 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的参数，返回一个 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的值。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">andb</span>.<br/>
</div>

<div class="doc">
<a name="lab27"></a><h2 class="section">由旧类型构造新类型</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在现实生活中，问题层出不穷。
  不同的问题可能使用不同的数据类型。
  我们不希望每次都从头构造一个数据类型，而是希望能基于已有的数据类型定义新的数据类型。

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">rgb</span></span> 仍然是简单的枚举类型。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">rgb</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="tactic">red</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">green</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">blue</span>.<br/>

<br/>
</div>

<div class="doc">
  <span class="inlinecode"><span class="id" type="var">color</span></span> 与我们之前定义的数据类型不同。
  除了我们已经熟悉的 <span class="inlinecode"><span class="id" type="var">black</span></span>、<span class="inlinecode"><span class="id" type="var">white</span></span> 形式之外，
  它还包含 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode">(<span class="id" type="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">rgb</span>)</span>。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">color</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">black</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">white</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">primary</span> (<span class="id" type="var">p</span> : <span class="id" type="var">rgb</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  这里，我们需要介绍一点理论知识。(很简单，不要害怕。)

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" type="var">color</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span> 告诉 Coq：
  <b>归纳</b> (Inductively) 地定义 (也称 <b>构造</b>) 名为 <span class="inlinecode"><span class="id" type="var">color</span></span> 的数据类型。

<div class="paragraph"> </div>

  在归纳定义中，我们需要给出构造 <span class="inlinecode"><span class="id" type="var">color</span></span> 类型的数据的方法 (也称 <b>构造函数</b>)：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">black</span></span> 是一个构造函数。它表示 <span class="inlinecode"><span class="id" type="var">black</span></span> 是类型为 <span class="inlinecode"><span class="id" type="var">color</span></span> 的值。

</li>
<li> <span class="inlinecode"><span class="id" type="var">white</span></span> 是一个构造函数。它表示 <span class="inlinecode"><span class="id" type="var">white</span></span> 是类型为 <span class="inlinecode"><span class="id" type="var">color</span></span> 的值。

</li>
<li> <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode">(<span class="id" type="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">rgb</span>)</span> 是一个构造函数。
    它表示，如果 <span class="inlinecode"><span class="id" type="var">p</span></span> 是类型为 <span class="inlinecode"><span class="id" type="var">rgb</span></span> 的值，
    那么 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> 就是类型为 <span class="inlinecode"><span class="id" type="var">color</span></span> 的值。
    例如，<span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="tactic">red</span></span>、<span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">green</span></span>、<span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">blue</span></span>
    都是类型为 <span class="inlinecode"><span class="id" type="var">color</span></span> 的值。

</li>
</ul>

<div class="paragraph"> </div>

  同样重要的是，<span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" type="var">color</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span> 还告诉 Coq：
  类型为 <span class="inlinecode"><span class="id" type="var">color</span></span> 的值有且 <b>仅有</b> 以上三种构造方式。
  例如，<span class="inlinecode"><span class="id" type="var">sunday</span></span>、<span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">saturday</span></span>、<span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">false</span></span> 
  都不是类型为 <span class="inlinecode"><span class="id" type="var">color</span></span> 的值。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在定义函数时，我们可以针对每个构造函数使用 <b>模式匹配</b> (Pattern Match)。
  函数 <span class="inlinecode"><span class="id" type="var">monochrome</span></span> 接受一个类型为 <span class="inlinecode"><span class="id" type="var">color</span></span> 的参数 <span class="inlinecode"><span class="id" type="var">c</span></span>。
  根据上面的分析，<span class="inlinecode"><span class="id" type="var">c</span></span> 有且仅有三种可能的构造方式。
  <span class="inlinecode"><span class="id" type="keyword">match</span></span> 分别考虑这三种构造方式：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">black</span></span> 只可能与 <span class="inlinecode"><span class="id" type="var">black</span></span> 匹配。

</li>
<li> <span class="inlinecode"><span class="id" type="var">white</span></span> 只可能与 <span class="inlinecode"><span class="id" type="var">white</span></span> 匹配。

</li>
<li> <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">q</span></span> 只可能与 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">xxx</span></span> 匹配。

</li>
</ul>
  这里，<span class="inlinecode"><span class="id" type="var">q</span></span> 为变量，它的类型是 <span class="inlinecode"><span class="id" type="var">rgb</span></span> (Coq 可以自动推断出这一点)。
  当 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">q</span></span> 与 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">xxx</span></span> 匹配时，<span class="inlinecode"><span class="id" type="var">q</span></span> 被 <b>绑定</b> (bind) 到 <span class="inlinecode"><span class="id" type="var">xxx</span></span>。
  你可以在 <span class="inlinecode">=&gt;</span> 的右边使用 <span class="inlinecode"><span class="id" type="var">q</span></span>。
  在本例中，我们并没有在 <span class="inlinecode">=&gt;</span> 的右边使用 <span class="inlinecode"><span class="id" type="var">q</span></span>。
  在这种情况下，我们可以使用通配符 <span class="inlinecode"><span class="id" type="var">_</span></span> 代替 <span class="inlinecode"><span class="id" type="var">q</span></span>。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">monochrome</span> (<span class="id" type="var">c</span> : <span class="id" type="var">color</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">black</span> =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">white</span> =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">primary</span> <span class="id" type="var">q</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
  我们还可以对 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">q</span></span> 进行更细致的模式匹配。
  函数 <span class="inlinecode"><span class="id" type="var">isred</span></span> 中的 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> 用于匹配除 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="tactic">red</span></span> 之外的由
  <span class="inlinecode"><span class="id" type="var">primary</span></span> 构造的 <span class="inlinecode"><span class="id" type="var">color</span></span>，即 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">green</span></span> 与 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">blue</span></span>。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">isred</span> (<span class="id" type="var">c</span> : <span class="id" type="var">color</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">black</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">white</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">primary</span> <span class="id" type="tactic">red</span> =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">primary</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab28"></a><h2 class="section">模块</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  Coq 使用 <b>模块</b> (Module) 组织较大规模的代码。
  目前，我们只需要了解它的两种基本功能:
<ul class="doclist">
<li> 可以将一组紧密相关的定义放在 <span class="inlinecode"><span class="id" type="keyword">Module</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> 和 <span class="inlinecode"><span class="id" type="keyword">End</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> 之间。
    这样，在 <span class="inlinecode"><span class="id" type="keyword">End</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> 之后，我们可以使用 <span class="inlinecode"><span class="id" type="var">X.foo</span></span> 引用模块内部的 <span class="inlinecode"><span class="id" type="var">foo</span></span>。

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">Module</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> 与 <span class="inlinecode"><span class="id" type="keyword">End</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> 中的定义是封闭的。
    它们不会与该模块外部的同名定义产生冲突。

</li>
</ul>

<div class="paragraph"> </div>

  这里，我们使用了模块的第二种功能，
  在 <span class="inlinecode"><span class="id" type="keyword">Module</span></span> <span class="inlinecode"><span class="id" type="var">NatPlayground</span>.</span> 里定义自己的 <span class="inlinecode"><span class="id" type="var">nat</span></span> 类型。
  注意: 在 <span class="inlinecode"><span class="id" type="keyword">End</span></span> <span class="inlinecode"><span class="id" type="var">NatPlayground</span>.</span> 之后，我们采用的仍是 Coq 标准库里提供的定义。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Module</span> <span class="id" type="var">NatPlayground</span>.<br/>
</div>

<div class="doc">
<a name="lab29"></a><h2 class="section">自然数 (Naturals)</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  现在，我们要定义自然数数据类型。好戏刚刚开场。

<div class="paragraph"> </div>

  自然数类型与之前我们定义的数据类型有一个很大的区别，
  那就是自然数有无穷多个 (在后续课程中，我们会知道，自然数有可数无穷多个)。
  我们无法以一一列举的方式定义自然数类型。
  怎么办？怎么才能在有限的纸张上写下无穷多个自然数？

<div class="paragraph"> </div>

  答案是：归纳定义。<span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>关键词的威力在这里得以显现。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">nat</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>).<br/>

<br/>
</div>

<div class="doc">
  So Easy! 我们来解读一下。

<div class="paragraph"> </div>

  这个归纳定义告诉我们，自然数 <span class="inlinecode"><span class="id" type="var">nat</span></span> <b>有且仅有</b> 两种构造方式：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">O</span></span> 是一个构造函数。

</li>
</ul>
  它告诉我们，<span class="inlinecode"><span class="id" type="var">O</span></span> 是自然数。(注意：这里是大写字母 <span class="inlinecode"><span class="id" type="var">O</span></span>，不是数字 <span class="inlinecode">0</span>。
  本质上讲，我们现在仅仅是在定义一些符号。这些符号毫无意义。
  它们的意义来自于我们如何使用(通过定义函数)它们。
  如果我们像使用自然数那样使用它们，那么它们“就是”自然数。)
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> 是一个构造函数。

</li>
</ul>
  它告诉我们，如何 <span class="inlinecode"><span class="id" type="var">n</span></span> 是自然数，那么 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 也是自然数。

<div class="paragraph"> </div>

  需要注意的是，与 <span class="inlinecode"><span class="id" type="var">monochrome</span></span> 中的 <span class="inlinecode"><span class="id" type="var">primary</span></span> <span class="inlinecode"><span class="id" type="var">q</span></span> 构造函数不同，
  <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 中的 <span class="inlinecode"><span class="id" type="var">n</span></span> 的类型是我们正在定义的 <span class="inlinecode"><span class="id" type="var">nat</span></span>。
  什么？等等！你要定义 <span class="inlinecode"><span class="id" type="var">nat</span></span>，但是你在定义中又用到了 <span class="inlinecode"><span class="id" type="var">nat</span></span>，这不会造成循环依赖吗?
  让我们再分析一下 <span class="inlinecode"><span class="id" type="var">nat</span></span> 的定义。
  根据第一个构造函数，我们知道 <span class="inlinecode"><span class="id" type="var">O</span></span> 是自然数 (类型是 <span class="inlinecode"><span class="id" type="var">nat</span></span>)。
  根据第二个构造函数，我们知道 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span> 是自然数。
  再根据第二个构造函数，我们知道 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)</span> 是自然数，
  依此类推，我们知道 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span>、<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)))</span>…… 都是自然数。

<div class="paragraph"> </div>

  综上所述，在 <span class="inlinecode"><span class="id" type="var">nat</span></span> 的定义中，
  第一个构造函数给出了一个特定的自然数 <span class="inlinecode"><span class="id" type="var">O</span></span>，
  第二个构造函数根据已知的自然数 <span class="inlinecode"><span class="id" type="var">n</span></span> 构造一个新的自然数 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 
  (也称为 <span class="inlinecode"><span class="id" type="var">n</span></span> 的 <b>后继</b> (Successor))。
  没有循环依赖。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  需要再次强调的是，到目前为止，我们仅仅是定义了一些符号：
  <span class="inlinecode"><span class="id" type="var">O</span></span>、<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span>、<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)</span> 等。
  <span class="inlinecode"><span class="id" type="var">O</span></span>、<span class="inlinecode"><span class="id" type="var">S</span></span> 并无特别之处，你可以将它们换成其它符号。

<div class="paragraph"> </div>

  接下来，我们将在 <span class="inlinecode"><span class="id" type="var">nat</span></span> 上定义函数：
  前驱函数 <span class="inlinecode"><span class="id" type="var">pred</span></span>、加法 <span class="inlinecode"><span class="id" type="var">plus</span></span>、减法 <span class="inlinecode"><span class="id" type="var">minus</span></span>、乘法 <span class="inlinecode"><span class="id" type="var">mult</span></span> 与幂运算 <span class="inlinecode"><span class="id" type="var">exp</span></span>。
  正是这些函数为符号赋予了意义。
  (以后大家在学习数理逻辑的时候，遇到的第一个难点，
  就是区分语法 (符号、公式)与语义 (解释、意义、真假)。)

</div>
<div class="code code-tight">
<span class="id" type="keyword">End</span> <span class="id" type="var">NatPlayground</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">nat</span></span> 实际上刻画了自然数的一进制表示法。
  在一进制下，100 需要表示为一百个S后接一个O。
  为了避免这种麻烦，Coq 允许我们将一进制的 <span class="inlinecode"><span class="id" type="var">nat</span></span> 解析打印为十进制形式。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)))).<br/>
<span class="id" type="keyword">Check</span> 4.<br/>

<br/>
</div>

<div class="doc">
你猜构造函数 <span class="inlinecode"><span class="id" type="var">S</span></span> 的类型是什么？ 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">S</span>.<br/>

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">NatPlayground2</span>.<br/>
</div>

<div class="doc">
  先定义前驱函数 <span class="inlinecode"><span class="id" type="var">pred</span></span>。
  需要注意的是，我们规定 <span class="inlinecode"><span class="id" type="var">O</span></span> 的前驱仍是 <span class="inlinecode"><span class="id" type="var">O</span></span>。
  根据 <span class="inlinecode"><span class="id" type="var">nat</span></span> 的定义，我们知道非零自然数的形式一定是 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>，
  它的前驱是 <span class="inlinecode"><span class="id" type="var">n'</span></span>。 

</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">pred</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> =&gt; <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
  函数 <span class="inlinecode"><span class="id" type="var">plus</span></span> 返回两个自然数 <span class="inlinecode"><span class="id" type="var">n</span></span> 与 <span class="inlinecode"><span class="id" type="var">m</span></span> 的和：
<ul class="doclist">
<li> 第一个分支： <span class="inlinecode"><span class="id" type="var">O</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>

</li>
<li> 第二个分支： <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span>)</span>。

</li>
</ul>
  注意：我们还没有定义 “+”。这里的 “+” 是数学上的加法符号。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">plus</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> =&gt; <span class="id" type="var">S</span> (<span class="id" type="var">plus</span> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
  需要注意的是，<span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> 使用了自身 <span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> (n' &lt; n)，
  是一个递归函数。
  因此，我们使用了关键字 <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>，
  而不是之前在定义函数时使用的 <span class="inlinecode"><span class="id" type="keyword">Definition</span></span>。

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> 是与递归定义紧密相关的概念。
  这里，我们不深究它背后的理论。
  有兴趣的同学，可以选修冯老师的课程或者研究生关于计算理论的课程。 

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  此时，有同学提问：使用关键词 <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> 与 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 定义函数有什么区别?
  答：注意观察 CoqIde 后侧的 "Messages" 窗口。
  除了 "plus is defined"，
  它还显示了一行信息:
  "plus is recursively defined (decreasing on 1st argument)"。
  Coq 要求所有函数都是可计算的 (在这里，你可以理解成函数对于所有输入都会终止)。
  要保证这一点，Coq 要求使用 <span class="inlinecode"><span class="id" type="var">FixPoint</span></span> 定义的递归函数中的某些参数必须是递减的。

<div class="paragraph"> </div>

  Coq 检查到 <span class="inlinecode"><span class="id" type="var">plus</span></span> 的第一个参数是递减的。
  这意味着我们对参数 <span class="inlinecode"><span class="id" type="var">n</span></span> 执行了<b>结构化递归</b> (Structural Induction)。

<div class="paragraph"> </div>

  然而，不存在算法能够判断所有的递归定义的函数是否是可终止的
  (又是神奇的计算理论!)。
  对此，你的新朋友 Coq 也无能为例。
  因此，有些时候我们需要告诉 Coq 一些信息，帮助 Coq 验证某个递归函数确实是可以终止的
  (我们暂时不需要做这些)。

<div class="paragraph"> </div>

 测试 <span class="inlinecode">3</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span>。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Compute</span> (<span class="id" type="var">plus</span> 3 2).<br/>

<br/>
</div>

<div class="doc">
为得出此结论，Coq 所执行的化简步骤如下： 
</div>
<div class="code code-tight">

<br/>

<br/>
</div>

<div class="doc">
  乘法 <span class="inlinecode"><span class="id" type="var">mult</span></span> 的定义方式类似，它用到了刚刚定义的 <span class="inlinecode"><span class="id" type="var">plus</span></span>。
  这里，<span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> 的意思与 <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> <span class="inlinecode">(<span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> 相同。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">mult</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> =&gt; <span class="id" type="var">plus</span> <span class="id" type="var">m</span> (<span class="id" type="var">mult</span> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_mult</span>: (<span class="id" type="var">mult</span> 3 3) = 9.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab30"></a><h4 class="section">练习：1 星, standard (exp)</h4>

  我们将自然数上的幂运算的定义作为练习。
  你需要用到刚刚定义的 <span class="inlinecode"><span class="id" type="var">mult</span></span>。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">exp</span> (<span class="id" type="var">base</span> <span class="id" type="var">power</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;. <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
测试一下。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_exp</span>: (<span class="id" type="var">exp</span> 3 3) = 27.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
你可以在两个表达式之间添加逗号来同时匹配它们
  减法 <span class="inlinecode"><span class="id" type="var">minus</span></span> 的定义稍微有些复杂。
  它需要对两个参数 <span class="inlinecode"><span class="id" type="var">n</span></span> 与 <span class="inlinecode"><span class="id" type="var">m</span></span> 分别做模式匹配。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">minus</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span>, <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span>   , <span class="id" type="var">_</span>    =&gt; <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">_</span> , <span class="id" type="var">O</span>    =&gt; <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span>, <span class="id" type="var">S</span> <span class="id" type="var">m'</span> =&gt; <span class="id" type="var">minus</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab31"></a><h4 class="section">练习：1 星, standard (exp)</h4>

  注意 <span class="inlinecode"><span class="id" type="var">minus</span></span> 是如何使用 <span class="inlinecode"><span class="id" type="keyword">match</span></span> 对两个参数同时做并列模式匹配的。
  当然，你也可以先对 <span class="inlinecode"><span class="id" type="var">n</span></span> 做模式匹配，再嵌套地对 <span class="inlinecode"><span class="id" type="var">m</span></span> 做模式匹配。
  留作练习。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">minus'</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;. <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_minus'</span>: <span class="id" type="var">minus</span> 10 5 = <span class="id" type="var">minus'</span> 10 5.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
<span class="id" type="keyword">End</span> <span class="id" type="var">NatPlayground2</span>.<br/>

<br/>
</div>

<div class="doc">
  我们可以引入通常的加法、减法、乘法 <b>记号</b> (Notation)。
  <span class="inlinecode"><span class="id" type="keyword">level</span></span> 规定了优先级，<span class="inlinecode"><span class="id" type="tactic">left</span></span> <span class="inlinecode"><span class="id" type="keyword">associativity</span></span> 表示“左结合”。
  目前，你不需要了解这些细节。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> &quot;x + y" := (<span class="id" type="var">plus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 50, <span class="id" type="tactic">left</span> <span class="id" type="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> &quot;x - y" := (<span class="id" type="var">minus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 50, <span class="id" type="tactic">left</span> <span class="id" type="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> &quot;x * y" := (<span class="id" type="var">mult</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="tactic">left</span> <span class="id" type="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Check</span> ((0 + 1) + 1).<br/>

<br/>
</div>

<div class="doc">
<a name="lab32"></a><h4 class="section">练习：1 星, standard (factorial)</h4>

    请定义阶乘函数 <span class="inlinecode"><span class="id" type="var">factorial</span></span>：
       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (if n &gt; 0)

</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">factorial</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;. <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_factorial1</span>:          (<span class="id" type="var">factorial</span> 3) = 6.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_factorial2</span>:          (<span class="id" type="var">factorial</span> 5) = (<span class="id" type="var">mult</span> 10 12).<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab33"></a><h4 class="section">练习：2 星, standard (double_plus)</h4>

  完成函数 <span class="inlinecode"><span class="id" type="var">double</span></span> 的定义，它接受参数 <span class="inlinecode"><span class="id" type="var">n</span></span>，返回 <span class="inlinecode">2<span class="id" type="var">n</span></span>。
  请使用递归定义方式，而不是定义为 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span>。 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">double</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab34"></a><h4 class="section">练习：2 星, standard (sum_to)</h4>

  完成函数 <span class="inlinecode"><span class="id" type="var">sum_to</span></span> 的定义，它接受参数 <span class="inlinecode"><span class="id" type="var">n</span></span>，返回 <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">...</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span>。 

</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">sum_to</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">sum_to_10</span> :<br/>
&nbsp;&nbsp;<span class="id" type="var">sum_to</span> 10 = 55.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
我们再来练习定义几个自然数上的函数。
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">eqb</span></span> 判断两个自然数是否相等 (命名中的后缀 ”b“ 表示它返回的是 bool 值)。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">eqb</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> =&gt; <span class="id" type="var">eqb</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab35"></a><h4 class="section">练习：1 星, standard (eqb1)</h4>

  参考 <span class="inlinecode"><span class="id" type="var">minus</span></span>的定义，使用并列模式匹配改写 <span class="inlinecode"><span class="id" type="var">eqb</span></span>，并设计测试用例。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">eqb1</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;. <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">evenb</span></span> 判断给定的自然数 <span class="inlinecode"><span class="id" type="var">n</span></span> 是否为偶数。
  尽管我们知道 <span class="inlinecode"><span class="id" type="var">O</span></span> 为偶数，但是我们无法直接判断 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 是否为偶数，
  因为 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 是否为偶数，取决于 <span class="inlinecode"><span class="id" type="var">pred</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 是否为偶数。
  换句话说，我们需要 <b>递归</b> (Recursively) 定义该函数。
  并且，根据上面的分析，我们需要两个 <b>基础情况</b> (Basic Cases):
  <span class="inlinecode"><span class="id" type="var">O</span></span> 是偶数，<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span> 不是偶数。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">evenb</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span>        =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">O</span>      =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n'</span>) =&gt; <span class="id" type="var">evenb</span> <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_evenb1</span>:   <span class="id" type="var">evenb</span> 2019 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们可以基于 <span class="inlinecode"><span class="id" type="var">evenb</span></span> 定义 <span class="inlinecode"><span class="id" type="var">oddb</span></span>。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">oddb</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" type="var">negb</span> (<span class="id" type="var">evenb</span> <span class="id" type="var">n</span>).<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_oddb1</span>:    <span class="id" type="var">oddb</span> 2019 = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_oddb2</span>:    <span class="id" type="var">oddb</span> 9102 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">leb</span></span> 函数检查第一个参数 <span class="inlinecode"><span class="id" type="var">n</span></span> 是否小于等于第二个参数 <span class="inlinecode"><span class="id" type="var">m</span></span>。
  注意这也是一个递归函数。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">leb</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> =&gt; <span class="id" type="var">leb</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_leb1</span>:             (<span class="id" type="var">leb</span> 2 2) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_leb2</span>:             (<span class="id" type="var">leb</span> 2 4) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_leb3</span>:             (<span class="id" type="var">leb</span> 4 2) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
为 <span class="inlinecode"><span class="id" type="var">eqb</span></span> 与 <span class="inlinecode"><span class="id" type="var">leb</span></span> 引入符号记法。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> &quot;x =? y" := (<span class="id" type="var">eqb</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70) : <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> &quot;x &lt;=? y" := (<span class="id" type="var">leb</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70) : <span class="id" type="var">nat_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_leb3'</span>:  (4 &lt;=? 2) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab36"></a><h4 class="section">练习：1 星, standard (ltb)</h4>

    <span class="inlinecode"><span class="id" type="var">ltb</span></span> 检查第一个参数 <span class="inlinecode"><span class="id" type="var">n</span></span> 是否小于第二个参数 <span class="inlinecode"><span class="id" type="var">m</span></span>。
    请完成它的定义。 

</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">ltb</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;. <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> &quot;x &lt;? y" := (<span class="id" type="var">ltb</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70) : <span class="id" type="var">nat_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ltb1</span>:             (<span class="id" type="var">ltb</span> 2 2) = <span class="id" type="var">false</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ltb2</span>:             (<span class="id" type="var">ltb</span> 2 4) = <span class="id" type="var">true</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ltb3</span>:             (<span class="id" type="var">ltb</span> 4 2) = <span class="id" type="var">false</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab37"></a><h1 class="section">基于化简的证明</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  我们已经定义好了自然数类型。
  下面，我们要正式进入另一个主题：证明。
  在 Coq 中，我们不仅可以编程，我们还可以做证明。
  学习如何做证明是问题求解课程的核心内容之一。

<div class="paragraph"> </div>

  有同学问：为什么要在 Coq 中学习证明？
  在数学课上学习证明不就够了吗？

<div class="paragraph"> </div>

  如果你做过足够长、足够复杂的证明，你就会体会到，证明是多么容易出错。
  证明出了错，要想找到错误，又是何等困难。
  如果在你写证明的时候，能有一位严苛的权威人士始终盯着你的证明，
  帮助你检查每一个证明步骤，直到 <span class="inlinecode"><span class="id" type="keyword">Qed</span></span> 的那一美妙时刻，
  你是不是会对写出来的证明更有信心？

<div class="paragraph"> </div>

  Coq 就是这么一位严苛的权威人士。
  你可以欺骗你自己，但是你欺骗不了 Coq。
  从今往后，你将与 Coq 相爱相杀。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  本节从三个最基本的 <b>证明策略</b> (Proof Tactics) 开始：
  <span class="inlinecode"><span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> 与 <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>。
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="tactic">intros</span></span> 用于引入变量。

</li>
<li> <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> 用于化简。

</li>
<li> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 用于判断等号两边是否相同。

</li>
</ul>

<div class="paragraph"> </div>

  证明策略是在证明过程中，你下达给 Coq 的指令。
  Coq 将执行这些指令。
  如果执行不下去，就意味着你的证明行不通，需要改换思路。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  定理 <span class="inlinecode"><span class="id" type="var">plus_O_n</span></span> 说明：<span class="inlinecode">0</span> (即，<span class="inlinecode"><span class="id" type="var">O</span></span>) 是自然数加法的左单位元。
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> 表明这是一个需要证明的定理。
    <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> 这个关键字本身并不重要，可以是 <span class="inlinecode"><span class="id" type="keyword">Example</span></span>、<span class="inlinecode"><span class="id" type="keyword">Lemma</span></span>、<span class="inlinecode"><span class="id" type="keyword">Fact</span></span>等。

</li>
<li> <span class="inlinecode"><span class="id" type="var">plus_O_n</span></span> 是定理的名字。以后，你可以通过这个名字引用该定理。

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">forall</span></span> 是一阶谓词逻辑里的全称量词符号，读作“对于所有”。

</li>
</ul>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_O_n</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, 0 + <span class="id" type="var">n</span> = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>. &nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. &nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. &nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>. 
<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  我们逐步解释该证明：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="keyword">Proof</span>.</span>：证明开始。

</li>
<li> <span class="inlinecode"><span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="var">n</span>.</span>：我们要证明的定理是一个全称命题：“对于所有的自然数 <span class="inlinecode"><span class="id" type="var">n</span></span>，……”。
    在证明这类命题时，通常的做法是：“假设 <span class="inlinecode"><span class="id" type="var">n</span></span> 是任意自然数，……”。
    在后续的证明“……”中，我们就可以使用 <span class="inlinecode"><span class="id" type="var">n</span></span> 了。
    也就是说，我们将 <span class="inlinecode"><span class="id" type="var">n</span></span> 从 <b>证明目标</b> (Goal) 
    移到了 <b>证明上下文</b> (Context) 中。
    <span class="inlinecode"><span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="var">n</span>.</span> 的作用就是“引入任意自然数 <span class="inlinecode"><span class="id" type="var">n</span></span>”。
    (两年以后，面对《数理逻辑十二讲》的第四讲，
    小明将会回想起问题求解习题课带他见识Coq证明的那个睡意惺忪的清晨。)

</li>
<li> <span class="inlinecode"><span class="id" type="tactic">simpl</span>.</span>：根据加法 <span class="inlinecode"><span class="id" type="var">plus</span></span> 的定义 (模式匹配的第一种情况)，
    等号左边 <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> 可以化简为 <span class="inlinecode"><span class="id" type="var">n</span></span>。

</li>
<li> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span>.</span>： 等号左右两边都是 <span class="inlinecode"><span class="id" type="var">n</span></span>。

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">Qed</span>.</span>：证毕。

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  实际上，<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 在判断等号两边是否相同时，
  会先尝试对等号两边进行化简。
  因此，有些时候，<span class="inlinecode"><span class="id" type="tactic">simpl</span></span> 可以省略。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_O_n'</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, 0 + <span class="id" type="var">n</span> = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  类似地，我们可以证明定理 <span class="inlinecode"><span class="id" type="var">mult_0_l</span></span>：<span class="inlinecode">0</span> 是自然数乘法的左零元。
  (定理名中的后缀 <span class="inlinecode"><span class="id" type="var">_l</span></span> 表示 left。)

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_0_l</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, 0 * <span class="id" type="var">n</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  请解释定理 <span class="inlinecode"><span class="id" type="var">plus_1_l</span></span> 及其证明过程。
  (你要确保理解每一个证明步骤。这次没有 Coq 盯着你。
  你可以欺骗我，但你不能欺骗你自己。)

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_l</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, 1 + <span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab38"></a><h1 class="section">基于改写 (Rewriting) 的证明</h1>
 <b>改写</b> (Rewriting) 指的是用等号的一端替换等号的另一端。
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  定理 <span class="inlinecode"><span class="id" type="var">plus_id_example</span></span> 读作：
  对于所有的自然数 <span class="inlinecode"><span class="id" type="var">n</span></span> 与 <span class="inlinecode"><span class="id" type="var">m</span></span>，
  如果 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>，那么 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> = <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span>。

<div class="paragraph"> </div>

  首先，这个定理是一个条件句：如果 A，那么 B。
  要证明这类结论，我们通常是将 A 作为已知条件，然后证明 B 成立。
  用 Coq 的语言来讲，就是把 A 从待证目标 (Goal) 移到上下文 (Context) 中。
  我们又需要用到 <span class="inlinecode"><span class="id" type="tactic">intros</span></span> 策略。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_id_example</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> + <span class="id" type="var">n</span> = <span class="id" type="var">m</span> + <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> -&gt; <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">H</span></span> 策略中的箭头 <span class="inlinecode">-&gt;</span> 表示从左往右应用 Rewriting，
  即在目标中，将等式 <span class="inlinecode"><span class="id" type="var">H</span></span> 的左边 (即，<span class="inlinecode"><span class="id" type="var">n</span></span>) 替换成等式 <span class="inlinecode"><span class="id" type="var">H</span></span> 的右边 (即，<span class="inlinecode"><span class="id" type="var">m</span></span>)。
  如果要改变 Rewriting 的方向，则使用 <span class="inlinecode">&lt;-</span> 箭头。

<div class="paragraph"> </div>

  另外，<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> 默认为 <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">H</span></span>。

<div class="paragraph"> </div>

<a name="lab39"></a><h4 class="section">练习：1 星, standard (plus_id_exercise)</h4>

  删除 "<span class="inlinecode"><span class="id" type="var">Admitted</span>.</span>"，完成定理 <span class="inlinecode"><span class="id" type="var">plus_id_exercise</span></span> 的证明。
  (<span class="inlinecode"><span class="id" type="var">Admitted</span></span> 表示暂时跳过该定理的证明，而将其将其作为已知条件。) 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_id_exercise</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> -&gt; <span class="id" type="var">m</span> = <span class="id" type="var">o</span> -&gt; <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">o</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  如前所述，<b>改写</b> (Rewriting)' 指的是用等号的一端替换等号的另一端。
  这里的等式可以是之前证明过的定理。
  比如定理 <span class="inlinecode"><span class="id" type="var">mult_O_plus</span></span> 的证明用到了之前证明过的 <span class="inlinecode"><span class="id" type="var">plus_O_n</span></span>。

<div class="paragraph"> </div>

  (是不是已经忘记了 <span class="inlinecode"><span class="id" type="var">plus_O_n</span></span> 说了些什么？没关系，这很正常。
  这些都是为了教学构造出来的没有多大实际意义的例子。
  忘了的话，就试试 <span class="inlinecode"><span class="id" type="keyword">Check</span></span> <span class="inlinecode"><span class="id" type="var">plus_O_n</span></span>。)

</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">plus_O_n</span>.<br/>
</div>

<div class="doc">
=&gt; forall n : nat, 0 + n = n. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_O_plus</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;(0 + <span class="id" type="var">n</span>) * <span class="id" type="var">m</span> = <span class="id" type="var">n</span> * <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> -&gt; <span class="id" type="var">plus_O_n</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  需要注意的是，<span class="inlinecode"><span class="id" type="var">plus_O_n</span></span> 是关于 <span class="inlinecode"><span class="id" type="var">n</span></span> 的全称语句。
  在 Rewriting 时，Coq 会通过匹配当前的证明目标来尝试
  <b>实例化</b> (Instantiate) <span class="inlinecode"><span class="id" type="var">n</span></span>。 
<div class="paragraph"> </div>

<a name="lab40"></a><h4 class="section">练习：2 星, standard (mult_S_1)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_S_1</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> * (1 + <span class="id" type="var">n</span>) = <span class="id" type="var">m</span> * <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab41"></a><h1 class="section">分情形分析 (Case Analysis) 证明法</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  不用想也知道，使用 <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>、<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>、<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>
  只能证明一些 “Too Simple，Sometimes Naive” 的定理。
  我们需要学习更高级的证明策略。

<div class="paragraph"> </div>

  先尝试使用已学过的证明策略证明下述定理。
  你会发现 <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> 不起作用。
  这是因为，<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> 中的 <span class="inlinecode"><span class="id" type="var">n</span></span> 是任意自然数。
  在 <span class="inlinecode"><span class="id" type="var">plus</span></span> 的定义中，Coq 无法确定使用哪一条模式匹配进行化简。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">Nat.add</span>. </div>

<div class="doc">
与 <span class="inlinecode"><span class="id" type="var">plus</span></span> 相同 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_neq_0_firsttry</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">n</span> + 1) =? 0 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="keyword">Abort</span>. 
<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  解决的方法也很自然：对 <span class="inlinecode"><span class="id" type="var">n</span></span> 分情况分析。
<ul class="doclist">
<li> 如果 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">O</span></span>：使用 <span class="inlinecode"><span class="id" type="var">plus</span></span> 的第一条模式匹配进行化简。

</li>
<li> 如果 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>：使用 <span class="inlinecode"><span class="id" type="var">plus</span></span> 的第二条模式匹配进行化简。

</li>
</ul>

<div class="paragraph"> </div>

  对自然数 <span class="inlinecode"><span class="id" type="var">n</span></span> 进行分情况分析，
  用 Coq 的语言来讲，就是 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>。 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_neq_0</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">n</span> + 1) =? 0 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>] <span class="id" type="var">eqn</span>:<span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  由于 <span class="inlinecode"><span class="id" type="var">nat</span></span> 的定义中包含两个构造函数，
  所以，<span class="inlinecode"><span class="id" type="var">n</span></span> 有两种构成方式。
  在使用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 分情况分析时，Coq 会产生两个子目标，
  分别对应 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">O</span></span> 与 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 两种情况。

<div class="paragraph"> </div>

  记号 "<span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">n'</span>]</span> <span class="inlinecode"><span class="id" type="var">eqn</span>:<span class="id" type="var">E</span></span>" 使用 <span class="inlinecode">|</span> 区分了两种情况，
  并将每种情况下与 <span class="inlinecode"><span class="id" type="var">n</span></span> 有关的等式命名为 <span class="inlinecode"><span class="id" type="var">E</span></span>。
  在第一种情况中，<span class="inlinecode"><span class="id" type="var">E</span></span> 为 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">O</span></span>。
  由于 <span class="inlinecode"><span class="id" type="var">O</span></span> 构造函数没有参数，所以 <span class="inlinecode"></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 中 <span class="inlinecode">|</span> 的左边为空。
  在第二种情况中，<span class="inlinecode"><span class="id" type="var">E</span></span> 为 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>。
  其中，<span class="inlinecode"><span class="id" type="var">n'</span></span> 是 <span class="inlinecode"></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 中的 <span class="inlinecode"><span class="id" type="var">n'</span></span>，对应于构造函数 <span class="inlinecode"><span class="id" type="var">S</span></span> 的参数。 

<div class="paragraph"> </div>

  另外，在上面的证明中，我们使用并列的两个 <span class="inlinecode">-</span> 标记了两种情况，
  使得证明的结构更为清晰。
  从语法上讲，<span class="inlinecode">-</span> 并不是必须的。
  但是，强烈建议大家在使用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 策略时，同时使用 <span class="inlinecode">-</span>。
  如果需要嵌套地分情况分析，可以使用 <span class="inlinecode">+</span>、<span class="inlinecode">*</span>、<span class="inlinecode">{}</span> 等 (我们马上就会碰到)。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 策略可用于任何归纳 (Inductive) 定义的数据类型。
  定理 <span class="inlinecode"><span class="id" type="var">negb_involutive</span></span> 的证明使用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 对布尔值分情况分析。 

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">negb_involutive</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">negb</span> (<span class="id" type="var">negb</span> <span class="id" type="var">b</span>) = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  注意：我们省略了 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 的 <span class="inlinecode"><span class="id" type="keyword">as</span></span> 子句。
  我们可以写 <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[|]</span> 或者 <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[]</span>。

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 可以嵌套使用。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_commutative</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>, <span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">andb</span> <span class="id" type="var">c</span> <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Eb</span>. &nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ec</span>. &nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ec</span>. &nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们也可以用匹配的花括号区别每个子目标对应的证明。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_commutative'</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>, <span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">andb</span> <span class="id" type="var">c</span> <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Eb</span>.<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">reflexivity</span>. } } <br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">reflexivity</span>. } }<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
此外，花括号有限定范围的作用，它允许我们在一个证明中的多个层级下使用同一种标号： 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb3_exchange</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span>, <span class="id" type="var">andb</span> (<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) <span class="id" type="var">d</span> = <span class="id" type="var">andb</span> (<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">d</span>) <span class="id" type="var">c</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Eb</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">d</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">d</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">d</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">d</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. }<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  在很多证明中，我们在引入变量之后会立即对该变量进行情况分析。
  例如： intros x y. destruct y as <span class="inlinecode">|<span class="id" type="var">y</span></span> eqn:E.
  Coq 提供了一种简便的记法： intros x <span class="inlinecode">|<span class="id" type="var">y</span></span>.
  也就是说，我们可以在引入变量的同时对它进行情况分析。
  (在 Coq 的术语中，这被称为 <b>intro pattern</b>。)

<div class="paragraph"> </div>

  需要注意的是，上述简便记法丢失了 <span class="inlinecode"><span class="id" type="var">eqn</span>:<span class="id" type="var">E</span></span> 信息。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">eqb</span>.<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_neq_0'</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">n</span> + 1) =? 0 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [|<span class="id" type="var">n</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
如果没有需要命名的参数，我们只需写 <span class="inlinecode">[]</span>。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_commutative''</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>, <span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">andb</span> <span class="id" type="var">c</span> <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [] [].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab42"></a><h4 class="section">练习：2 星, standard (andb_true_elim2)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_true_elim2</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> -&gt; <span class="id" type="var">c</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab43"></a><h4 class="section">练习：1 星, standard (zero_nbeq_plus_1)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">zero_nbeq_plus_1</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;0 =? (<span class="id" type="var">n</span> + 1) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab44"></a><h4 class="section">练习：3 星, standard, optional (andb_eq_orb)</h4>

    请证明定理 <span class="inlinecode"><span class="id" type="var">andb_eq_orb</span></span>。
    可能有一点点难度 (是不是很兴奋？)，试试看吧。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_eq_orb</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">b</span> <span class="id" type="var">c</span> : <span class="id" type="var">bool</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">orb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> = <span class="id" type="var">c</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>
</div>

</div>

</body>
</html>