<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Basics</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Basics</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">数据类型与自然数 (Data Types and Naturals)</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">引言</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  '程序 = 算法 + 数据结构' by ???

<div class="paragraph"> </div>

  如何说算法是一张食谱，那么数据就是食材。
  所谓'巧妇难为无米之炊'，没有数据，算法就无用武之地。
  正如食材各式各样，数据也有各种 _类型_ (在本教材中，我们使用数据类型的说法，而不是数据结构)。

<div class="paragraph"> </div>

  数据类型包含两部分含义： 
<ul class="doclist">
<li> 数据 (也称 _值_) 构成的集合； 

</li>
<li> 定义在这些数据上的操作。

</li>
</ul>

<div class="paragraph"> </div>

  比如自然数是一种数据类型，它的数据集合是 {0, 1, 2, ...}，
  它允许的操作包括前驱、后继、加法、减法 (受限的减法)、乘法、幂运算等。

<div class="paragraph"> </div>

  同样重要的是，自然数作为一种数据类型，它 _不包括_ -1、0.5、2/3、e 等数据，
  也_不支持_除法、拼接、旋转等操作。

<div class="paragraph"> </div>

  在程序设计语言里， _类型检查 (Type Checking)_ 的工作就是检查：
<ul class="doclist">
<li> 是否使用了无效的 (invalid) 数据； 

</li>
<li> 是否进行了非法的 (unsupported) 操作。

</li>
</ul>

<div class="paragraph"> </div>

  本章介绍如何在 Coq (内置的 <i>'Gallina'</i> 程序设计语言) 中定义数据类型。
  同时，本章还将介绍如何在 Coq 中做证明。
  我们以自然数数据类型为例。

<div class="paragraph"> </div>

    其它常见的函数式语言特性包括<i>'代数数据类型（Algebraic Data Type）'</i>，
    能让构造和处理丰富数据结构更加简单的<i>'模式匹配（Pattern Matching）'</i>，
    以及用来支持抽象和代码复用的复杂的<i>'多态类型系统（Polymorphic Type System）'</i>。

<div class="paragraph"> </div>


</div>
<div class="code">
</div>

<div class="doc">
<a name="lab3"></a><h1 class="section">数据与函数</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  Coq 的标准库 (Standard Library) 中内置了一些常用的数据类型，
  比如布尔类型、自然数、列表、散列表等。

<div class="paragraph"> </div>

  要定义一个数据类型，我们需要：
<ul class="doclist">
<li> 定义数据集合

</li>
<li> 定义操作

</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h2 class="section">枚举类型</h2>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h3 class="section">一周七日</h3>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  以下声明 (Declaration) 定义了一个名为 <span class="inlinecode"><span class="id" title="var">day</span></span> 的数据类型。
  它的数据构成的集合为 {<span class="inlinecode"><span class="id" title="var">monday</span></span>, <span class="inlinecode"><span class="id" title="var">tuesday</span></span>, <span class="inlinecode"><span class="id" title="var">wednesday</span></span>, <span class="inlinecode"><span class="id" title="var">thursday</span></span>, <span class="inlinecode"><span class="id" title="var">friday</span></span>, <span class="inlinecode"><span class="id" title="var">saturday</span></span>, <span class="inlinecode"><span class="id" title="var">sunday</span></span>}。
  <span class="inlinecode"><span class="id" title="var">day</span></span> 是 <i>'枚举'(Enumerate)_ 数据类型，因为我们直接在定义中一一列举了它包含的值。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">day</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">monday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">tuesday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">wednesday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">thursday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">friday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">saturday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">sunday</span>.<br/>

<br/>
</div>

<div class="doc">
  下面，我们定义一个名为 <span class="inlinecode"><span class="id" title="var">next_day</span></span> 的操作，也称为函数。
  该操作接受一个类型为 <span class="inlinecode"><span class="id" title="var">day</span></span> 的数据 <span class="inlinecode"><span class="id" title="var">d</span></span> (称为_参数 (parameter)_)，返回一个类型为 <span class="inlinecode"><span class="id" title="var">day</span></span> 的数据 (称为_返回值_)。 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">next_day</span> (<span class="id" title="var">d</span>:<span class="id" title="var">day</span>) : <span class="id" title="var">day</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">d</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">monday</span>    =&gt; <span class="id" title="var">tuesday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">tuesday</span>   =&gt; <span class="id" title="var">wednesday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">wednesday</span> =&gt; <span class="id" title="var">thursday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">thursday</span>  =&gt; <span class="id" title="var">friday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">friday</span>    =&gt; <span class="id" title="var">saturday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">saturday</span>  =&gt; <span class="id" title="var">sunday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">sunday</span>    =&gt; <span class="id" title="var">monday</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="var">next_day</span></span> <span class="inlinecode"><span class="id" title="var">saturday</span></span> 的结果应该是 <span class="inlinecode"><span class="id" title="var">sunday</span></span>。
  我们可以用 <span class="inlinecode"><span class="id" title="keyword">Compute</span></span> 指令查看该结果。

</div>
<div class="code">
<span class="id" title="keyword">Compute</span> (<span class="id" title="var">next_day</span> <span class="id" title="var">saturday</span>).<br/>

<br/>
</div>

<div class="doc">
  <span class="inlinecode">(<span class="id" title="var">next_day</span></span> <span class="inlinecode">(<span class="id" title="var">next_day</span></span> <span class="inlinecode"><span class="id" title="var">saturday</span>))</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" title="var">next_day</span></span> <span class="inlinecode"><span class="id" title="var">sunday</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">monday</span>.</span> Sad!

</div>
<div class="code">
<span class="id" title="keyword">Compute</span> (<span class="id" title="var">next_day</span> (<span class="id" title="var">next_day</span> <span class="id" title="var">saturday</span>)).<br/>

<br/>
</div>

<div class="doc">
第二，我们可以将<i>'期望'</i>的结果写成 Coq 的示例： 
<div class="paragraph"> </div>

  我们可以做单元测试 (Unit Test)。
  下面的 <span class="inlinecode"><span class="id" title="keyword">Example</span></span> 定义了一个断言 (Assertioin)： 
  <span class="inlinecode"><span class="id" title="var">saturday</span></span> 的明天的明天是 <span class="inlinecode"><span class="id" title="var">monday</span></span>。
  我们还给这个断言起了个名字： time_files。
  以后，我们可以使用 time_files 引用该断言。

</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">time_flies</span>:<br/>
&nbsp;&nbsp;(<span class="id" title="var">next_day</span> (<span class="id" title="var">next_day</span> <span class="id" title="var">saturday</span>)) = <span class="id" title="var">monday</span>.<br/>

<br/>
</div>

<div class="doc">
  我们需要 _证明_ 该断言是真的。
  证明很简单，分为两步：

<div class="paragraph"> </div>

  证明：
<ul class="doclist">
<li> 化简。等号左边的 <span class="inlinecode">(<span class="id" title="var">next_day</span></span> <span class="inlinecode">(<span class="id" title="var">next_day</span></span> <span class="inlinecode"><span class="id" title="var">saturday</span>))</span> 可以化简为 <span class="inlinecode"><span class="id" title="var">monday</span></span>。

</li>
<li> 相同性判断。等号左边的 <span class="inlinecode"><span class="id" title="var">monday</span></span> 与 等号右边的 <span class="inlinecode"><span class="id" title="var">monday</span></span> 相同。

</li>
</ul>
  证毕。

</div>
<div class="code">
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  Coq 是 _交互式定理证明 (Interactive Theorem Proving; ITP)_ 工具，
  也称为 _证明助手 (Proof Assistant)_。

<div class="paragraph"> </div>

  要想使用 Coq 证明某个定理，你需要：
<ul class="doclist">
<li> 清楚该定理的证明过程

</li>
<li> 清楚 Coq 支持的证明策略 (Proof Tactics)

</li>
<li> 将证明过程翻译成 Coq 支持的证明策略

</li>
</ul>

<div class="paragraph"> </div>

  比如上例中的 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 表示化简，<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 判断相同性。
  <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> 表示证明开始，<span class="inlinecode"><span class="id" title="keyword">Qed</span></span> 表示证毕 (哇，多么美妙的词语)。

</div>
<div class="code">
</div>

<div class="doc">
<a name="lab6"></a><h2 class="section">作业提交指南</h2>

<div class="paragraph"> </div>

 如果你在课堂中使用《软件基础》，你的讲师可能会用自动化脚本来为你的作业评分。
    为了让这些脚本能够正常工作（这样你才能拿到全部学分！），请认真遵循以下规则：
<ul class="doclist">
<li> 评分脚本在提取你提交的 <span class="inlinecode">.<span class="id" title="var">v</span></span> 文件时会用到其中的特殊标记。因此请勿修改练习的
        “分隔标记”，如练习的标题、名称、以及末尾的 <span class="inlinecode">[]</span> 等等。

</li>
<li> 不要删除练习。如果你想要跳过某个练习（例如它标记为可选或你无法解决它），
        可以在 <span class="inlinecode">.<span class="id" title="var">v</span></span> 文件中留下部分证明，这没关系，不过此时请确认它以 <span class="inlinecode"><span class="id" title="var">Admitted</span></span>
        结尾（不要用 <span class="inlinecode"><span class="id" title="keyword">Abort</span></span> 之类的东西）。

</li>
<li> 你也可以在解答中使用附加定义（如辅助函数，需要的引理等）。
        你可以将它们放在练习的头部和你要证明的定理之间。

</li>
</ul>

<div class="paragraph"> </div>

    You will also notice that each chapter (like <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>) is
    accompanied by a <i>test script</i> (<span class="inlinecode"><span class="id" title="var">BasicsTest.v</span></span>) that automatically
    calculates points for the finished homework problems in the
    chapter.  These scripts are mostly for the auto-grading
    infrastructure that your instructor may use to help process
    assignments, but you may also like to use them to double-check
    that your file is well formatted before handing it in.  In a
    terminal window either type <span class="inlinecode"><span class="id" title="var">make</span></span> <span class="inlinecode"><span class="id" title="var">BasicsTest.vo</span></span> or do the
    following:

<div class="paragraph"> </div>

       coqc -Q . LF Basics.v
       coqc -Q . LF BasicsTest.v

<div class="paragraph"> </div>

    There is no need to hand in <span class="inlinecode"><span class="id" title="var">BasicsTest.v</span></span> itself (or <span class="inlinecode"><span class="id" title="var">Preface.v</span></span>).

<div class="paragraph"> </div>

    <i>If your class is using the Canvas system to hand in assignments</i>:
<ul class="doclist">
<li> If you submit multiple versions of the assignment, you may
        notice that they are given different names.  This is fine: The
        most recent submission is the one that will be graded.

</li>
<li> To hand in multiple files at the same time (if more than one
        chapter is assigned in the same week), you need to make a
        single submission with all the files at once using the button
        "Add another file" just above the comment box. 
</li>
</ul>

</div>
<div class="code">
</div>

<div class="doc">
<a name="lab7"></a><h3 class="section">布尔类型</h3>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  下面的声明定义了布尔类型 <span class="inlinecode"><span class="id" title="var">bool</span></span>，它包含两个值 <span class="inlinecode"><span class="id" title="var">true</span></span> 与 <span class="inlinecode"><span class="id" title="var">false</span></span>。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  常用的布尔函数包括： <span class="inlinecode"><span class="id" title="var">negb</span></span> 取反； <span class="inlinecode"><span class="id" title="var">andb</span></span> 并且； <span class="inlinecode"><span class="id" title="var">orb</span></span> 或者。
  它们的定义如下所示。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">negb</span> (<span class="id" title="var">b</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">andb</span> (<span class="id" title="var">b1</span>:<span class="id" title="var">bool</span>) (<span class="id" title="var">b2</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">b2</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">orb</span> (<span class="id" title="var">b1</span>:<span class="id" title="var">bool</span>) (<span class="id" title="var">b2</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">b2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  我们以 <span class="inlinecode"><span class="id" title="var">orb</span></span> 为例进行“单元测试”与证明。
  这四个测试用例实际上构成了 <span class="inlinecode"><span class="id" title="var">orb</span></span> 的真值表 (Truth Table)。

<div class="paragraph"> </div>

  注意： <span class="inlinecode"><span class="id" title="var">orb</span></span> 函数接受两个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的参数。
  <span class="inlinecode"><span class="id" title="var">orb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> 表示将函数 <span class="inlinecode"><span class="id" title="var">orb</span></span> 应用 (Apply) 到参数 <span class="inlinecode"><span class="id" title="var">true</span></span> 与 <span class="inlinecode"><span class="id" title="var">false</span></span> 上。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb1</span>:  (<span class="id" title="var">orb</span> <span class="id" title="var">true</span> <span class="id" title="var">false</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb2</span>:  (<span class="id" title="var">orb</span> <span class="id" title="var">false</span> <span class="id" title="var">false</span>) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb3</span>:  (<span class="id" title="var">orb</span> <span class="id" title="var">false</span> <span class="id" title="var">true</span>)  = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb4</span>:  (<span class="id" title="var">orb</span> <span class="id" title="var">true</span>  <span class="id" title="var">true</span>)  = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  我们可以使用 <span class="inlinecode"><span class="id" title="var">Natation</span></span> 为布尔函数引入更常见的符号。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x &amp;&amp; y" := (<span class="id" title="var">andb</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;x || y" := (<span class="id" title="var">orb</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb5</span>:  <span class="id" title="var">false</span> || <span class="id" title="var">false</span> || <span class="id" title="var">true</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab8"></a><h4 class="section">练习：1 星, standard (nandb)</h4>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  要想熟练使用 Coq，不做练习是不可能的。

<div class="paragraph"> </div>

  现在，你需要定义一个布尔函数 <span class="inlinecode"><span class="id" title="var">nandb</span></span>：
  只有当两个参数都是 <span class="inlinecode"><span class="id" title="var">false</span></span> 时，它才返回 <span class="inlinecode"><span class="id" title="var">true</span></span>；
  否则，它返回 <span class="inlinecode"><span class="id" title="var">false</span></span>。
  你可以使用之前定义过的布尔函数 <span class="inlinecode"><span class="id" title="var">negb</span></span>、<span class="inlinecode"><span class="id" title="var">andb</span></span>、<span class="inlinecode"><span class="id" title="var">orb</span></span>。

<div class="paragraph"> </div>

  指令 <span class="inlinecode"><span class="id" title="var">Admitted</span></span> 是证明中的占位符。
  你的任务就是将它替换成真正的证明。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nandb</span> (<span class="id" title="var">b1</span>:<span class="id" title="var">bool</span>) (<span class="id" title="var">b2</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nandb1</span>:               (<span class="id" title="var">nandb</span> <span class="id" title="var">true</span> <span class="id" title="var">false</span>) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nandb2</span>:               (<span class="id" title="var">nandb</span> <span class="id" title="var">false</span> <span class="id" title="var">false</span>) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nandb3</span>:               (<span class="id" title="var">nandb</span> <span class="id" title="var">false</span> <span class="id" title="var">true</span>) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nandb4</span>:               (<span class="id" title="var">nandb</span> <span class="id" title="var">true</span> <span class="id" title="var">true</span>) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab9"></a><h2 class="section">类型</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  Coq 中的每个表达式都有类型。
  我们可以使用 <span class="inlinecode"><span class="id" title="keyword">Check</span></span> 指令查看表达式的类型。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">negb</span> <span class="id" title="var">true</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  Coq (内置的 <i>'Gallina'</i> ) 是 _函数式(Functional)_ 程序设计语言。
  在函数式程序设计语言中，函数也是数据，也有类型。
  更多关于函数式程序设计的内容，我们会在后续课程与 Coq 教材中学习。

<div class="paragraph"> </div>

  函数 <span class="inlinecode"><span class="id" title="var">negb</span></span> 的类型是 <i>'函数类型'</i> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>。
  这是由 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型构成的复合类型，
  它告诉我们： <span class="inlinecode"><span class="id" title="var">negb</span></span> 是一个函数，它接受一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的参数，
  返回一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的值。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">negb</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  类似地，<span class="inlinecode"><span class="id" title="var">andb</span></span> 的类型是 <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>，
  它告诉我们：<span class="inlinecode"><span class="id" title="var">andb</span></span> 是一个函数，它接受两个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的参数，
  返回一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的值。

<div class="paragraph"> </div>

  关于 <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 的另一种“更函数式的”理解方式，
  我们将在函数式程序设计章节中介绍。
  此处仅简单提及。
  实际上，<span class="inlinecode">-&gt;</span> 运算符是右结合的。
  也就是说，<span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 实际上是 <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span>。
  它告诉我们：<span class="inlinecode"><span class="id" title="var">andb</span></span> 是一个函数，它接受一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的参数，
  返回一个类型为 <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> 的函数 
  (没错，在函数式程序设计中，函数可以作为返回值。是不是很优雅？)。
  这个返回的函数又可以接受一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的参数，返回一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的值。

</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="var">andb</span>.<br/>
</div>

<div class="doc">
<a name="lab10"></a><h2 class="section">由旧类型构造新类型</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在现实生活中，问题层出不穷。
  不同的问题可能使用不同的数据类型。
  我们不希望每次都从头构造一个数据类型，而是希望能基于已有的数据类型定义新的数据类型。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="var">rgb</span></span> 仍然是简单的枚举类型。

</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">rgb</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="tactic">red</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">green</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">blue</span>.<br/>

<br/>
</div>

<div class="doc">
  <span class="inlinecode"><span class="id" title="var">color</span></span> 与我们之前定义的数据类型不同。
  除了我们已经熟悉的 <span class="inlinecode"><span class="id" title="var">black</span></span>、<span class="inlinecode"><span class="id" title="var">white</span></span> 形式之外，
  它还包含 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">rgb</span>)</span>。

</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">color</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">black</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">white</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">primary</span> (<span class="id" title="var">p</span> : <span class="id" title="var">rgb</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  这里，我们需要介绍一点理论知识。(很简单，不要害怕。)

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" title="var">color</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> 告诉 Coq：
  _归纳(Inductively)_ 地定义 (也称 <i>'构造'</i>) 名为 <span class="inlinecode"><span class="id" title="var">color</span></span> 的数据类型。

<div class="paragraph"> </div>

  在归纳定义中，我们需要给出构造 <span class="inlinecode"><span class="id" title="var">color</span></span> 类型的数据的方法 (也称 <i>'构造函数'</i>)：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">black</span></span> 是一个构造函数。它表示 <span class="inlinecode"><span class="id" title="var">black</span></span> 是类型为 <span class="inlinecode"><span class="id" title="var">color</span></span> 的值。

</li>
<li> <span class="inlinecode"><span class="id" title="var">white</span></span> 是一个构造函数。它表示 <span class="inlinecode"><span class="id" title="var">white</span></span> 是类型为 <span class="inlinecode"><span class="id" title="var">color</span></span> 的值。

</li>
<li> <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">rgb</span>)</span> 是一个构造函数。
    它表示，如果 <span class="inlinecode"><span class="id" title="var">p</span></span> 是类型为 <span class="inlinecode"><span class="id" title="var">rgb</span></span> 的值，那么 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> 就是类型为 <span class="inlinecode"><span class="id" title="var">color</span></span> 的值。例如，<span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="tactic">red</span></span>、<span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">green</span></span>、<span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">blue</span></span> 都是类型为 <span class="inlinecode"><span class="id" title="var">color</span></span> 的值。

</li>
</ul>

<div class="paragraph"> </div>

  同样重要的是，<span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" title="var">color</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> 还告诉 Coq：
  类型为 <span class="inlinecode"><span class="id" title="var">color</span></span> 的值有且 _仅有_ 以上三种构造方式。
  例如，<span class="inlinecode"><span class="id" title="var">sunday</span></span>、<span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">saturday</span></span>、<span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> 都不是类型为 <span class="inlinecode"><span class="id" title="var">color</span></span> 的值。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在定义函数时，我们可以针对每个构造函数使用 <i>'模式匹配'。
  函数 <span class="inlinecode"><span class="id" title="var">monochrome</span></span> 接受一个类型为 <span class="inlinecode"><span class="id" title="var">color</span></span> 的参数 <span class="inlinecode"><span class="id" title="var">c</span></span>。
  根据上面的分析，<span class="inlinecode"><span class="id" title="var">c</span></span> 有且仅有三种可能的构造方式。
  <span class="inlinecode"><span class="id" title="keyword">match</span></span> 分别考虑这三种构造方式：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">black</span></span> 只可能与 <span class="inlinecode"><span class="id" title="var">black</span></span> 匹配。

</li>
<li> <span class="inlinecode"><span class="id" title="var">white</span></span> 只可能与 <span class="inlinecode"><span class="id" title="var">white</span></span> 匹配。

</li>
<li> <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> 只可能与 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">xxx</span></span> 匹配。

</li>
</ul>
  这里，<span class="inlinecode"><span class="id" title="var">q</span></span> 为变量，它的类型是 <span class="inlinecode"><span class="id" title="var">rgb</span></span> (Coq 可以自动推断出这一点)。
  当 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> 与 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">xxx</span></span> 匹配时，<span class="inlinecode"><span class="id" title="var">q</span></span> 被 <i>'绑定'(bind)_ 到 <span class="inlinecode"><span class="id" title="var">xxx</span></span>。
  你可以在 <span class="inlinecode">=&gt;</span> 的右边使用 <span class="inlinecode"><span class="id" title="var">q</span></span>。
  在本例中，我们并没有在 <span class="inlinecode">=&gt;</span> 的右边使用 <span class="inlinecode"><span class="id" title="var">q</span></span>。
  在这种情况下，我们可以使用通配符 <span class="inlinecode"><span class="id" title="var">_</span></span> 代替 <span class="inlinecode"><span class="id" title="var">q</span></span>。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">monochrome</span> (<span class="id" title="var">c</span> : <span class="id" title="var">color</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">black</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">white</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">primary</span> <span class="id" title="var">q</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
  我们还可以对 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> 进行更细致的模式匹配。
  函数 <span class="inlinecode"><span class="id" title="var">isred</span></span> 中的 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> 用于匹配除 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="tactic">red</span></span> 之外的由
  <span class="inlinecode"><span class="id" title="var">primary</span></span> 构造的 <span class="inlinecode"><span class="id" title="var">color</span></span>，即 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">green</span></span> 与 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">blue</span></span>。

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isred</span> (<span class="id" title="var">c</span> : <span class="id" title="var">color</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">black</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">white</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">primary</span> <span class="id" title="tactic">red</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">primary</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab11"></a><h2 class="section">模块</h2>

<div class="paragraph"> </div>

 Coq 提供了<i>'模块系统'</i>来帮助组织大规模的开发。
    如果我们将一组定义放在 <span class="inlinecode"><span class="id" title="keyword">Module</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> 和 <span class="inlinecode"><span class="id" title="keyword">End</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> 标记之间，那么在文件中的
    <span class="inlinecode"><span class="id" title="keyword">End</span></span> 之后，我们就可以通过像 <span class="inlinecode"><span class="id" title="var">X.foo</span></span> 这样的名字来引用，而不必直接用
    <span class="inlinecode"><span class="id" title="var">foo</span></span> 了。在这里，我们通过此特性在内部模块中引入了 <span class="inlinecode"><span class="id" title="var">nat</span></span> 类型的定义，
    这样就不会覆盖标准库中的同名定义了。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatPlayground</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h2 class="section">自然数 (Naturals)</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  现在，我们要定义自然数数据类型。好戏刚刚开场。

<div class="paragraph"> </div>

  自然数类型与之前我们定义的数据类型有一个很大的区别，
  那就是自然数有无穷多个 (在后续课程中，我们会知道，自然数有可数无穷多个)。
  我们无法以一一列举的方式定义自然数类型。
  怎么办？怎么才能在有限的纸张上写下无穷多个自然数？
  (“以”)
  答案是：归纳定义。<span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>关键词的威力在这里得以显现。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>).<br/>

<br/>
</div>

<div class="doc">
  So Easy! 我们来解读一下。
  这个归纳定义告诉我们，自然数 <span class="inlinecode"><span class="id" title="var">nat</span></span> _有且仅有_ 两种构造方式：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">O</span></span> 是一个构造函数。

</li>
</ul>
  它告诉我们，<span class="inlinecode"><span class="id" title="var">O</span></span> 是自然数。(注意：这里是大写字母 <span class="inlinecode"><span class="id" title="var">O</span></span>，不是数字 <span class="inlinecode">0</span>。
  本质上讲，我们现在仅仅是在定义一些符号。这些符号毫无意义。
  它们的意义来自于我们如何使用(通过定义函数)它们。
  如果我们像使用自然数那样使用它们，那么它们“就是”自然数。)
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> 是一个构造函数。

</li>
</ul>
  它告诉我们，如何 <span class="inlinecode"><span class="id" title="var">n</span></span> 是自然数，那么 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 也是自然数。

<div class="paragraph"> </div>

  需要注意的是，与 <span class="inlinecode"><span class="id" title="var">monochrome</span></span> 中的 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> 构造函数不同，
  <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 中的 <span class="inlinecode"><span class="id" title="var">n</span></span> 的类型是我们正在定义的 <span class="inlinecode"><span class="id" title="var">nat</span></span>。
  什么？等等！你要定义 <span class="inlinecode"><span class="id" title="var">nat</span></span>，但是你在定义中又用到了 <span class="inlinecode"><span class="id" title="var">nat</span></span>，这不会造成循环依赖吗?
  让我们再分析一下 <span class="inlinecode"><span class="id" title="var">nat</span></span> 的定义。
  根据第一个构造函数，我们知道 <span class="inlinecode"><span class="id" title="var">O</span></span> 是自然数 (类型是 <span class="inlinecode"><span class="id" title="var">nat</span></span>)。
  根据第二个构造函数，我们知道 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span> 是自然数。
  再根据第二个构造函数，我们知道 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)</span> 是自然数，
  依此类推，我们知道 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>))</span>、<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)))</span>…… 都是自然数。

<div class="paragraph"> </div>

  综上所述，在 <span class="inlinecode"><span class="id" title="var">nat</span></span> 的定义中，
  第一个构造函数给出了一个特定的自然数 <span class="inlinecode"><span class="id" title="var">O</span></span>，
  第二个构造函数根据已知的自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 构造一个新的自然数 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 
  (也称为 <span class="inlinecode"><span class="id" title="var">n</span></span> 的 <i>'后继'(Successor)_)。
  没有循环依赖。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  需要再次强调的是，到目前为止，我们仅仅是定义了一些符号：
  <span class="inlinecode"><span class="id" title="var">O</span></span>、<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span>、<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)</span> 等。
  <span class="inlinecode"><span class="id" title="var">O</span></span>、<span class="inlinecode"><span class="id" title="var">S</span></span> 并无特别之处，你可以将它们换成其它符号。

<div class="paragraph"> </div>

  接下来，我们将在 <span class="inlinecode"><span class="id" title="var">nat</span></span> 上定义函数：
  前驱函数 <span class="inlinecode"><span class="id" title="var">pred</span></span>、加法 <span class="inlinecode"><span class="id" title="var">plus</span></span>、减法 <span class="inlinecode"><span class="id" title="var">minus</span></span>、乘法 <span class="inlinecode"><span class="id" title="var">mult</span></span> 与幂运算 <span class="inlinecode"><span class="id" title="var">exp</span></span>。
  正是这些函数为符号赋予了意义。
  (以后大家在学习数理逻辑的时候，遇到的第一个难点，
  就是区分语法 (符号、公式)与语义 (解释、意义、真假)。)

</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatPlayground</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="var">nat</span></span> 实际上刻画了自然数的一进制表示法。
  在一进制下，100 需要表示为一百个S后接一个O。
  为了避免这种麻烦，Coq 允许我们将一进制的 <span class="inlinecode"><span class="id" title="var">nat</span></span> 解析打印为十进制形式。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)))).<br/>
<span class="id" title="keyword">Check</span> 4.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  你猜构造函数 <span class="inlinecode"><span class="id" title="var">S</span></span> 的类型是什么？

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">S</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatPlayground2</span>.<br/>

<br/>
</div>

<div class="doc">
  先定义前驱函数 <span class="inlinecode"><span class="id" title="var">pred</span></span>。
  需要注意的是，我们规定 <span class="inlinecode"><span class="id" title="var">O</span></span> 的前驱仍是 <span class="inlinecode"><span class="id" title="var">O</span></span>。
  根据 <span class="inlinecode"><span class="id" title="var">nat</span></span> 的定义，我们知道非零自然数的形式一定是 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>，
  它的前驱是 <span class="inlinecode"><span class="id" title="var">n'</span></span>。 

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
  函数 <span class="inlinecode"><span class="id" title="var">plus</span></span> 返回两个自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 与 <span class="inlinecode"><span class="id" title="var">m</span></span> 的和：
<ul class="doclist">
<li> 第一个分支： <span class="inlinecode"><span class="id" title="var">O</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>

</li>
<li> 第二个分支： <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>。

</li>
</ul>
  注意：我们还没有定义 “+”。这里的 “+” 是数学上的加法符号。

</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
  需要注意的是，<span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> 使用了自身 <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> (n' &lt; n)，
  是一个递归函数。
  因此，我们使用了关键字 <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>，而不是之前在定义函数时使用的 <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>。
  <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> 是与递归定义紧密相关的概念。
  我们不深究它背后的理论。
  有兴趣的同学，可以选修冯老师的课程或者研究生关于计算理论的课程。 

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  此时，有同学提问：使用关键词 <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> 与 <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> 定义函数有什么区别?
  答：注意观察 CoqIde 后侧的 "Messages" 窗口。
  除了 "plus is defined"，
  它还显示了一行信息"plus is recursively defined (decreasing on 1st argument)"。
  Coq 要求所有函数都是可计算的 (在这里，你可以理解成函数对于所有输入都会终止)。
  要保证这一点，Coq 要求使用 <span class="inlinecode"><span class="id" title="var">FixPoint</span></span> 定义的递归函数中的某些参数必须是递减的。

<div class="paragraph"> </div>

  Coq 检查到 <span class="inlinecode"><span class="id" title="var">plus</span></span> 的第一个参数是递减的。
  这意味着我们对参数 <span class="inlinecode"><span class="id" title="var">n</span></span> 执行了<i>'结构化递归' (Structural Induction)_。

<div class="paragraph"> </div>

  然而，不存在算法能够判断所有的递归定义的函数是否是可终止的
  (又是神奇的计算理论!)。
  对此，你的新朋友 Coq 也无能为例。
  因此，有些时候我们需要告诉 Coq 一些信息，帮助 Coq 验证某个递归函数确实是可以终止的
  (我们暂时不需要做这些)。

<div class="paragraph"> </div>

 测试 <span class="inlinecode">3</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span>。 
</div>
<div class="code">
<span class="id" title="keyword">Compute</span> (<span class="id" title="var">plus</span> 3 2).<br/>

<br/>
</div>

<div class="doc">
为得出此结论，Coq 所执行的化简步骤如下： 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
  乘法 <span class="inlinecode"><span class="id" title="var">mult</span></span> 的定义方式类似，它用到了刚刚定义的 <span class="inlinecode"><span class="id" title="var">plus</span></span>。
  这里，<span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> 的意思与 <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> 相同。

</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">mult</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">plus</span> <span class="id" title="var">m</span> (<span class="id" title="var">mult</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_mult</span>: (<span class="id" title="var">mult</span> 3 3) = 9.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h4 class="section">练习：1 星, standard (exp)</h4>

  我们将自然数上的幂运算的定义作为练习。
  你需要用到刚刚定义的 <span class="inlinecode"><span class="id" title="var">mult</span></span>。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">exp</span> (<span class="id" title="var">base</span> <span class="id" title="var">power</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
测试一下。
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_exp</span>: (<span class="id" title="var">exp</span> 3 3) = 27.<br/>
<span class="id" title="keyword">Proof</span>.  <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
你可以在两个表达式之间添加逗号来同时匹配它们
  减法 <span class="inlinecode"><span class="id" title="var">minus</span></span> 的定义稍微有些复杂。
  它需要对两个参数 <span class="inlinecode"><span class="id" title="var">n</span></span> 与 <span class="inlinecode"><span class="id" title="var">m</span></span> 分别做模式匹配。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">minus</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span>   , <span class="id" title="var">_</span>    =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">_</span> , <span class="id" title="var">O</span>    =&gt; <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">minus</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab14"></a><h4 class="section">练习：1 星, standard (exp)</h4>

  注意 <span class="inlinecode"><span class="id" title="var">minus</span></span> 是如何使用 <span class="inlinecode"><span class="id" title="keyword">match</span></span> 对两个参数同时做并列模式匹配的。
  当然，你也可以先对 <span class="inlinecode"><span class="id" title="var">n</span></span> 做模式匹配，再嵌套地对 <span class="inlinecode"><span class="id" title="var">m</span></span> 做模式匹配。
  留作练习。

</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">minus'</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_minus'</span>: <span class="id" title="var">minus</span> 10 5 = <span class="id" title="var">minus'</span> 10 5.<br/>
<span class="id" title="keyword">Proof</span>.  <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
<span class="id" title="keyword">End</span> <span class="id" title="var">NatPlayground2</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h4 class="section">练习：1 星, standard (factorial)</h4>

    请定义阶乘函数 <span class="inlinecode"><span class="id" title="var">factorial</span></span>：
       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (if n &gt; 0)

</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">factorial</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_factorial1</span>:          (<span class="id" title="var">factorial</span> 3) = 6.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_factorial2</span>:          (<span class="id" title="var">factorial</span> 5) = (<span class="id" title="var">mult</span> 10 12).<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  我们可以引入通常的加法、减法、乘法<i>'记号（Notation）'</i>。
  <span class="inlinecode"><span class="id" title="keyword">level</span></span> 规定了优先级，<span class="inlinecode"><span class="id" title="tactic">left</span></span> <span class="inlinecode"><span class="id" title="keyword">associativity</span></span> 表示“左结合”。
  目前，你不需要了解这些细节。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x + y" := (<span class="id" title="var">plus</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x - y" := (<span class="id" title="var">minus</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x * y" := (<span class="id" title="var">mult</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> ((0 + 1) + 1).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  我们再来练习定义几个自然数上的函数。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="var">eqb</span></span> 判断两个自然数是否相等 (命名中的后缀 ”b“ 表示它返回的是 bool 值)。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">eqb</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">eqb</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h4 class="section">练习：1 星, standard (eqb1)</h4>

  参考 <span class="inlinecode"><span class="id" title="var">minus</span></span>的定义，使用并列模式匹配改写 <span class="inlinecode"><span class="id" title="var">eqb</span></span>，
  并设计测试用例。

</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">eqb1</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="var">evenb</span></span> 判断给定的自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 是否为偶数。
  尽管我们知道 <span class="inlinecode"><span class="id" title="var">O</span></span> 为偶数，但是我们无法直接判断 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 是否为偶数，
  因为 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 是否为偶数，取决于 <span class="inlinecode"><span class="id" title="var">pred</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 是否为偶数。
  换句话说，我们需要 <i>'递归'(Recursively)_ 定义该函数。
  并且，根据上面的分析，我们需要两个 <i>'基础情况'(Basic Cases)_：
  <span class="inlinecode"><span class="id" title="var">O</span></span> 是偶数，<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span> 不是偶数。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">evenb</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span>        =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">O</span>      =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) =&gt; <span class="id" title="var">evenb</span> <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_evenb1</span>:   <span class="id" title="var">evenb</span> 2019 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们可以基于 <span class="inlinecode"><span class="id" title="var">evenb</span></span> 定义 <span class="inlinecode"><span class="id" title="var">oddb</span></span>。
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">oddb</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span>   :=   <span class="id" title="var">negb</span> (<span class="id" title="var">evenb</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_oddb1</span>:    <span class="id" title="var">oddb</span> 2019 = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_oddb2</span>:    <span class="id" title="var">oddb</span> 9102 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="var">leb</span></span> 函数检查第一个参数 <span class="inlinecode"><span class="id" title="var">n</span></span> 是否小于等于第二个参数 <span class="inlinecode"><span class="id" title="var">m</span></span>。
  注意这也是一个递归函数。 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">leb</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">leb</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_leb1</span>:             (<span class="id" title="var">leb</span> 2 2) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_leb2</span>:             (<span class="id" title="var">leb</span> 2 4) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_leb3</span>:             (<span class="id" title="var">leb</span> 4 2) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  为 <span class="inlinecode"><span class="id" title="var">eqb</span></span> 与 <span class="inlinecode"><span class="id" title="var">leb</span></span> 引入符号记法。 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x =? y" := (<span class="id" title="var">eqb</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70) : <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;=? y" := (<span class="id" title="var">leb</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70) : <span class="id" title="var">nat_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_leb3'</span>:  (4 &lt;=? 2) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h4 class="section">练习：1 星, standard (ltb)</h4>

    <span class="inlinecode"><span class="id" title="var">ltb</span></span> 检查第一个参数 <span class="inlinecode"><span class="id" title="var">n</span></span> 是否小于第二个参数 <span class="inlinecode"><span class="id" title="var">m</span></span>。
    请完成它的定义。 

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ltb</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;? y" := (<span class="id" title="var">ltb</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70) : <span class="id" title="var">nat_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_ltb1</span>:             (<span class="id" title="var">ltb</span> 2 2) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_ltb2</span>:             (<span class="id" title="var">ltb</span> 2 4) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_ltb3</span>:             (<span class="id" title="var">ltb</span> 4 2) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab18"></a><h1 class="section">基于化简的证明</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  我们已经定义好了自然数类型。
  下面，我们要正式进入另一个主题：证明。
  在 Coq 中，我们不仅可以编程，我们还可以做证明。
  学习如何做证明是问题求解课程的核心内容之一。

<div class="paragraph"> </div>

  有同学问：为什么要在 Coq 中学习证明？
  在数学课上学习证明不就够了吗？

<div class="paragraph"> </div>

  如果你做过足够长、足够复杂的证明，你就会体会到，证明是多么容易出错。
  证明出了错，要想找到错误，又是何等困难。
  如果在你写证明的时候，能有一位严苛的权威人士始终盯着你的证明，
  帮助你检查每一个证明步骤，直到 <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> 的那一美妙时刻，
  你是不是会对写出来的证明更有信心？

<div class="paragraph"> </div>

  Coq 就是这么一位严苛的权威人士。
  你可以欺骗你自己，但是你欺骗不了 Coq。
  从今往后，你将与 Coq 相爱相杀。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  本节从三个最基本的 <i>'证明策略' (Proof Tactics)_ 开始：
  <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 与 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>。
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">intros</span></span> 用于引入变量。

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 用于化简。

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 用于判断等号两边是否相同。

</li>
</ul>

<div class="paragraph"> </div>

  证明策略是在证明过程中，你下达给 Coq 的指令。
  Coq 将执行这些指令。
  如果执行不下去，就意味着你的证明行不通，需要改换思路。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  定理 <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span> 说明：<span class="inlinecode">0</span> (即，<span class="inlinecode"><span class="id" title="var">O</span></span>) 是自然数加法的左单位元。
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> 表明这是一个需要证明的定理。
    <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> 这个关键字本身并不重要，可以是 <span class="inlinecode"><span class="id" title="keyword">Example</span></span>、<span class="inlinecode"><span class="id" title="keyword">Lemma</span></span>、<span class="inlinecode"><span class="id" title="keyword">Fact</span></span>等。

</li>
<li> <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span> 是定理的名字。以后，你可以通过这个名字引用该定理。

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> 是一阶谓词逻辑里的全称量词符号，读作“对于所有”。

</li>
</ul>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_O_n</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 0 + <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>. &nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. &nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. &nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>. 
<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  我们逐步解释该证明：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">Proof</span>.</span>：证明开始。

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">n</span>.</span>：我们要证明的定理是一个全称命题：“对于所有的自然数 <span class="inlinecode"><span class="id" title="var">n</span></span>，……”。
    在证明这类命题时，通常的做法是：“假设 <span class="inlinecode"><span class="id" title="var">n</span></span> 是任意自然数，……”。
    在后续的证明“……”中，我们就可以使用 <span class="inlinecode"><span class="id" title="var">n</span></span> 了。
    也就是说，我们将 <span class="inlinecode"><span class="id" title="var">n</span></span> 从 <i>'证明目标' (Goal)_ 
    移到了 <i>'证明上下文' (Context)_中。
    <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">n</span>.</span> 的作用就是“引入任意自然数 <span class="inlinecode"><span class="id" title="var">n</span></span>”。

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">simpl</span>.</span>：根据加法 <span class="inlinecode"><span class="id" title="var">plus</span></span> 的定义 (模式匹配的第一种情况)，
    等号左边 <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> 可以化简为 <span class="inlinecode"><span class="id" title="var">n</span></span>。

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span>.</span>： 等号左右两边都是 <span class="inlinecode"><span class="id" title="var">n</span></span>。

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">Qed</span>.</span>：证毕。

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  实际上，<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 在判断等号两边是否相同时，
  会先尝试对等号两边进行化简。
  因此，有些时候，<span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 可以省略。

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_O_n'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 0 + <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  类似地，我们可以证明定理 <span class="inlinecode"><span class="id" title="var">mult_0_l</span></span>：<span class="inlinecode">0</span> 是自然数乘法的左零元。
  (定理名中的后缀 <span class="inlinecode"><span class="id" title="var">_l</span></span> 表示 left。)

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_l</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>, 0 * <span class="id" title="var">n</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  请你解释定理 <span class="inlinecode"><span class="id" title="var">plus_1_l</span></span> 及其证明过程。
  (你要确保理解每一个证明步骤。
  这次没有 Coq 盯着你。
  你可以欺骗我，但你不能欺骗你自己。)

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_1_l</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>, 1 + <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab19"></a><h1 class="section">基于改写 (Rewriting) 的证明</h1>

<div class="paragraph"> </div>

  <i>'改写 (Rewriting)'</i> 指的是用等号的一端替换等号的另一端。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  定理 <span class="inlinecode"><span class="id" title="var">plus_id_example</span></span> 读作：
  对于所有的自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 与 <span class="inlinecode"><span class="id" title="var">m</span></span>，
  如果 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>，那么 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> = <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>。

<div class="paragraph"> </div>

  首先，这个定理是一个条件句：如果 A，那么 B。
  要证明这类结论，我们通常是将 A 作为已知条件，然后证明 B 成立。
  用 Coq 的语言来讲，就是把 A 从待证目标 (Goal) 移到上下文 (Context) 中。
  我们又需要用到 <span class="inlinecode"><span class="id" title="tactic">intros</span></span> 策略。

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_id_example</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + <span class="id" title="var">n</span> = <span class="id" title="var">m</span> + <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">H</span></span> 策略中的箭头 <span class="inlinecode">-&gt;</span> 表示从左往右应用 Rewriting，
  即在目标中，将等式 <span class="inlinecode"><span class="id" title="var">H</span></span> 的左边 (即，<span class="inlinecode"><span class="id" title="var">n</span></span>) 替换成等式 <span class="inlinecode"><span class="id" title="var">H</span></span> 的右边 (即，<span class="inlinecode"><span class="id" title="var">m</span></span>)。
  如果要改变 Rewriting 的方向，则使用 <span class="inlinecode">&lt;-</span> 箭头。

<div class="paragraph"> </div>

  另外，<span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> 默认为 <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">H</span></span>。

<div class="paragraph"> </div>

<a name="lab20"></a><h4 class="section">练习：1 星, standard (plus_id_exercise)</h4>

  删除 "<span class="inlinecode"><span class="id" title="var">Admitted</span>.</span>"，完成定理 <span class="inlinecode"><span class="id" title="var">plus_id_exercise</span></span> 的证明。
  (<span class="inlinecode"><span class="id" title="var">Admitted</span></span> 表示暂时跳过该定理的证明，而将其将其作为已知条件。) 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_id_exercise</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> -&gt; <span class="id" title="var">m</span> = <span class="id" title="var">o</span> -&gt; <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">o</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  如前所述，<i>'改写 (Rewriting)'</i> 指的是用等号的一端替换等号的另一端。
  这里的等式可以是之前证明过的定理。
  比如定理 <span class="inlinecode"><span class="id" title="var">mult_O_plus</span></span> 的证明用到了之前证明过的 <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span>。

<div class="paragraph"> </div>

  (是不是已经忘记了 <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span> 说了些什么？没关系，这很正常。
  这些都是为了教学构造出来的没有多大实际意义的例子。
  忘了的话，就试试 <span class="inlinecode"><span class="id" title="keyword">Check</span></span> <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span>。)

</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="var">plus_O_n</span>.<br/>
</div>

<div class="doc">
=&gt; forall n : nat, 0 + n = n. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_O_plus</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(0 + <span class="id" title="var">n</span>) * <span class="id" title="var">m</span> = <span class="id" title="var">n</span> * <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">plus_O_n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  需要注意的是，<span class="inlinecode"><span class="id" title="var">plus_O_n</span></span> 是关于 <span class="inlinecode"><span class="id" title="var">n</span></span> 的全称语句。
  在 Rewriting 时，Coq 会通过匹配当前的证明目标来尝试
  <i>'实例化'（Instantiate）_ <span class="inlinecode"><span class="id" title="var">n</span></span>。 
<div class="paragraph"> </div>

<a name="lab21"></a><h4 class="section">练习：2 星, standard (mult_S_1)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_S_1</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">m</span> = <span class="id" title="var">S</span> <span class="id" title="var">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" title="var">m</span> * (1 + <span class="id" title="var">n</span>) = <span class="id" title="var">m</span> * <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab22"></a><h1 class="section">分情形分析 (Case Analysis) 证明法</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  不用想也知道，使用 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>、<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>、<span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>
  只能证明一些 “Too Simple，Sometimes Naive” 的定理。
  我们需要学习更高级的证明策略。

<div class="paragraph"> </div>

  先尝试使用已学过的证明策略证明下述定理。
  你会发现 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 不起作用。
  这是因为，<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> 中的 <span class="inlinecode"><span class="id" title="var">n</span></span> 是任意自然数。
  在 <span class="inlinecode"><span class="id" title="var">plus</span></span> 的定义中，Coq 无法确定使用哪一条模式匹配进行化简。

</div>
<div class="code">
<span class="id" title="keyword">Print</span> <span class="id" title="var">Nat.add</span>. </div>

<div class="doc">
与 <span class="inlinecode"><span class="id" title="var">plus</span></span> 相同 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_1_neq_0_firsttry</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> + 1) =? 0 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>. 
<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  解决的方法也很自然：对 <span class="inlinecode"><span class="id" title="var">n</span></span> 分情况分析。
<ul class="doclist">
<li> 如果 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">O</span></span>：使用 <span class="inlinecode"><span class="id" title="var">plus</span></span> 的第一条模式匹配进行化简。

</li>
<li> 如果 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>：使用 <span class="inlinecode"><span class="id" title="var">plus</span></span> 的第二条模式匹配进行化简。

</li>
</ul>

<div class="paragraph"> </div>

  对自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 进行分情况分析，
  用 Coq 的语言来讲，就是 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>。 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_1_neq_0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> + 1) =? 0 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">E</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  由于 <span class="inlinecode"><span class="id" title="var">nat</span></span> 的定义中包含两个构造函数，
  所以，<span class="inlinecode"><span class="id" title="var">n</span></span> 有两种构成方式。
  在使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 分情况分析时，Coq 会产生两个子目标，
  分别对应 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">O</span></span> 与 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 两种情况。

<div class="paragraph"> </div>

  记号 "<span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">n'</span>]</span> <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">E</span></span>" 使用 <span class="inlinecode">|</span> 区分了两种情况，
  并将每种情况下与 <span class="inlinecode"><span class="id" title="var">n</span></span> 有关的等式命名为 <span class="inlinecode"><span class="id" title="var">E</span></span>。
  在第一种情况中，<span class="inlinecode"><span class="id" title="var">E</span></span> 为 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">O</span></span>。
  由于 <span class="inlinecode"><span class="id" title="var">O</span></span> 构造函数没有参数，所以 <span class="inlinecode"></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 中 <span class="inlinecode">|</span> 的左边为空。
  在第二种情况中，<span class="inlinecode"><span class="id" title="var">E</span></span> 为 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>。
  其中，<span class="inlinecode"><span class="id" title="var">n'</span></span> 是 <span class="inlinecode"></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 中的 <span class="inlinecode"><span class="id" title="var">n'</span></span>，对应于构造函数 <span class="inlinecode"><span class="id" title="var">S</span></span> 的参数。 

<div class="paragraph"> </div>

  另外，在上面的证明中，我们使用并列的两个 <span class="inlinecode">-</span> 标记了两种情况，
  使得证明的结构更为清晰。
  从语法上讲，<span class="inlinecode">-</span> 并不是必须的。
  但是，强烈建议大家在使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 策略时，同时使用 <span class="inlinecode">-</span>。
  如果需要嵌套地分情况分析，可以使用 <span class="inlinecode">+</span>、<span class="inlinecode">*</span>、<span class="inlinecode">{}</span> 等 (我们马上就会碰到)。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 策略可用于任何归纳 (Inductive) 定义的数据类型。
  定理 <span class="inlinecode"><span class="id" title="var">negb_involutive</span></span> 的证明使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 对布尔值分情况分析。 

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_involutive</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">E</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  注意：我们省略了 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 的 <span class="inlinecode"><span class="id" title="keyword">as</span></span> 子句。
  我们可以写 <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[|]</span> 或者 <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[]</span>。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 可以嵌套使用。 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_commutative</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">andb</span> <span class="id" title="var">c</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Eb</span>. &nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>. &nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>. &nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们也可以用匹配的花括号区别每个子目标对应的证明。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_commutative'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">andb</span> <span class="id" title="var">c</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Eb</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. } } <br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. } }<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
此外，花括号有限定范围的作用，它允许我们在一个证明中的多个层级下使用同一种标号： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb3_exchange</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>, <span class="id" title="var">andb</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>) <span class="id" title="var">d</span> = <span class="id" title="var">andb</span> (<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">d</span>) <span class="id" title="var">c</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Eb</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  在很多证明中，我们在引入变量之后会立即对该变量进行情况分析。
  例如： intros x y. destruct y as <span class="inlinecode">|<span class="id" title="var">y</span></span> eqn:E.
  Coq 提供了一种简便的记法： intros x <span class="inlinecode">|<span class="id" title="var">y</span></span>.
  也就是说，我们可以在引入变量的同时对它进行情况分析。
  (在 Coq 的术语中，这被称为 <i>'intro pattern'</i>。)

<div class="paragraph"> </div>

  需要注意的是，上述简便记法丢失了 <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">E</span></span> 信息。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">eqb</span>.<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_1_neq_0'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> + 1) =? 0 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [|<span class="id" title="var">n</span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
如果没有需要命名的参数，我们只需写上 <span class="inlinecode">[]</span> 即可。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_commutative''</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">andb</span> <span class="id" title="var">c</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [] [].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab23"></a><h4 class="section">练习：2 星, standard (andb_true_elim2)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_true_elim2</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">c</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab24"></a><h4 class="section">练习：1 星, standard (zero_nbeq_plus_1)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_nbeq_plus_1</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;0 =? (<span class="id" title="var">n</span> + 1) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab25"></a><h1 class="section">更多练习</h1>
<a name="lab26"></a><h4 class="section">练习：1 星, standard (indentity_fn_applied_twice)</h4>

  证明定理 <span class="inlinecode"><span class="id" title="var">identity_fn_applied_twice</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">identity_fn_applied_twice</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">f</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">bool</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">bool</span>), <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>), <span class="id" title="var">f</span> (<span class="id" title="var">f</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab27"></a><h4 class="section">练习：1 星, standard (negation_fn_applied_twice)</h4>


<div class="paragraph"> </div>

  声明并证明定理 <span class="inlinecode"><span class="id" title="var">negation_fn_applied_twice</span></span>。
  它与 <span class="inlinecode"><span class="id" title="var">identity_fn_applied_twice</span></span>类似，
  但是第二个前提改为 <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span>),</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>。 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="var">From</span> <span class="id" title="var">Coq</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">String</span>. 
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">manual_grade_for_negation_fn_applied_twice</span> : <span class="id" title="var">option</span> (<span class="id" title="var">nat</span>*<span class="id" title="var">string</span>) := <span class="id" title="var">None</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab28"></a><h4 class="section">练习：3 星, standard, optional (andb_eq_orb)</h4>


<div class="paragraph"> </div>

    请证明定理 <span class="inlinecode"><span class="id" title="var">andb_eq_orb</span></span>。

<div class="paragraph"> </div>

    有一点点难度 (是不是很兴奋？)，试试看吧。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_eq_orb</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">orb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" title="var">b</span> = <span class="id" title="var">c</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab29"></a><h4 class="section">练习：3 星, standard (binary)</h4>

  下面这道题目可以检验你是否掌握了本节的主要内容。
  不要怕。正是这些让你感到有些困难的题目在悄悄地锻炼你的能力。

<div class="paragraph"> </div>

  我们考虑自然数的一种 <i>'二进制' (Binary)_ 表示法：
  一个二进制数是由构造子 (即，构造函数) <span class="inlinecode"><span class="id" title="var">A</span></span> (表示 0) 与 <span class="inlinecode"><span class="id" title="var">B</span></span> (表示 1)
  组成的序列，且该序列以构造子 <span class="inlinecode"><span class="id" title="var">Z</span></span> 结束。
  (能理解这句话吗? 我实在不知道该怎么表达了。
  它的英文是：“treating a binary number as a sequence of constructors <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span> (representing 0s and 1s), terminated by a <span class="inlinecode"><span class="id" title="var">Z</span></span>.”。
  Help me if you can!)

<div class="paragraph"> </div>

  在我们定义的 <i>'一进制' (unary)_ <span class="inlinecode"><span class="id" title="var">nat</span></span> 中，
  一个一进制数是由构造子 <span class="inlinecode"><span class="id" title="var">S</span></span> 组成的序列，且该序列以构造子 <span class="inlinecode"><span class="id" title="var">O</span></span> 结束。

<div class="paragraph"> </div>

  看下面的例子 (注意，低位 (low-order bit) 在左，高位 (high-order bit) 在右)：

<div class="paragraph"> </div>

        decimal            binary                           unary
           0                   Z                              O
           1                 B Z                            S O
           2              A (B Z)                        S (S O)
           3              B (B Z)                     S (S (S O))
           4           A (A (B Z))                 S (S (S (S O)))
           5           B (A (B Z))              S (S (S (S (S O))))
           6           A (B (B Z))           S (S (S (S (S (S O)))))
           7           B (B (B Z))        S (S (S (S (S (S (S O))))))
           8        A (A (A (B Z)))    S (S (S (S (S (S (S (S O)))))))

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bin</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Z</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">A</span> (<span class="id" title="var">n</span> : <span class="id" title="var">bin</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">B</span> (<span class="id" title="var">n</span> : <span class="id" title="var">bin</span>).<br/>

<br/>
</div>

<div class="doc">
(a) 请给出递增函数 <span class="inlinecode"><span class="id" title="var">incr</span></span> 与转换函数 <span class="inlinecode"><span class="id" title="var">bin_to_nat</span></span> 的定义。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">incr</span> (<span class="id" title="var">m</span>:<span class="id" title="var">bin</span>) : <span class="id" title="var">bin</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">bin_to_nat</span> (<span class="id" title="var">m</span>:<span class="id" title="var">bin</span>) : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  (b) 为 <span class="inlinecode"><span class="id" title="var">incr</span></span> 与 <span class="inlinecode"><span class="id" title="var">bin_to_nat</span></span> 编写单元测试 (使用 <span class="inlinecode"><span class="id" title="keyword">Example</span></span>) 并给出证明。
  你至少需要编写单元测试用例测试 <span class="inlinecode"><span class="id" title="var">incr</span></span> 与 <span class="inlinecode"><span class="id" title="var">bin_to_nat</span></span> 的可交换性。

</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">manual_grade_for_binary</span> : <span class="id" title="var">option</span> (<span class="id" title="var">nat</span>*<span class="id" title="var">string</span>) := <span class="id" title="var">None</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>