<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Induction</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Induction</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Induction: 归纳证明</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  我们先用下面一行命令，将上一章中所有的定义都导入进来。
  在此之前，你需要先编译 <span class="inlinecode"><span class="id" title="var">Basics.v</span></span> 得到 <span class="inlinecode"><span class="id" title="var">Basics.vo</span></span>。
  编译方法：在 CoqIDE 中打开 <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>，
  执行 "Compile" 菜单中的 "Compile Buffer" 命令。

<div class="paragraph"> </div>

  (TODO (to ant-hengxin): How to "Make"?)

</div>
<div class="code">

<br/>
<span class="id" title="var">From</span> <span class="id" title="var">LF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">Basics</span>.<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">归纳法证明</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在上一章中，我们使用 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 证明了定理 <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span> (即，<span class="inlinecode">0</span> 是 <span class="inlinecode">+</span> 的左单位元)。
  下面，我们尝试使用 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 证明定理 <span class="inlinecode"><span class="id" title="var">plus_n_O</span></span>，
  它表明 <span class="inlinecode">0</span> 也是 <span class="inlinecode">+</span> 的右单位元。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O_firsttry</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">n</span> + 0.<br/>

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  我们发现 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 不起作用。
  这是因为，<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> 中的 <span class="inlinecode"><span class="id" title="var">n</span></span> 是任意自然数，无法使用 <span class="inlinecode"><span class="id" title="var">plus</span></span> 定义中的匹配进行化简。

<div class="paragraph"> </div>

  那么，用上一章学过的 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 对 <span class="inlinecode"><span class="id" title="var">n</span></span> 分情况讨论，是否可行?

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O_secondtry</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">n</span> + 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">E</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. &nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> 的情形可以通过 <span class="inlinecode"><span class="id" title="var">plus</span></span> 的第一条模式匹配完成化简。

</li>
<li> 对于 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>，经过一步 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 后，
    我们还需要证明 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0)</span>。
    这意味着我们需要证明 <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span>。
    而这与我们一开始要证明的目标 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span>在形式上是完全相同的，
    不同的是，此处 <span class="inlinecode"><span class="id" title="var">n'</span></span> 比 <span class="inlinecode"><span class="id" title="var">n</span></span> 小 1。
    这就提示我们需要使用 <i>'数学归纳法' (Mathematical Induction)_。

<div class="paragraph"> </div>

    在我们问题求解课程四个学期的内容中，数学归纳法经常出现，非常重要。
    甚至在大家以后的科研工作中，数学归纳法都有可能是最常用的理解问题
    与证明定理的方法。
    (请默念三遍：数学归纳法，数学归纳法，数学归纳法)
    另外，数学归纳法不仅仅是应用在自然数上的，
    而是可以应用于所有归纳定义的结构/对象。
    关于这一点，我们会在后续章节与后续课程深入学习。

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  我们从<i>'自然数上的归纳原理'</i>开始：
  (问卷：高中时是否学习过数学归纳法?)
  假设 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span> 为关于自然数的命题。
  我们想要证明 <span class="inlinecode"><span class="id" title="var">P</span></span> 对于所有自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 都成立时。
  数学归纳法告诉我们，只需要：
<ul class="doclist">
<li> 证明 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">O</span>)</span> 成立；

</li>
<li> 证明对于任何 <span class="inlinecode"><span class="id" title="var">n'</span></span>，若 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n'</span>)</span> 成立，那么 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> 也成立。

</li>
</ul>

<div class="paragraph"> </div>

  (此处又有学生提问：怎么证明数学归纳法的正确性呢?)

<div class="paragraph"> </div>

  (答：难道你不觉得这是显然成立的吗?)

<div class="paragraph"> </div>

  (另一位学生反驳：你不是说要“怀疑一切、证明一切”吗? (TODO: 嗯，回头补上))

<div class="paragraph"> </div>

  (故作镇定：很好。那怎么证明呢? 这个问题我们还是先留给大家思考吧。
  后续课程中我们还有机会回到这个问题上来。)

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  Coq 通过应用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 策略把待定目标 <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span>
  分为两个子目标:
<ul class="doclist">
<li> 基础情况: <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>。此时，我们需要证明 <span class="inlinecode"><span class="id" title="var">P</span>(0)</span>，即 <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> 成立。

</li>
<li> 归纳步骤: <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>。
    此时，我们有归纳假设 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n'</span>)</span> 成立，即 <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> 成立。
    我们需要在归纳假设 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n'</span>)</span> 成立的基础上，证明 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span> 成立，
    即证明 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> 成立，
    也就是 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> 成立。
    基本的证明方法就是将对 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> 的证明
    化归 (Reduce) 到可以直接应用归纳假设 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n'</span>)</span> 的情况。

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = <span class="id" title="var">n</span> + 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">IHn'</span>]. &nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHn'</span>. &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  根据上面的分析，对自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 应用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 策略，
  会产生两个子目标。
  就像使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 做分情形分析一样，在 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 中，
  我们使用 <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[</span> <span class="inlinecode">|</span> <span class="inlinecode">]</span> 表达基本情况与归纳步骤。
<ul class="doclist">
<li> 在基本情况中，<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>。不需要额外参数。

</li>
<li> 在归纳步骤，<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>。我们需要引入额外参数代表 <span class="inlinecode"><span class="id" title="var">n'</span></span>。

</li>
</ul>
  需要特别注意的是，我们还使用 IHn' 记录了归纳假设。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">minus_diag</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">minus</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">IHn'</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  注意: 在上面的证明中，我们没有使用 <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>。
  当 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 会自动将 <span class="inlinecode"><span class="id" title="var">n</span></span> 移到上下文中。
<a name="lab3"></a><h4 class="section">练习：2 星, standard, recommended (basic_induction)</h4>

    使用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 完成以下证明。你可能需要使用之前证明的定理。
    记住 <span class="inlinecode"><span class="id" title="keyword">Print</span></span>、<span class="inlinecode"><span class="id" title="keyword">Search</span></span>。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_r</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> * 0 = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_Sm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">S</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) = <span class="id" title="var">n</span> + (<span class="id" title="var">S</span> <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
  我们终于可以证明加法交换律与结合律了。

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_comm</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_assoc</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">p</span>) = (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab4"></a><h4 class="section">练习：2 星, standard (double_plus)</h4>

  完成函数 <span class="inlinecode"><span class="id" title="var">double</span></span> 的定义，它接受参数 <span class="inlinecode"><span class="id" title="var">n</span></span>，返回 <span class="inlinecode">2<span class="id" title="var">n</span></span>: 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">double</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
使用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 证明 <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">double_plus</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">double</span> <span class="id" title="var">n</span> = <span class="id" title="var">n</span> + <span class="id" title="var">n</span> .<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab5"></a><h4 class="section">练习：2 星, standard, optional (evenb_S)</h4>

  证明下述关于 <span class="inlinecode"><span class="id" title="var">evenb</span></span> 的定理。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evenb_S</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">evenb</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) = <span class="id" title="var">negb</span> (<span class="id" title="var">evenb</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab6"></a><h1 class="section">证明里的证明</h1>

<div class="paragraph"> </div>

 和在非形式化的数学中一样，在 Coq 中，大的证明通常会被分为一系列定理，
    后面的定理引用之前的定理。但有时一个证明会需要一些繁杂琐碎的事实，
    而这些事实缺乏普遍性，以至于我们甚至都不应该给它们单独取顶级的名字。
    此时，如果能仅在需要时简单地陈述并立即证明所需的“子定理”就会很方便。
    我们可以用 <span class="inlinecode"><span class="id" title="tactic">assert</span></span> 策略来做到。例如，我们之前对 <span class="inlinecode"><span class="id" title="var">mult_0_plus</span></span>
    定理的证明引用了前一个名为 <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span> 的定理，而我们只需内联使用 <span class="inlinecode"><span class="id" title="tactic">assert</span></span>
    就能陈述并证明 <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span>： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_plus'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(0 + <span class="id" title="var">n</span>) * <span class="id" title="var">m</span> = <span class="id" title="var">n</span> * <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span>: 0 + <span class="id" title="var">n</span> = <span class="id" title="var">n</span>). { <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">assert</span></span> 策略引入两个子目标。第一个为断言本身，通过给它加前缀 <span class="inlinecode"><span class="id" title="var">H</span>:</span>
    我们将该断言命名为 <span class="inlinecode"><span class="id" title="var">H</span></span>。（当然也可以用 <span class="inlinecode"><span class="id" title="keyword">as</span></span> 来命名该断言，与之前的
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 和 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 一样。例如 <span class="inlinecode"><span class="id" title="tactic">assert</span></span> <span class="inlinecode">(0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>。）
    注意我们用花括号 <span class="inlinecode">{</span> <span class="inlinecode">...</span> <span class="inlinecode">}</span> 将该断言的证明括了起来。这样不仅方便阅读，
    同时也能在交互使用 Coq 时更容易看出该子目标何时得证。第二个目标
    与之前执行 <span class="inlinecode"><span class="id" title="tactic">assert</span></span> 时一样，只是这次在上下文中，我们有了名为 <span class="inlinecode"><span class="id" title="var">H</span></span> 的前提
    <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>。也就是说，<span class="inlinecode"><span class="id" title="tactic">assert</span></span> 生成的第一个子目标是我们必须证明的已断言的事实，
    而在第二个子目标中，我们可以使用已断言的事实在一开始尝试证明的事情上取得进展。 
<div class="paragraph"> </div>

 另一个 <span class="inlinecode"><span class="id" title="tactic">assert</span></span> 的例子... 
<div class="paragraph"> </div>

 举例来说，假如我们要证明 <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">q</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">q</span>)</span>。
    <span class="inlinecode">=</span> 两边唯一不同的就是内层第一个子式中 <span class="inlinecode">+</span> 的参数 <span class="inlinecode"><span class="id" title="var">m</span></span> 和 <span class="inlinecode"><span class="id" title="var">n</span></span> 交换了位置，
    我们似乎可以用加法交换律（<span class="inlinecode"><span class="id" title="var">plus_comm</span></span>）来改写它。然而，
    <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> 策略并不知道应该作用在 <i>'哪里'</i>。本命题中 <span class="inlinecode">+</span> 用了三次 ，
    结果 <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> 只对 <i>'最外层'</i> 起了作用... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_rearrange_firsttry</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + (<span class="id" title="var">p</span> + <span class="id" title="var">q</span>) = (<span class="id" title="var">m</span> + <span class="id" title="var">n</span>) + (<span class="id" title="var">p</span> + <span class="id" title="var">q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">plus_comm</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
为了在需要的地方使用 <span class="inlinecode"><span class="id" title="var">plus_comm</span></span>，我们可以（为此这里讨论的 <span class="inlinecode"><span class="id" title="var">m</span></span> 和 <span class="inlinecode"><span class="id" title="var">n</span></span>）
    引入一个局部引理来陈述 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>，之后用 <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> 证明它，
    并用它来进行期望的改写。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_rearrange</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + (<span class="id" title="var">p</span> + <span class="id" title="var">q</span>) = (<span class="id" title="var">m</span> + <span class="id" title="var">n</span>) + (<span class="id" title="var">p</span> + <span class="id" title="var">q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span>: <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">plus_comm</span>. <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab7"></a><h1 class="section">形式化证明 vs. 非形式化证明</h1>

<div class="paragraph"> </div>

 数学声明的成功证明由什么构成？这个问题已经困扰了哲学家数千年，
    不过这儿有个还算凑合的定义：数学命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 的证明是一段书面（或口头）的文本，
    它对 <span class="inlinecode"><span class="id" title="var">P</span></span> 的真实性进行无可辩驳的论证，逐步说服读者或听者使其确信 <span class="inlinecode"><span class="id" title="var">P</span></span> 为真。
    也就是说，证明是一种交流行为。

<div class="paragraph"> </div>

    交流活动会涉及不同类型的读者。一方面，“读者”可以是像 Coq 这样的程序，
    此时灌输的“确信”是 <span class="inlinecode"><span class="id" title="var">P</span></span> 能够从一个确定的，由形式化逻辑规则组成的集合中
    机械地推导出来，而证明则是指导程序检验这一事实的方法。这种方法就是
    <i>'形式化'</i> 证明。

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Definition manual_grade_for_plus_comm_informal : option (nat*string) := None.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_swap : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem mult_comm : forall m n : nat,
  m * n = n * m.
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Check leb.

<div class="paragraph"> </div>

Theorem leb_refl : forall n:nat,
  true = (n &lt;=? n).
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem zero_nbeq_S : forall n:nat,
  0 =? (S n) = false.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem andb_false_r : forall b : bool,
  andb b false = false.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem plus_ble_compat_l : forall n m p : nat,
  n &lt;=? m = true -&gt; (p + n) &lt;=? (p + m) = true.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem S_nbeq_0 : forall n:nat,
  (S n) =? 0 = false.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem mult_1_l : forall n:nat, 1 * n = n.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem all3_spec : forall b c : bool,
    orb
      (andb b c)
      (orb (negb b)
               (negb c))
  = true.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p.
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem eqb_refl : forall n : nat,
  true = (n =? n).
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_swap' : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Definition manual_grade_for_binary_commute : option (nat*string) := None.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Fixpoint nat_to_bin (n:nat) : bin
  . Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.
Proof.
   Admitted.

<div class="paragraph"> </div>

Definition manual_grade_for_binary_inverse_a : option (nat*string) := None.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Definition manual_grade_for_binary_inverse_b : option (nat*string) := None.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Definition manual_grade_for_binary_inverse_c : option (nat*string) := None.

<div class="paragraph"> </div>


</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>