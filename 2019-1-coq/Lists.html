<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Lists</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Lists</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Lists: 使用结构化的数据</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  本节介绍<i>'列表'(List)_数据类型。
  下一节介绍<i>'函数式程序设计' (Functional Programming; FP)_范型。

<div class="paragraph"> </div>

  为什么要先介绍列表呢?
  列表是函数式程序设计中的基础数据类型。
  最早的(?)的函数式程序设计语言 Lisp 的含义即是 "LISt Processor"。

</div>
<div class="code">

<br/>
<span class="id" title="var">From</span> <span class="id" title="var">LF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="keyword">Induction</span>.<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatList</span>.<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">自然数序对</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在定义列表数据类型之前，我们先热热身，
  定义简单的自然数 _序对 (Ordered Pair)_。
  它只有一种构造方式，即将构造函数 <span class="inlinecode"><span class="id" title="var">pair</span></span> 作用到两个自然数 <span class="inlinecode"><span class="id" title="var">n1</span></span> <span class="inlinecode"><span class="id" title="var">n2</span></span> 上。 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natprod</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">pair</span> (<span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>).<br/>

<br/>
</div>

<div class="doc">
  注意: 我们将该类型命名为 natprod，
  其中 prod 表示 <i>'乘积' (Product)_ 类型。

</div>
<div class="code">
<span class="id" title="keyword">Check</span> (<span class="id" title="var">pair</span> 3 5).<br/>

<br/>
</div>

<div class="doc">
  函数 <span class="inlinecode"><span class="id" title="var">fst</span></span> 与 <span class="inlinecode"><span class="id" title="var">snd</span></span> 分别用于提取有序对的第一个和第二个分量。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fst</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snd</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Compute</span> (<span class="id" title="var">fst</span> (<span class="id" title="var">pair</span> 3 5)).<br/>

<br/>
</div>

<div class="doc">
  在数学上，我们使用 <span class="inlinecode">(<span class="id" title="var">x</span>,<span class="id" title="var">y</span>)</span> 表示有序对 <span class="inlinecode"><span class="id" title="var">pair</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;( x , y )" := (<span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>

<br/>
<span class="id" title="keyword">Compute</span> (<span class="id" title="var">fst</span> (3,5)).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fst'</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ <span class="id" title="var">x</span> <br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snd'</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">swap_pair</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">natprod</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ (<span class="id" title="var">y</span>,<span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
  由于 <span class="inlinecode"><span class="id" title="var">natprod</span></span> 也是归纳类型 (使用 Inductive 定义)，
  因此我们可以使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 对 <span class="inlinecode"><span class="id" title="var">natprod</span></span> 类型的值分情形讨论。
  又由于 <span class="inlinecode"><span class="id" title="var">natprod</span></span> 只有一个构造函数 <span class="inlinecode"><span class="id" title="var">pair</span></span>，
  因此使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 时只会产生一个子目标。
  另外，<span class="inlinecode"><span class="id" title="var">pair</span></span> 有两个参数，
  所以可以使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 的 <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">s</span>]</span> 子句
  匹配并记录有序对的两个分量。 

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">surjective_pairing</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">p</span> = (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>, <span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">m</span>]. &nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab3"></a><h4 class="section">练习：1 星, standard (snd_fst_is_swap)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">snd_fst_is_swap</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">snd</span> <span class="id" title="var">p</span>, <span class="id" title="var">fst</span> <span class="id" title="var">p</span>) = <span class="id" title="var">swap_pair</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab4"></a><h4 class="section">练习：1 星, standard, optional (fst_swap_is_snd)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">fst_swap_is_snd</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">fst</span> (<span class="id" title="var">swap_pair</span> <span class="id" title="var">p</span>) = <span class="id" title="var">snd</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab5"></a><h1 class="section">自然数列表</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  由任意多个自然数构成的<i>'自然数列表'</i>类型
  需要使用递归来定义。
  一个自然数列表有且仅有两种构造方式:
<ul class="doclist">
<li> 空列表是自然数列表，记为 <span class="inlinecode"><span class="id" title="var">nil</span></span>;

</li>
<li> 如果 <span class="inlinecode"><span class="id" title="var">l</span></span> 是自然数列表，<span class="inlinecode"><span class="id" title="var">n</span></span> 是自然数，
    把 <span class="inlinecode"><span class="id" title="var">n</span></span> 添加到 <span class="inlinecode"><span class="id" title="var">l</span></span> 的表头，可以构成新的列表，记为 <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>。

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natlist</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">cons</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>).<br/>

<br/>
</div>

<div class="doc">
例如，<span class="inlinecode"><span class="id" title="var">mylist</span></span> 是一个三元素列表。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist</span> := <span class="id" title="var">cons</span> 1 (<span class="id" title="var">cons</span> 2 (<span class="id" title="var">cons</span> 3 <span class="id" title="var">nil</span>)).<br/>

<br/>
</div>

<div class="doc">
  对于较长的列表，要写很多的 <span class="inlinecode"><span class="id" title="var">cons</span></span> 与括号，繁琐易错。
  以下三个 <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> 声明允许我们:
<ul class="doclist">
<li> 使用 <span class="inlinecode">::</span> 中缀操作符代替 <span class="inlinecode"><span class="id" title="var">cons</span></span>。注意: <span class="inlinecode">::</span> 是右结合的。

</li>
<li> 使用 <span class="inlinecode">[</span> <span class="inlinecode">]</span> 代替 <span class="inlinecode"><span class="id" title="var">nil</span></span>。

</li>
<li> 使用单重中括号记法代替多重圆括号记法。

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x :: l" := (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;[ ]" := <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ x ; .. ; y ]" := (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> .. (<span class="id" title="var">cons</span> <span class="id" title="var">y</span> <span class="id" title="var">nil</span>) ..).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist1</span> := 1 :: (2 :: (3 :: <span class="id" title="var">nil</span>)).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist2</span> := 1 :: 2 :: 3 :: <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist3</span> := [1;2;3].<br/>

<br/>
</div>

<div class="doc">
  接下来，我们定义一些常用的列表操作函数。

</div>
<div class="code">
</div>

<div class="doc">
<a name="lab6"></a><h3 class="section">Head（带默认值）与 Tail</h3>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="var">hd</span></span> 函数返回列表 <span class="inlinecode"><span class="id" title="var">l</span></span> 的第一个元素（即“表头 (head)”）。
  由于空表没有表头，<span class="inlinecode"><span class="id" title="var">hd</span></span> 接受另一个参数 <span class="inlinecode"><span class="id" title="var">default</span></span> 
  作为这种特殊情况下的默认返回值。
  (后面，我们会学习一种更优雅的处理方式。)

<div class="paragraph"> </div>

  该函数的定义展示了如何对列表进行模式匹配:
<ul class="doclist">
<li> 空列表 <span class="inlinecode"><span class="id" title="var">nil</span></span>;

</li>
<li> 非空列表 <span class="inlinecode"><span class="id" title="var">l</span></span> 可以拆分为表头 <span class="inlinecode"><span class="id" title="var">h</span></span>
    与表尾 <span class="inlinecode"><span class="id" title="var">t</span></span> (tail; 仍是列表) 两部分。

</li>
</ul>
  这种模式匹配很常用。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd</span> (<span class="id" title="var">default</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">default</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">tl</span></span> 函数返回列表 <span class="inlinecode"><span class="id" title="var">l</span></span> 除表头以外的部分（即“表尾 (tail)”）。
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tl</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd1</span> : <span class="id" title="var">hd</span> 0 [1;2;3] = 1.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd2</span> : <span class="id" title="var">hd</span> 0 [] = 0.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_tl</span> : <span class="id" title="var">tl</span> [1;2;3] = [2;3].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab7"></a><h3 class="section">Repeat</h3>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> 函数接受自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">count</span></span>，
  返回一个包含了 <span class="inlinecode"><span class="id" title="var">count</span></span> 个 <span class="inlinecode"><span class="id" title="var">n</span></span> 的列表。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="tactic">repeat</span> (<span class="id" title="var">n</span> <span class="id" title="var">count</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">count</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">count'</span> ⇒ <span class="id" title="var">n</span> :: (<span class="id" title="tactic">repeat</span> <span class="id" title="var">n</span> <span class="id" title="var">count'</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab8"></a><h3 class="section">Length</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">length</span></span> 函数返回列表 <span class="inlinecode"><span class="id" title="var">l</span></span> 的长度。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">length</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab9"></a><h3 class="section">Append</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">app</span></span> 函数将两个列表 <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span> 联接起来。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">app</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span> :: (<span class="id" title="var">app</span> <span class="id" title="var">t</span> <span class="id" title="var">l2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
我们常用右结合的中缀运算符 <span class="inlinecode">++</span> 代替 <span class="inlinecode"><span class="id" title="var">app</span></span>。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x ++ y" := (<span class="id" title="var">app</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60).<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app1</span>: [1;2;3] ++ [4;5] = [1;2;3;4;5].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app2</span>: <span class="id" title="var">nil</span> ++ [4;5] = [4;5].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app3</span>: [1;2;3] ++ <span class="id" title="var">nil</span> = [1;2;3].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab10"></a><h3 class="section">练习</h3>

<div class="paragraph"> </div>

<a name="lab11"></a><h4 class="section">练习：2 星, standard, recommended (list_funs)</h4>

<div class="paragraph"> </div>

  完成函数 <span class="inlinecode"><span class="id" title="var">nonzeros</span></span>、<span class="inlinecode"><span class="id" title="var">oddmembers</span></span> 和 <span class="inlinecode"><span class="id" title="var">countoddmembers</span></span>
  的定义。你可以通过测试用例来理解这些函数的功能。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nonzeros</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nonzeros</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">nonzeros</span> [0;1;0;2;3;0;0] = [1;2;3].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">oddmembers</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_oddmembers</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">oddmembers</span> [0;1;0;2;3;0;0] = [1;3].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">countoddmembers</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers1</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">countoddmembers</span> [1;0;3;1;4;5] = 4.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers2</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">countoddmembers</span> [0;2;4] = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers3</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">countoddmembers</span> <span class="id" title="var">nil</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab12"></a><h4 class="section">练习：3 星, advanced (alternate)</h4>

<div class="paragraph"> </div>

  请完成函数 <span class="inlinecode"><span class="id" title="var">alternate</span></span> 的定义。
  它交替地从两个列表 <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span> 取元素，
  生成一个合并后的列表。你可以通过测试用例来理解它的功能。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">alternate</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate1</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">alternate</span> [1;2;3] [4;5;6] = [1;4;2;5;3;6].<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate2</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">alternate</span> [1] [4;5;6] = [1;4;5;6].<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate3</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">alternate</span> [1;2;3] [4] = [1;4;2;3].<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate4</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">alternate</span> [] [20;30] = [20;30].<br/>
<span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> <a name="lab13"></a><h4 class="section">练习：3 星, standard, recommended (more list functions)</h4>
 完成函数 <span class="inlinecode"><span class="id" title="var">count</span></span> 的定义。
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">count</span> (<span class="id" title="var">v</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_count1</span>: <span class="id" title="var">count</span> 1 [1;2;3;1;4;1] = 3.<br/>
<span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_count2</span>: <span class="id" title="var">count</span> 6 [1;2;3;1;4;1] = 0.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
完成函数 <span class="inlinecode"><span class="id" title="var">member</span></span> 的定义。
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">member</span> (<span class="id" title="var">v</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_member1</span>: <span class="id" title="var">member</span> 1 [1;4;1] = <span class="id" title="var">true</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_member2</span>: <span class="id" title="var">member</span> 2 [1;4;1] = <span class="id" title="var">false</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
完成函数 <span class="inlinecode"><span class="id" title="var">remov_one</span></span> 的定义。
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">remove_one</span> (<span class="id" title="var">v</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one1</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;5;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one2</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one3</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">count</span> 4 (<span class="id" title="var">remove_one</span> 5 [2;1;4;5;1;4]) = 2.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one4</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;5;4;5;1;4]) = 1.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
完成函数 <span class="inlinecode"><span class="id" title="var">remov_all</span></span> 的定义。
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">remove_all</span> (<span class="id" title="var">v</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all1</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;5;4;1]) = 0.<br/>
<span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all2</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;4;1]) = 0.<br/>
<span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all3</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">count</span> 4 (<span class="id" title="var">remove_all</span> 5 [2;1;4;5;1;4]) = 2.<br/>
<span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all4</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;5;4;5;1;4;5;1;4]) = 0.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
完成函数 <span class="inlinecode"><span class="id" title="var">subset</span></span> 的定义。
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">subset</span> (<span class="id" title="var">l1</span> : <span class="id" title="var">natlist</span>) (<span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_subset1</span>: <span class="id" title="var">subset</span> [1;2] [2;1;4;1] = <span class="id" title="var">true</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_subset2</span>: <span class="id" title="var">subset</span> [1;2;2] [2;1;4;1] = <span class="id" title="var">false</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab14"></a><h1 class="section">有关列表的论证</h1>

<div class="paragraph"> </div>

 和数字一样，有些列表处理函数的简单事实仅通过化简就能证明。
    例如，对于下面这个例子，<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 所做的简化就已经足够了... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">nil_app</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;[] ++ <span class="id" title="var">l</span> = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
...由于 <span class="inlinecode">[]</span> 被替换进了 <span class="inlinecode"><span class="id" title="var">app</span></span> 定义中相应的“被检”分支
    （即经由匹配“仔细检查”过值的表达式），整个匹配得以被简化。 
<div class="paragraph"> </div>

 和数字一样，有时对一个列表做分类讨论（是否是空）是非常有用的。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">tl_length_pred</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pred</span> (<span class="id" title="var">length</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> (<span class="id" title="var">tl</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l'</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
在这里 <span class="inlinecode"><span class="id" title="var">nil</span></span> 的情况能够工作是因为我们定义了 <span class="inlinecode"><span class="id" title="var">tl</span></span> <span class="inlinecode"><span class="id" title="var">nil</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">nil</span></span>，
    而 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 策略中 <span class="inlinecode"><span class="id" title="keyword">as</span></span> 注解引入的两个名字，<span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">l'</span></span>，分别对应了
    <span class="inlinecode"><span class="id" title="var">cons</span></span> 构造子的两个参数（正在构造的列表的头和尾）。 
<div class="paragraph"> </div>

 然而一般来说，许多关于列表的有趣定理都需要用到归纳法来证明。 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab15"></a><h2 class="section">对列表进行归纳</h2>

<div class="paragraph"> </div>

 比起对自然数的归纳，读者可能对归纳证明 <span class="inlinecode"><span class="id" title="var">natlist</span></span> 这样的数据类型更加陌生。
    不过基本思路同样简单。每个 <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> 声明定义了一组数据值，
    这些值可以用声明过的构造子来构造：布尔值可以用 <span class="inlinecode"><span class="id" title="var">true</span></span> 或 <span class="inlinecode"><span class="id" title="var">false</span></span> 来构造；
    自然数可以用 <span class="inlinecode"><span class="id" title="var">O</span></span> 或 <span class="inlinecode"><span class="id" title="var">S</span></span> 应用到另一个自然数上来构造；而列表可以用 <span class="inlinecode"><span class="id" title="var">nil</span></span>
    或者将 <span class="inlinecode"><span class="id" title="var">cons</span></span> 应用到一个自然数和另一个列表上来构造。

<div class="paragraph"> </div>

    除此以外，归纳定义的集合中元素的形式 <i>'只能是'</i> 构造子对其它项的应用；
    这一事实同时也给出了一种对归纳定义的集合进行论证的方法：一个自然数要么是
    <span class="inlinecode"><span class="id" title="var">O</span></span>，要么就是 <span class="inlinecode"><span class="id" title="var">S</span></span> 应用到某个<i>'更小'</i>的自然数上；一个列表要么是 <span class="inlinecode"><span class="id" title="var">nil</span></span>，
    要么就是 <span class="inlinecode"><span class="id" title="var">cons</span></span> 应用到某个数字和某个<i>'更小'</i>的列表上，诸如此类。
    所以，如果我们有某个命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 涉及列表 <span class="inlinecode"><span class="id" title="var">l</span></span>，而我们想证明 <span class="inlinecode"><span class="id" title="var">P</span></span> 对 <i>'一切'</i>
    列表都成立，那么可以像这样推理：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 首先，证明当 <span class="inlinecode"><span class="id" title="var">l</span></span> 为 <span class="inlinecode"><span class="id" title="var">nil</span></span> 时 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> 成立。

<div class="paragraph"> </div>


</li>
<li> 然后，证明当 <span class="inlinecode"><span class="id" title="var">l</span></span> 为 <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span> 时 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> 成立，其中 <span class="inlinecode"><span class="id" title="var">n</span></span> 是某个自然数，<span class="inlinecode"><span class="id" title="var">l'</span></span>
      是某个更小的列表，假设 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span> 成立.

</li>
</ul>

<div class="paragraph"> </div>

    由于较大的列表只能通过较小的列表构造出来，最终这个较小的列表会变成
    <span class="inlinecode"><span class="id" title="var">nil</span></span>，这两点合在一起就完成了 <span class="inlinecode"><span class="id" title="var">P</span></span> 对一切列表 <span class="inlinecode"><span class="id" title="var">l</span></span> 成立的证明。下面是个具体的例子： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) ++ <span class="id" title="var">l3</span> = <span class="id" title="var">l1</span> ++ (<span class="id" title="var">l2</span> ++ <span class="id" title="var">l3</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l1'</span> <span class="id" title="var">IHl1'</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl1'</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
注意，和归纳自然数时一样，此处 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 策略的 <span class="inlinecode"><span class="id" title="keyword">as</span>...</span> 从句为在
    “<span class="inlinecode"><span class="id" title="var">l1</span></span> 由构造子 <span class="inlinecode"><span class="id" title="var">cons</span></span> 构造而来”这一情况时出现的“更小的列表”和归纳假设取了名字。
    再次强调，如果你把 Coq 的证明当做静态的文档，那么可能不会有特别多的收获 ——
    如果你通过交互式的 Coq 会话来阅读证明，就能看到当前的目标和上下文，
    而这些状态在你阅读写下来的脚本时是不可见的。所以一份用自然语言写成的证明 ——
    写给人看的 —— 需要包含更多的提示来帮助读者理解当前的状态，
    比如第二种情况下的归纳假设到底是什么。 
<div class="paragraph"> </div>

 <i>'定理'</i>：对所有的列表 <span class="inlinecode"><span class="id" title="var">l1</span></span>, <span class="inlinecode"><span class="id" title="var">l2</span></span>, 和 <span class="inlinecode"><span class="id" title="var">l3</span></span>，
   <span class="inlinecode">(<span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">(<span class="id" title="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span>)</span>。

<div class="paragraph"> </div>

   <i>'证明'</i>: 通过对 <span class="inlinecode"><span class="id" title="var">l1</span></span> 使用归纳法。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 首先, 假设 <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>。我们必须证明：

<div class="paragraph"> </div>

       (<font size=-2>&#9744;</font> ++ l2) ++ l3 = <font size=-2>&#9744;</font> ++ (l2 ++ l3),

<div class="paragraph"> </div>

     这可以通过展开 <span class="inlinecode">++</span> 的定义得到。

<div class="paragraph"> </div>


</li>
<li> 然后, 假设 <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l1'</span></span>，有：

<div class="paragraph"> </div>

       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)

<div class="paragraph"> </div>

     （归纳假设）。我们必须证明：

<div class="paragraph"> </div>

       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).

<div class="paragraph"> </div>

     根据 <span class="inlinecode">++</span> 的定义, 上式等价于：

<div class="paragraph"> </div>

       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),

<div class="paragraph"> </div>

     该式可通过我们的归纳假设立即证得。  <font size=-2>&#9744;</font> 
</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h3 class="section">反转列表</h3>

<div class="paragraph"> </div>

 举一个更加深入的例子来说明对列表的归纳证明：假设我们使用 <span class="inlinecode"><span class="id" title="var">app</span></span>
    来定义一个列表反转函数 <span class="inlinecode"><span class="id" title="var">rev</span></span>： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">rev</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">rev</span> <span class="id" title="var">t</span> ++ [<span class="id" title="var">h</span>]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_rev1</span>:            <span class="id" title="var">rev</span> [1;2;3] = [3;2;1].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_rev2</span>:            <span class="id" title="var">rev</span> <span class="id" title="var">nil</span> = <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h3 class="section"><span class="inlinecode"><span class="id" title="var">rev</span></span> 的性质</h3>

<div class="paragraph"> </div>

 Now, for something a bit more challenging than the proofs
    we've seen so far, let's prove that reversing a list does not
    change its length.  Our first attempt gets stuck in the successor
    case... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_length_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHl'</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
不妨单独提出引理，阐述 <span class="inlinecode">++</span> 与 <span class="inlinecode"><span class="id" title="var">length</span></span> 形成的等式关系，
    以推进证明。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_length</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = (<span class="id" title="var">length</span> <span class="id" title="var">l1</span>) + (<span class="id" title="var">length</span> <span class="id" title="var">l2</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l1'</span> <span class="id" title="var">IHl1'</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl1'</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
注意，为了让该引理尽可能 <i>'通用'</i>，我们不仅关心由 <span class="inlinecode"><span class="id" title="var">rev</span></span> 得到的列表，
    还要对 <i>'所有'</i> 的 <span class="inlinecode"><span class="id" title="var">natlist</span></span> 进行全称量化。这很自然，因为这个证明目标
    显然不依赖于被反转的列表。除此之外，证明这个更普遍的性质也更容易些。 
<div class="paragraph"> </div>

 现在我们可以完成最初的证明了。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_length</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">app_length</span>, <span class="id" title="var">plus_comm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
作为对比，以下是这两个定理的非形式化证明：

<div class="paragraph"> </div>

    <i>'定理'</i>：对于所有的列表 <span class="inlinecode"><span class="id" title="var">l1</span></span> 和 <span class="inlinecode"><span class="id" title="var">l2</span></span>，
       <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span>.

<div class="paragraph"> </div>

    <i>'证明'</i>：对 <span class="inlinecode"><span class="id" title="var">l1</span></span> 进行归纳。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 首先，假设 <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>。我们必须证明

<div class="paragraph"> </div>

        length (<font size=-2>&#9744;</font> ++ l2) = length <font size=-2>&#9744;</font> + length l2,

<div class="paragraph"> </div>

      根据 <span class="inlinecode"><span class="id" title="var">length</span></span> 和 <span class="inlinecode">++</span> 的定义，上式显然可得。

<div class="paragraph"> </div>


</li>
<li> 其次，假设 <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l1'</span></span>，并且

<div class="paragraph"> </div>

        length (l1' ++ l2) = length l1' + length l2.

<div class="paragraph"> </div>

      我们必须证明

<div class="paragraph"> </div>

        length ((n::l1') ++ l2) = length (n::l1') + length l2).

<div class="paragraph"> </div>

      根据 <span class="inlinecode"><span class="id" title="var">length</span></span> 和 <span class="inlinecode">++</span> 的定义以及归纳假设，上式显然可得。 <font size=-2>&#9744;</font> 
</li>
</ul>

<div class="paragraph"> </div>

 <i>'定理'</i>: 对于所有的列表 <span class="inlinecode"><span class="id" title="var">l</span></span>，<span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">rev</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>。

<div class="paragraph"> </div>

    <i>'证明'</i>: 对 <span class="inlinecode"><span class="id" title="var">l</span></span> 进行归纳。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 首先，假设 <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>。我们必须证明

<div class="paragraph"> </div>

          length (rev <font size=-2>&#9744;</font>) = length <font size=-2>&#9744;</font>,

<div class="paragraph"> </div>

        根据 <span class="inlinecode"><span class="id" title="var">length</span></span> 和 <span class="inlinecode"><span class="id" title="var">rev</span></span> 的定义，上式显然可得。

<div class="paragraph"> </div>


</li>
<li> 其次，假设 <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l'</span></span>，并且

<div class="paragraph"> </div>

          length (rev l') = length l'.

<div class="paragraph"> </div>

        我们必须证明

<div class="paragraph"> </div>

          length (rev (n :: l')) = length (n :: l').

<div class="paragraph"> </div>

        根据 <span class="inlinecode"><span class="id" title="var">rev</span></span> 的定义，上式来自于

<div class="paragraph"> </div>

          length ((rev l') ++ <span class="inlinecode"><span class="id" title="var">n</span></span>) = S (length l')

<div class="paragraph"> </div>

        根据之前的引理，此式等同于

<div class="paragraph"> </div>

          length (rev l') + length <span class="inlinecode"><span class="id" title="var">n</span></span> = S (length l').

<div class="paragraph"> </div>

        根据归纳假设和 <span class="inlinecode"><span class="id" title="var">length</span></span> 的定义，上式显然可得。 <font size=-2>&#9744;</font> 
</li>
</ul>

<div class="paragraph"> </div>

 这些证明的风格实在是冗长而迂腐。几次练习之后，我们会发现减少细枝末节，
    详述不太显然的步骤更有助于我们理解证明。毕竟细节更容易在大脑中思考，
    必要时我们还可以在草稿纸上补全。下面我们以一种更加紧凑的方式呈现之前的证明： 
<div class="paragraph"> </div>

 <i>'定理'</i>：
     对于所有 <span class="inlinecode"><span class="id" title="var">l</span></span>，<span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">rev</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>。

<div class="paragraph"> </div>

    <i>'证明'</i>：首先，观察到 <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">l</span></span> <span class="inlinecode">++</span> <span class="inlinecode">[<span class="id" title="var">n</span>])</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> 对一切 <span class="inlinecode"><span class="id" title="var">l</span></span> 成立
    （通过对 <span class="inlinecode"><span class="id" title="var">l</span></span> 的归纳直接可得）。当 <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n'</span>::<span class="id" title="var">l'</span></span> 时，通过再次对 <span class="inlinecode"><span class="id" title="var">l</span></span> 使用归纳，
    然后同时使用之前观察得到的性质和归纳假设即可证明。 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 一般而言，在不同的情况下合适的风格也会不同：读者对这个问题了解程度，
    以及当前的证明与读者熟悉的证明之间的相似度都会影响到这一点。
    对于我们现在的目的而言，最好先用更加冗长的方式。 
<div class="paragraph"> </div>

<a name="lab18"></a><h2 class="section"><span class="inlinecode"><span class="id" title="keyword">Search</span></span> 搜索</h2>

<div class="paragraph"> </div>

 我们已经见过很多需要使用之前证明过的结论（例如通过 <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>）来证明的定理了。
    但是在引用别的定理时，我们必须事先知道它们的名字。当然，即使是已被证明的定理本身
    我们都不能全部记住，更不用提它们的名字了。

<div class="paragraph"> </div>

    Coq 的 <span class="inlinecode"><span class="id" title="keyword">Search</span></span> 指令在这时就非常有用了。执行 <span class="inlinecode"><span class="id" title="keyword">Search</span></span> <span class="inlinecode"><span class="id" title="var">foo</span></span> 会让 Coq
    显示所有涉及到 <span class="inlinecode"><span class="id" title="var">foo</span></span> 的定理。例如，去掉下面的注释后，
    你会看到一个我们证明过的所有关于 <span class="inlinecode"><span class="id" title="var">rev</span></span> 的定理的列表： 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
在接下来的学习中，你要记得使用 <span class="inlinecode"><span class="id" title="keyword">Search</span></span>，它能为你节约大量的时间！

<div class="paragraph"> </div>

    如果你正在使用 ProofGeneral，那么可以用 <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">a</span></span> 来运行 <span class="inlinecode"><span class="id" title="keyword">Search</span></span>。
    通过 <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-;</span> 可以将它返回的结果粘贴到缓冲区内。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab19"></a><h2 class="section">列表练习，第一部分</h2>

<div class="paragraph"> </div>

<a name="lab20"></a><h4 class="section">练习：3 星, standard (list_exercises)</h4>


<div class="paragraph"> </div>

    更多有关列表的实践： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">l</span> ++ [] = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_app_distr</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">rev</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = <span class="id" title="var">rev</span> <span class="id" title="var">l2</span> ++ <span class="id" title="var">rev</span> <span class="id" title="var">l1</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_involutive</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
下面的练习有简短的解法，如果你开始发现情况已经复杂到你无法理清的程度，
    请后退一步并试着寻找更为简单的方法。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc4</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> <span class="id" title="var">l4</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">l1</span> ++ (<span class="id" title="var">l2</span> ++ (<span class="id" title="var">l3</span> ++ <span class="id" title="var">l4</span>)) = ((<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) ++ <span class="id" title="var">l3</span>) ++ <span class="id" title="var">l4</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
一个关于你对 <span class="inlinecode"><span class="id" title="var">nonzeros</span></span> 的实现的练习： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nonzeros_app</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">nonzeros</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = (<span class="id" title="var">nonzeros</span> <span class="id" title="var">l1</span>) ++ (<span class="id" title="var">nonzeros</span> <span class="id" title="var">l2</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab21"></a><h4 class="section">练习：2 星, standard (eqblist)</h4>


<div class="paragraph"> </div>

    填写 <span class="inlinecode"><span class="id" title="var">eqblist</span></span> 的定义，它通过比较列表中的数字来判断是否相等。
    证明对于所有列表 <span class="inlinecode"><span class="id" title="var">l</span></span>，<span class="inlinecode"><span class="id" title="var">eqblist</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> 返回 <span class="inlinecode"><span class="id" title="var">true</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">eqblist</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_eqblist1</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="var">eqblist</span> <span class="id" title="var">nil</span> <span class="id" title="var">nil</span> = <span class="id" title="var">true</span>).<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_eqblist2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">eqblist</span> [1;2;3] [1;2;3] = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_eqblist3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">eqblist</span> [1;2;3] [1;2;4] = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eqblist_refl</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">eqblist</span> <span class="id" title="var">l</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab22"></a><h2 class="section">列表练习, 第二部分</h2>

<div class="paragraph"> </div>

 下面这组简单的定理用于证明你之前关于袋子的定义。 
<div class="paragraph"> </div>

<a name="lab23"></a><h4 class="section">练习：1 星, standard (count_member_nonzero)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">count_member_nonzero</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">s</span> : <span class="id" title="var">bag</span>),<br/>
&nbsp;&nbsp;1 &lt;=? (<span class="id" title="var">count</span> 1 (1 :: <span class="id" title="var">s</span>)) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 下面这条关于 <span class="inlinecode"><span class="id" title="var">leb</span></span> 的引理可助你完成下一个证明。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">leb_n_Sn</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> &lt;=? (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">IHn'</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Before doing the next exercise, make sure you've filled in the
   definition of <span class="inlinecode"><span class="id" title="var">remove_one</span></span> above. <a name="lab24"></a><h4 class="section">练习：3 星, advanced (remove_does_not_increase_count)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">remove_does_not_increase_count</span>: <span class="id" title="keyword">∀</span> (<span class="id" title="var">s</span> : <span class="id" title="var">bag</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">count</span> 0 (<span class="id" title="var">remove_one</span> 0 <span class="id" title="var">s</span>)) &lt;=? (<span class="id" title="var">count</span> 0 <span class="id" title="var">s</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab25"></a><h4 class="section">练习：3 星, standard, optional (bag_count_sum)</h4>


<div class="paragraph"> </div>

    写下一个用到函数 <span class="inlinecode"><span class="id" title="var">count</span></span> 和 <span class="inlinecode"><span class="id" title="var">sum</span></span> 的，关于袋子的有趣定理 <span class="inlinecode"><span class="id" title="var">bag_count_sum</span></span>，
    然后证明它。（你可能会发现该证明的难度取决于你如何定义 <span class="inlinecode"><span class="id" title="var">count</span></span>！） 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab26"></a><h4 class="section">练习：4 星, advanced (rev_injective)</h4>


<div class="paragraph"> </div>

    求证 <span class="inlinecode"><span class="id" title="var">rev</span></span> 是单射函数，即：

<div class="paragraph"> </div>

    forall (l1 l2 : natlist), rev l1 = rev l2 -&gt; l1 = l2.

<div class="paragraph"> </div>

    （这个问题既可以用简单的方式解决也可以用繁琐的方式来解决。） 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">manual_grade_for_rev_injective</span> : <span class="id" title="var">option</span> (<span class="id" title="var">nat</span>×<span class="id" title="var">string</span>) := <span class="id" title="var">None</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab27"></a><h1 class="section">Options 可选类型</h1>

<div class="paragraph"> </div>

 假设我们想要写一个返回某个列表中第 <span class="inlinecode"><span class="id" title="var">n</span></span> 个元素的函数。如果我们为它赋予类型
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">natlist</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>，那么当列表太短时我们仍须返回某个数... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nth_bad</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ 42  <br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l'</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">n</span> =? <span class="id" title="var">O</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">nth_bad</span> <span class="id" title="var">l'</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
这种方案并不好：如果 <span class="inlinecode"><span class="id" title="var">nth_bad</span></span> 返回了 <span class="inlinecode">42</span>，那么不经过进一步处理的话，
    我们无法得知该值是否真的出现在了输入中。（译注：我们无法判断是什么因素让它返回了
    <span class="inlinecode">42</span>，因为它可能是列表过短时的返回值，同时也可能是（此时列表足够长）在列表中找到的值）
    一种更好的方式是改变 <span class="inlinecode"><span class="id" title="var">nth_bad</span></span> 的返回类型，使其包含一个错误值作为可能的结果。
    我们将此类型命名为 <span class="inlinecode"><span class="id" title="var">natoption</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natoption</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Some</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">None</span>.<br/>

<br/>
</div>

<div class="doc">
然后我们可以修改前面 <span class="inlinecode"><span class="id" title="var">nth_bad</span></span> 的定义，使其在列表太短时返回 <span class="inlinecode"><span class="id" title="var">None</span></span>，
    在列表足够长且 <span class="inlinecode"><span class="id" title="var">a</span></span> 在 <span class="inlinecode"><span class="id" title="var">n</span></span> 处时返回 <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span>。我们将这个新函数称为
    <span class="inlinecode"><span class="id" title="var">nth_error</span></span> 来表明它可以产生带错误的结果。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nth_error</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l'</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">n</span> =? <span class="id" title="var">O</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">Some</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">nth_error</span> <span class="id" title="var">l'</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nth_error1</span> : <span class="id" title="var">nth_error</span> [4;5;6;7] 0 = <span class="id" title="var">Some</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nth_error2</span> : <span class="id" title="var">nth_error</span> [4;5;6;7] 3 = <span class="id" title="var">Some</span> 7.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nth_error3</span> : <span class="id" title="var">nth_error</span> [4;5;6;7] 9 = <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
（在 HTML 版本中隐藏了这些老套的证明。若你想看它请点击小方格。）

<div class="paragraph"> </div>

    本例也是个介绍 Coq 编程语言更多细微特性的机会，比如条件表达式... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nth_error'</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l'</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">n</span> =? <span class="id" title="var">O</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Some</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">nth_error'</span> <span class="id" title="var">l'</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Coq 的条件语句和其它语言中的一样，不过加上了一点更为一般化的特性。
    由于布尔类型不是内建的，因此 Coq 实际上支持在<i>'任何'</i>带有两个构造子的，
    归纳定义的类型上使用条件表达式。当断言（guard）求值为 <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>
    定义中的第一个构造子时，它被认为是真的；当它被求值到第二个构造子时，
    则被认为是假的。 
<div class="paragraph"> </div>

 以下函数从 <span class="inlinecode"><span class="id" title="var">natoption</span></span> 中取出一个 <span class="inlinecode"><span class="id" title="var">nat</span></span>，在遇到 <span class="inlinecode"><span class="id" title="var">None</span></span> 时它将返回提供的默认值。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">option_elim</span> (<span class="id" title="var">d</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">o</span> : <span class="id" title="var">natoption</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">o</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">n'</span> ⇒ <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">None</span> ⇒ <span class="id" title="var">d</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab28"></a><h4 class="section">练习：2 星, standard (hd_error)</h4>
 用同样的思路修正之前的 <span class="inlinecode"><span class="id" title="var">hd</span></span> 函数，使我们无需为 <span class="inlinecode"><span class="id" title="var">nil</span></span> 的情况提供默认元素。  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd_error</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natoption</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_error1</span> : <span class="id" title="var">hd_error</span> [] = <span class="id" title="var">None</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_error2</span> : <span class="id" title="var">hd_error</span> [1] = <span class="id" title="var">Some</span> 1.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_error3</span> : <span class="id" title="var">hd_error</span> [5;6] = <span class="id" title="var">Some</span> 5.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab29"></a><h4 class="section">练习：1 星, standard, optional (option_elim_hd)</h4>
 此练习能帮助你在新的 <span class="inlinecode"><span class="id" title="var">hd_error</span></span> 和旧的 <span class="inlinecode"><span class="id" title="var">hd</span></span> 之间建立联系。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">option_elim_hd</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">default</span>:<span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">hd</span> <span class="id" title="var">default</span> <span class="id" title="var">l</span> = <span class="id" title="var">option_elim</span> <span class="id" title="var">default</span> (<span class="id" title="var">hd_error</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatList</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab30"></a><h1 class="section">偏映射（Partial Maps）</h1>

<div class="paragraph"> </div>

 最后演示一下如何在 Coq 中定义基础的数据结构。这是一个简单的
    <i>'偏映射'</i> 数据类型，它类似于大多数编程语言中的映射或字典数据结构。 
<div class="paragraph"> </div>

 首先，我们定义一个新的归纳数据类型 <span class="inlinecode"><span class="id" title="var">id</span></span> 来用作偏映射的“键”。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">id</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Id</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>).<br/>

<br/>
</div>

<div class="doc">
本质上来说，<span class="inlinecode"><span class="id" title="var">id</span></span> 只是一个数。但通过 <span class="inlinecode"><span class="id" title="var">Id</span></span> 标签封装自然数来引入新的类型，
    能让定义变得更加可读，同时我们也可以灵活地按需修改它的定义。 
<div class="paragraph"> </div>

 我们还需要一个 <span class="inlinecode"><span class="id" title="var">id</span></span> 的相等关系测试： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">eqb_id</span> (<span class="id" title="var">x1</span> <span class="id" title="var">x2</span> : <span class="id" title="var">id</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">x1</span>, <span class="id" title="var">x2</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Id</span> <span class="id" title="var">n1</span>, <span class="id" title="var">Id</span> <span class="id" title="var">n2</span> ⇒ <span class="id" title="var">n1</span> =? <span class="id" title="var">n2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab31"></a><h4 class="section">练习：1 星, standard (eqb_id_refl)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eqb_id_refl</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">true</span> = <span class="id" title="var">eqb_id</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 现在我们定义偏映射的类型： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">PartialMap</span>.<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">NatList</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">partial_map</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">empty</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">record</span> (<span class="id" title="var">i</span> : <span class="id" title="var">id</span>) (<span class="id" title="var">v</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">m</span> : <span class="id" title="var">partial_map</span>).<br/>

<br/>
</div>

<div class="doc">
此声明可以读作：“有两种方式可以构造一个 <span class="inlinecode"><span class="id" title="var">partial_map</span></span>：用构造子 <span class="inlinecode"><span class="id" title="var">empty</span></span>
    表示一个空的偏映射，或通过将构造子 <span class="inlinecode"><span class="id" title="var">record</span></span> 应用到一个键、一个值和一个既有的
    <span class="inlinecode"><span class="id" title="var">partial_map</span></span> 来构造一个带“键-值”映射 的 <span class="inlinecode"><span class="id" title="var">partial_map</span></span>。”
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">update</span></span> 函数在部分映射中覆盖给定的键以取缔原值（如该键尚不存在，
    则新建其记录）。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">update</span> (<span class="id" title="var">d</span> : <span class="id" title="var">partial_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> : <span class="id" title="var">id</span>) (<span class="id" title="var">value</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">partial_map</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">record</span> <span class="id" title="var">x</span> <span class="id" title="var">value</span> <span class="id" title="var">d</span>.<br/>

<br/>
</div>

<div class="doc">
最后，<span class="inlinecode"><span class="id" title="var">find</span></span> 函数按照给定的键搜索一个 <span class="inlinecode"><span class="id" title="var">partial_map</span></span>。若该键无法找到，
    它就返回 <span class="inlinecode"><span class="id" title="var">None</span></span>；若该键与 <span class="inlinecode"><span class="id" title="var">val</span></span> 相关联，则返回 <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">val</span></span>。
    若同一个键被映到多个值，<span class="inlinecode"><span class="id" title="var">find</span></span> 就会返回它遇到的第一个值。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">find</span> (<span class="id" title="var">x</span> : <span class="id" title="var">id</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">partial_map</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">d</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">empty</span>         ⇒ <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">record</span> <span class="id" title="var">y</span> <span class="id" title="var">v</span> <span class="id" title="var">d'</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">eqb_id</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="var">Some</span> <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">find</span> <span class="id" title="var">x</span> <span class="id" title="var">d'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab32"></a><h4 class="section">练习：1 星, standard (update_eq)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">update_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">d</span> : <span class="id" title="var">partial_map</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">id</span>) (<span class="id" title="var">v</span>: <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">find</span> <span class="id" title="var">x</span> (<span class="id" title="var">update</span> <span class="id" title="var">d</span> <span class="id" title="var">x</span> <span class="id" title="var">v</span>) = <span class="id" title="var">Some</span> <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab33"></a><h4 class="section">练习：1 星, standard (update_neq)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">update_neq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">d</span> : <span class="id" title="var">partial_map</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">id</span>) (<span class="id" title="var">o</span>: <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eqb_id</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> = <span class="id" title="var">false</span> → <span class="id" title="var">find</span> <span class="id" title="var">x</span> (<span class="id" title="var">update</span> <span class="id" title="var">d</span> <span class="id" title="var">y</span> <span class="id" title="var">o</span>) = <span class="id" title="var">find</span> <span class="id" title="var">x</span> <span class="id" title="var">d</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
<span class="id" title="keyword">End</span> <span class="id" title="var">PartialMap</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab34"></a><h4 class="section">练习：2 星, standard (baz_num_elts)</h4>


<div class="paragraph"> </div>

    考虑以下归纳定义： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">baz</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Baz1</span> (<span class="id" title="var">x</span> : <span class="id" title="var">baz</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">Baz2</span> (<span class="id" title="var">y</span> : <span class="id" title="var">baz</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>).<br/>

<br/>
</div>

<div class="doc">
有<i>'多少'</i>个表达式具备类型 <span class="inlinecode"><span class="id" title="var">baz</span></span>？（以注释说明。） 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">manual_grade_for_baz_num_elts</span> : <span class="id" title="var">option</span> (<span class="id" title="var">nat</span>×<span class="id" title="var">string</span>) := <span class="id" title="var">None</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>