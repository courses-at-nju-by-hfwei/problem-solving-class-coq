<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Lists: 使用结构化的数据</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://coq-zh.github.io/SF-zh/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 1: 逻辑基础</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>目录</li></a>
   <a href='coqindex.html'><li class='section_name'>索引</li></a>
   <a href='deps.html'><li class='section_name'>路线</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">Lists<span class="subtitle">使用结构化的数据</span></h1>


<div class="code code-tight">

<span class="id" type="var">From</span> <span class="id" type="var">LF</span> <span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <span class="id" type="keyword">Induction</span>.<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">NatList</span>.<br/>
</div>

<div class="doc">
<a name="lab64"></a><h1 class="section">数值序对</h1>

<div class="paragraph"> </div>

 在 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 类型定义中，每个构造子（Constructor）可以有任意多个参数
    —— 可以没有（如 <span class="inlinecode"><span class="id" type="var">true</span></span> 和 <span class="inlinecode"><span class="id" type="var">O</span></span>），可以只有一个（如 <span class="inlinecode"><span class="id" type="var">S</span></span>），也可以更多
    （如 <span class="inlinecode"><span class="id" type="var">nybble</span></span>，以及下文所示）： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <span class="id" type="var">natprod</span> : <span class="id" type="keyword">Type</span> :=<br/>
| <span class="id" type="var">pair</span> (<span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> : <span class="id" type="var">nat</span>).<br/>
</div>

<div class="doc">
此声明可以读作：“只有一种方式来构造一个数值序对：通过将构造子 <span class="inlinecode"><span class="id" type="var">pair</span></span>
    应用到两个 <span class="inlinecode"><span class="id" type="var">nat</span></span> 类型的参数上”。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> (<span class="id" type="var">pair</span> 3 5).<br/>
</div>

<div class="doc">
下述函数分别用于提取二元组中的第一个和第二个分量。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">fst</span> (<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">pair</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ⇒ <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">snd</span> (<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">pair</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ⇒ <span class="id" type="var">y</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="var">Compute</span> (<span class="id" type="var">fst</span> (<span class="id" type="var">pair</span> 3 5)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;3&nbsp;*)</span><br/>
</div>

<div class="doc">
鉴于二元组较为常用，不妨以标准的数学记法 <span class="inlinecode">(<span class="id" type="var">x</span>,<span class="id" type="var">y</span>)</span> 取代 <span class="inlinecode"><span class="id" type="var">pair</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span>。
    通过 <span class="inlinecode"><span class="id" type="keyword">Notation</span></span> 向 Coq 声明该记法： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Notation</span> "( x , y )" := (<span class="id" type="var">pair</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>).<br/>
</div>

<div class="doc">
The new pair notation can be used both in expressions and in
    pattern matches. 
</div>
<div class="code code-tight">

<span class="id" type="var">Compute</span> (<span class="id" type="var">fst</span> (3,5)).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">fst'</span> (<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) ⇒ <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">snd'</span> (<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) ⇒ <span class="id" type="var">y</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">swap_pair</span> (<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>) : <span class="id" type="var">natprod</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) ⇒ (<span class="id" type="var">y</span>,<span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Note that pattern-matching on a pair (with parentheses: <span class="inlinecode">(<span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">y</span>)</span>)
    is not to be confused with the "multiple pattern" syntax
    (with no parentheses: <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">y</span></span>) that we have seen previously.

<div class="paragraph"> </div>

    The above examples illustrate pattern matching on a pair with
    elements <span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">y</span></span>, whereas <span class="inlinecode"><span class="id" type="var">minus</span></span> below (taken from
    <a href="Basics.html"><span class="inlineref">Basics</span></a>) performs pattern matching on the values <span class="inlinecode"><span class="id" type="var">n</span></span>
    and <span class="inlinecode"><span class="id" type="var">m</span></span>.

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span>&nbsp;<span class="id" type="var">minus</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">m</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>)&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span>&nbsp;<span class="id" type="var">n</span>,&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">O</span>&nbsp;&nbsp;&nbsp;,&nbsp;<span class="id" type="var">_</span>&nbsp;&nbsp;&nbsp;&nbsp;⇒&nbsp;<span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">_</span>&nbsp;,&nbsp;<span class="id" type="var">O</span>&nbsp;&nbsp;&nbsp;&nbsp;⇒&nbsp;<span class="id" type="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n'</span>,&nbsp;<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">m'</span>&nbsp;⇒&nbsp;<span class="id" type="var">minus</span>&nbsp;<span class="id" type="var">n'</span>&nbsp;<span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.
<div class="paragraph"> </div>

</div>
    The distinction is minor, but it is worth knowing that they
    are not the same. For instance, the following definitions are
    ill-formed:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Can't&nbsp;match&nbsp;on&nbsp;a&nbsp;pair&nbsp;with&nbsp;multiple&nbsp;patterns:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">bad_fst</span>&nbsp;(<span class="id" type="var">p</span>&nbsp;:&nbsp;<span class="id" type="var">natprod</span>)&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span>&nbsp;<span class="id" type="var">p</span>&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">x</span>,&nbsp;<span class="id" type="var">y</span>&nbsp;⇒&nbsp;<span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Can't&nbsp;match&nbsp;on&nbsp;multiple&nbsp;values&nbsp;with&nbsp;pair&nbsp;patterns:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">bad_minus</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">m</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>)&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span>&nbsp;<span class="id" type="var">n</span>,&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(<span class="id" type="var">O</span>&nbsp;&nbsp;&nbsp;,&nbsp;<span class="id" type="var">_</span>&nbsp;&nbsp;&nbsp;)&nbsp;⇒&nbsp;<span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">_</span>&nbsp;,&nbsp;<span class="id" type="var">O</span>&nbsp;&nbsp;&nbsp;)&nbsp;⇒&nbsp;<span class="id" type="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n'</span>,&nbsp;<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">m'</span>)&nbsp;⇒&nbsp;<span class="id" type="var">bad_minus</span>&nbsp;<span class="id" type="var">n'</span>&nbsp;<span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 我们现在来证明一些有关二元组的简单事实。

<div class="paragraph"> </div>

    定理倘若以稍显古怪的方式书写，则只需 <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>（及其内建的简化）
    即可完成证明。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">surjective_pairing'</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">n</span>,<span class="id" type="var">m</span>) = (<span class="id" type="var">fst</span> (<span class="id" type="var">n</span>,<span class="id" type="var">m</span>), <span class="id" type="var">snd</span> (<span class="id" type="var">n</span>,<span class="id" type="var">m</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
但是，如果我们用一种更为自然的方式来陈述此引理的话，只用
    <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 还不够。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">surjective_pairing_stuck</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">p</span> = (<span class="id" type="var">fst</span> <span class="id" type="var">p</span>, <span class="id" type="var">snd</span> <span class="id" type="var">p</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;啥也没有归约！&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
我们必须要向 Coq 展示 <span class="inlinecode"><span class="id" type="var">p</span></span> 的具体结构，这样 <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> 才能对
    <span class="inlinecode"><span class="id" type="var">fst</span></span> 和 <span class="inlinecode"><span class="id" type="var">snd</span></span> 做模式匹配。通过 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 可以达到这个目的。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">surjective_pairing</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">p</span> = (<span class="id" type="var">fst</span> <span class="id" type="var">p</span>, <span class="id" type="var">snd</span> <span class="id" type="var">p</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">n</span> <span class="id" type="var">m</span>]. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
注意：不同于解构自然数产生两个子目标，<span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 在此只产生
    一个子目标。这是因为 <span class="inlinecode"><span class="id" type="var">natprod</span></span> 只有一种构造方法。 
<div class="paragraph"> </div>

<a name="lab65"></a><h4 class="section">练习：1 星, standard (snd_fst_is_swap)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">snd_fst_is_swap</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">snd</span> <span class="id" type="var">p</span>, <span class="id" type="var">fst</span> <span class="id" type="var">p</span>) = <span class="id" type="var">swap_pair</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab66"></a><h4 class="section">练习：1 星, standard, optional (fst_swap_is_snd)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">fst_swap_is_snd</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">p</span> : <span class="id" type="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">fst</span> (<span class="id" type="var">swap_pair</span> <span class="id" type="var">p</span>) = <span class="id" type="var">snd</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab67"></a><h1 class="section">数值列表</h1>

<div class="paragraph"> </div>

 通过推广序对的定义，数值<b>列表</b>类型可以这样描述：
    “一个列表要么是空的，要么就是由一个数和另一个列表组成的序对。” 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <span class="id" type="var">natlist</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">cons</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">natlist</span>).<br/>
</div>

<div class="doc">
例如，这是一个三元素列表： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">mylist</span> := <span class="id" type="var">cons</span> 1 (<span class="id" type="var">cons</span> 2 (<span class="id" type="var">cons</span> 3 <span class="id" type="var">nil</span>)).<br/>
</div>

<div class="doc">
和序对一样，使用熟悉的编程记法来表示列表会更方便些。
    以下两个声明能让我们用 <span class="inlinecode">::</span> 作为中缀的 <span class="inlinecode"><span class="id" type="var">cons</span></span> 操作符，
    用方括号作为构造列表的“外围（outfix）”记法。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Notation</span> "x :: l" := (<span class="id" type="var">cons</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 60, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> "[ ]" := <span class="id" type="var">nil</span>.<br/>
<span class="id" type="keyword">Notation</span> "[ x ; .. ; y ]" := (<span class="id" type="var">cons</span> <span class="id" type="var">x</span> .. (<span class="id" type="var">cons</span> <span class="id" type="var">y</span> <span class="id" type="var">nil</span>) ..).<br/>
</div>

<div class="doc">
我们不必完全理解这些声明，但如果你感兴趣的话，我会大致说明一下
    发生了什么。 <span class="inlinecode"><span class="id" type="var">right</span></span> <span class="inlinecode"><span class="id" type="var">associativity</span></span> 告诉 Coq 当遇到多个 <span class="inlinecode">::</span>
    时如何给表达式加括号，如此一来下面三个声明做的就是同一件事： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">mylist1</span> := 1 :: (2 :: (3 :: <span class="id" type="var">nil</span>)).<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">mylist2</span> := 1 :: 2 :: 3 :: <span class="id" type="var">nil</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">mylist3</span> := [1;2;3].<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">at</span></span> <span class="inlinecode"><span class="id" type="var">level</span></span> <span class="inlinecode">60</span> 告诉 Coq 当遇到表达式和其它中缀运算符时应该如何加括号。
    例如，我们已经为 <span class="inlinecode"><span class="id" type="var">plus</span></span> 函数定义了 <span class="inlinecode">+</span> 中缀符号，它的优先级是 50：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span>&nbsp;"x + y"&nbsp;:=&nbsp;(<span class="id" type="var">plus</span>&nbsp;<span class="id" type="var">x</span>&nbsp;<span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span>&nbsp;<span class="id" type="var">level</span>&nbsp;50,&nbsp;<span class="id" type="var">left</span>&nbsp;<span class="id" type="var">associativity</span>).
<div class="paragraph"> </div>

</div>
    <span class="inlinecode">+</span> 会比 <span class="inlinecode">::</span> 结合的更紧密，所以 <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span> 会被解析成
    <span class="inlinecode">(1</span> <span class="inlinecode">+</span> <span class="inlinecode">2)</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span> 而非 <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">(2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3])</span>。

<div class="paragraph"> </div>

   (当你在 <span class="inlinecode">.<span class="id" type="var">v</span></span> 文件中看到“<span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">(2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3])</span>”这样的记法时可能会很疑惑。
   最里面那个括住了 3 的方括号，标明了它是一个列表。而外层的方括号则是用来指示
   “coqdoc”这部分要被显示为代码而非普通的文本；在生成的 HTML
   文件中，外层的方括号是看不到的。)

<div class="paragraph"> </div>

   上面的第二和第三个 <span class="inlinecode"><span class="id" type="keyword">Notation</span></span> 声明引入了标准的方括号记法来表示列表；
   第三个声明的右半部分展示了在 Coq 中声明 n 元记法的语法，
   以及将它们翻译成嵌套的二元构造子序列的方法。 
<div class="paragraph"> </div>

<a name="lab68"></a><h3 class="section">Repeat</h3>

<div class="paragraph"> </div>

 有很多函数可以方便地操作列表。例如 <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> 函数接受一个数字
    <span class="inlinecode"><span class="id" type="var">n</span></span> 和一个 <span class="inlinecode"><span class="id" type="var">count</span></span>，返回一个长度为 <span class="inlinecode"><span class="id" type="var">count</span></span>，每个元素都是 <span class="inlinecode"><span class="id" type="var">n</span></span> 的列表。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="tactic">repeat</span> (<span class="id" type="var">n</span> <span class="id" type="var">count</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">count</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">count'</span> ⇒ <span class="id" type="var">n</span> :: (<span class="id" type="tactic">repeat</span> <span class="id" type="var">n</span> <span class="id" type="var">count'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab69"></a><h3 class="section">Length</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">length</span></span> 函数用来计算列表的长度。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">length</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> ⇒ <span class="id" type="var">S</span> (<span class="id" type="var">length</span> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab70"></a><h3 class="section">Append</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">app</span></span> 函数用来把两个列表联接起来。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">app</span> (<span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <span class="id" type="var">natlist</span>) : <span class="id" type="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span>    ⇒ <span class="id" type="var">l<sub>2</sub></span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> ⇒ <span class="id" type="var">h</span> :: (<span class="id" type="var">app</span> <span class="id" type="var">t</span> <span class="id" type="var">l<sub>2</sub></span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
鉴于下文中 <span class="inlinecode"><span class="id" type="var">app</span></span> 随处可见，不妨将其定义为中缀运算符。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Notation</span> "x ++ y" := (<span class="id" type="var">app</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">right</span> <span class="id" type="var">associativity</span>, <span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 60).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_app1</span>:             [1;2;3] ++ [4;5] = [1;2;3;4;5].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_app2</span>:             <span class="id" type="var">nil</span> ++ [4;5] = [4;5].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_app3</span>:             [1;2;3] ++ <span class="id" type="var">nil</span> = [1;2;3].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab71"></a><h3 class="section">Head（带默认值）与 Tail</h3>

<div class="paragraph"> </div>

 下面介绍列表上的两种运算：<span class="inlinecode"><span class="id" type="var">hd</span></span> 函数返回列表的第一个元素（即“表头”）；
    <span class="inlinecode"><span class="id" type="var">tl</span></span> 函数返回列表除去第一个元素以外的部分（即“表尾”）。考虑到空表没有表头，
    传入一个参数作为返回的默认值。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">hd</span> (<span class="id" type="var">default</span>:<span class="id" type="var">nat</span>) (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> ⇒ <span class="id" type="var">default</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> ⇒ <span class="id" type="var">h</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">tl</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) : <span class="id" type="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> ⇒ <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> ⇒ <span class="id" type="var">t</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_hd<sub>1</sub></span>:             <span class="id" type="var">hd</span> 0 [1;2;3] = 1.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_hd<sub>2</sub></span>:             <span class="id" type="var">hd</span> 0 [] = 0.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_tl</span>:              <span class="id" type="var">tl</span> [1;2;3] = [2;3].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab72"></a><h3 class="section">练习</h3>

<div class="paragraph"> </div>

<a name="lab73"></a><h4 class="section">练习：2 星, standard, recommended (list_funs)</h4>
 完成以下 <span class="inlinecode"><span class="id" type="var">nonzeros</span></span>、<span class="inlinecode"><span class="id" type="var">oddmembers</span></span> 和 <span class="inlinecode"><span class="id" type="var">countoddmembers</span></span> 的定义，
    你可以查看测试函数来理解这些函数应该做什么。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">nonzeros</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) : <span class="id" type="var">natlist</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nonzeros</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">nonzeros</span> [0;1;0;2;3;0;0] = [1;2;3].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">oddmembers</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) : <span class="id" type="var">natlist</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_oddmembers</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">oddmembers</span> [0;1;0;2;3;0;0] = [1;3].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">countoddmembers</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_countoddmembers1</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">countoddmembers</span> [1;0;3;1;4;5] = 4.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_countoddmembers2</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">countoddmembers</span> [0;2;4] = 0.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_countoddmembers3</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">countoddmembers</span> <span class="id" type="var">nil</span> = 0.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab74"></a><h4 class="section">练习：3 星, advanced (alternate)</h4>
 完成 <span class="inlinecode"><span class="id" type="var">alternate</span></span> 的定义，它从两个列表中交替地取出元素并合并为一个列表，
    就像把拉链“拉”起来一样。更多具体示例见后面的测试。

<div class="paragraph"> </div>

    （注意：<span class="inlinecode"><span class="id" type="var">alternate</span></span> 有一种自然而优雅的定义，但是这一定义无法满足 Coq
    对于 <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> 必须“显然会终止”的要求。如果你发现你被这种解法束缚住了，
    可以试着换一种稍微啰嗦一点的解法，比如同时对两个列表中的元素进行操作。
    有种可行的解法需要定义新的序对，但这并不是唯一的方法。） 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">alternate</span> (<span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <span class="id" type="var">natlist</span>) : <span class="id" type="var">natlist</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_alternate1</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">alternate</span> [1;2;3] [4;5;6] = [1;4;2;5;3;6].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_alternate2</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">alternate</span> [1] [4;5;6] = [1;4;5;6].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_alternate3</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">alternate</span> [1;2;3] [4] = [1;4;2;3].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_alternate4</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">alternate</span> [] [20;30] = [20;30].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab75"></a><h2 class="section">用列表实现口袋（Bag）</h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">bag</span></span>（或者叫 <span class="inlinecode"><span class="id" type="var">multiset</span></span> 多重集）类似于集合，只是其中每个元素都能出现不止一次。
   口袋的一种可行的表示是列表。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">bag</span> := <span class="id" type="var">natlist</span>.<br/>
</div>

<div class="doc">
<a name="lab76"></a><h4 class="section">练习：3 星, standard, recommended (bag_functions)</h4>
 为袋子完成以下 <span class="inlinecode"><span class="id" type="var">count</span></span>、<span class="inlinecode"><span class="id" type="var">sum</span></span>、<span class="inlinecode"><span class="id" type="var">add</span></span>、和 <span class="inlinecode"><span class="id" type="var">member</span></span> 函数的定义。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">count</span> (<span class="id" type="var">v</span>:<span class="id" type="var">nat</span>) (<span class="id" type="var">s</span>:<span class="id" type="var">bag</span>) : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
这些命题都能通过 <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 来证明。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Example</span> <span class="id" type="var">test_count1</span>:              <span class="id" type="var">count</span> 1 [1;2;3;1;4;1] = 3.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_count2</span>:              <span class="id" type="var">count</span> 6 [1;2;3;1;4;1] = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
Multiset <span class="inlinecode"><span class="id" type="var">sum</span></span> is similar to set <span class="inlinecode"><span class="id" type="var">union</span></span>: <span class="inlinecode"><span class="id" type="var">sum</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode"><span class="id" type="var">b</span></span> contains all
    the elements of <span class="inlinecode"><span class="id" type="var">a</span></span> and of <span class="inlinecode"><span class="id" type="var">b</span></span>.  (Mathematicians usually define
    <span class="inlinecode"><span class="id" type="var">union</span></span> on multisets a little bit differently &mdash; using max instead
    of sum &mdash; which is why we don't use that name for this operation.)
    For <span class="inlinecode"><span class="id" type="var">sum</span></span> we're giving you a header that does not give explicit
    names to the arguments.  Moreover, it uses the keyword
    <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> instead of <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>, so even if you had names for
    the arguments, you wouldn't be able to process them recursively.
    The point of stating the question this way is to encourage you to
    think about whether <span class="inlinecode"><span class="id" type="var">sum</span></span> can be implemented in another way &mdash;
    perhaps by using functions that have already been defined.  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">sum</span> : <span class="id" type="var">bag</span> → <span class="id" type="var">bag</span> → <span class="id" type="var">bag</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_sum1</span>:              <span class="id" type="var">count</span> 1 (<span class="id" type="var">sum</span> [1;2;3] [1;4;1]) = 3.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">add</span> (<span class="id" type="var">v</span>:<span class="id" type="var">nat</span>) (<span class="id" type="var">s</span>:<span class="id" type="var">bag</span>) : <span class="id" type="var">bag</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_add1</span>:                <span class="id" type="var">count</span> 1 (<span class="id" type="var">add</span> 1 [1;4;1]) = 3.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_add2</span>:                <span class="id" type="var">count</span> 5 (<span class="id" type="var">add</span> 1 [1;4;1]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">member</span> (<span class="id" type="var">v</span>:<span class="id" type="var">nat</span>) (<span class="id" type="var">s</span>:<span class="id" type="var">bag</span>) : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_member1</span>:             <span class="id" type="var">member</span> 1 [1;4;1] = <span class="id" type="var">true</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_member2</span>:             <span class="id" type="var">member</span> 2 [1;4;1] = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab77"></a><h4 class="section">练习：3 星, standard, optional (bag_more_functions)</h4>
 你可以把下面这些和 <span class="inlinecode"><span class="id" type="var">bag</span></span> 有关的函数当作额外的练习 
<div class="paragraph"> </div>

 倘若某口袋不包含所要移除的数字，那么将 <span class="inlinecode"><span class="id" type="var">remove_one</span></span> 作用其上不应改变其内容。
    （本练习为选做，但高级班的学生为了完成后面的练习，需要写出 <span class="inlinecode"><span class="id" type="var">remove_one</span></span>
    的定义。） 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">remove_one</span> (<span class="id" type="var">v</span>:<span class="id" type="var">nat</span>) (<span class="id" type="var">s</span>:<span class="id" type="var">bag</span>) : <span class="id" type="var">bag</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_remove_one1</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">count</span> 5 (<span class="id" type="var">remove_one</span> 5 [2;1;5;4;1]) = 0.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_remove_one2</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">count</span> 5 (<span class="id" type="var">remove_one</span> 5 [2;1;4;1]) = 0.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_remove_one3</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">count</span> 4 (<span class="id" type="var">remove_one</span> 5 [2;1;4;5;1;4]) = 2.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_remove_one4</span>:<br/>
&nbsp;&nbsp;<span class="id" type="var">count</span> 5 (<span class="id" type="var">remove_one</span> 5 [2;1;5;4;5;1;4]) = 1.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">remove_all</span> (<span class="id" type="var">v</span>:<span class="id" type="var">nat</span>) (<span class="id" type="var">s</span>:<span class="id" type="var">bag</span>) : <span class="id" type="var">bag</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_remove_all1</span>:  <span class="id" type="var">count</span> 5 (<span class="id" type="var">remove_all</span> 5 [2;1;5;4;1]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_remove_all2</span>:  <span class="id" type="var">count</span> 5 (<span class="id" type="var">remove_all</span> 5 [2;1;4;1]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_remove_all3</span>:  <span class="id" type="var">count</span> 4 (<span class="id" type="var">remove_all</span> 5 [2;1;4;5;1;4]) = 2.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_remove_all4</span>:  <span class="id" type="var">count</span> 5 (<span class="id" type="var">remove_all</span> 5 [2;1;5;4;5;1;4;5;1;4]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">subset</span> (<span class="id" type="var">s<sub>1</sub></span>:<span class="id" type="var">bag</span>) (<span class="id" type="var">s<sub>2</sub></span>:<span class="id" type="var">bag</span>) : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_subset1</span>:              <span class="id" type="var">subset</span> [1;2] [2;1;4;1] = <span class="id" type="var">true</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_subset2</span>:              <span class="id" type="var">subset</span> [1;2;2] [2;1;4;1] = <span class="id" type="var">false</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab78"></a><h4 class="section">练习：2 星, standard, recommended (bag_theorem)</h4>
 写一个你认为有趣的关于袋子的定理 <span class="inlinecode"><span class="id" type="var">bag_theorem</span></span>，然后证明它；
    这个定理需要用到 <span class="inlinecode"><span class="id" type="var">count</span></span> 和 <span class="inlinecode"><span class="id" type="var">add</span></span>。注意，这是个开放性问题。
    也许你写下的定理是正确的，但它可能会涉及到你尚未学过的技巧因而无法证明。
    如果你遇到麻烦了，欢迎提问！ 
</div>
<div class="code code-tight">

<span class="comment">(*<br/>
Theorem&nbsp;bag_theorem&nbsp;:&nbsp;...<br/>
Proof.<br/>
&nbsp;&nbsp;...<br/>
Qed.<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">manual_grade_for_bag_theorem</span> : <span class="id" type="var">option</span> (<span class="id" type="var">nat</span>*<span class="id" type="var">string</span>) := <span class="id" type="var">None</span>.<br/>
<span class="comment">(*&nbsp;Note&nbsp;to&nbsp;instructors:&nbsp;For&nbsp;silly&nbsp;technical&nbsp;reasons,&nbsp;in&nbsp;this<br/>
&nbsp;&nbsp;&nbsp;file&nbsp;(only)&nbsp;you&nbsp;will&nbsp;need&nbsp;to&nbsp;write&nbsp;<span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode">(<span class="id" type="var">Datatypes.pair</span></span> <span class="inlinecode">3</span> <span class="inlinecode">""%<span class="id" type="var">string</span>)</span><br/>
&nbsp;&nbsp;&nbsp;rather&nbsp;than&nbsp;<span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode">(3,""%<span class="id" type="var">string</span>)</span>&nbsp;to&nbsp;enter&nbsp;your&nbsp;grade&nbsp;and&nbsp;comments.&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab79"></a><h1 class="section">有关列表的论证</h1>

<div class="paragraph"> </div>

 和数字一样，有些列表处理函数的简单事实仅通过化简就能证明。
    例如，对于下面这个例子，<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 所做的简化就已经足够了... 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">nil_app</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;[] ++ <span class="id" type="var">l</span> = <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
...由于 <span class="inlinecode">[]</span> 被替换进了 <span class="inlinecode"><span class="id" type="var">app</span></span> 定义中相应的“被检”分支
    （即经由匹配“仔细检查”过值的表达式），整个匹配得以被简化。 
<div class="paragraph"> </div>

 和数字一样，有时对一个列表做分类讨论（是否是空）是非常有用的。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">tl_length_pred</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">pred</span> (<span class="id" type="var">length</span> <span class="id" type="var">l</span>) = <span class="id" type="var">length</span> (<span class="id" type="var">tl</span> <span class="id" type="var">l</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;cons&nbsp;n&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
在这里 <span class="inlinecode"><span class="id" type="var">nil</span></span> 的情况能够工作是因为我们定义了 <span class="inlinecode"><span class="id" type="var">tl</span></span> <span class="inlinecode"><span class="id" type="var">nil</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">nil</span></span>，
    而 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 策略中 <span class="inlinecode"><span class="id" type="keyword">as</span></span> 注解引入的两个名字，<span class="inlinecode"><span class="id" type="var">n</span></span> 和 <span class="inlinecode"><span class="id" type="var">l'</span></span>，分别对应了
    <span class="inlinecode"><span class="id" type="var">cons</span></span> 构造子的两个参数（正在构造的列表的头和尾）。 
<div class="paragraph"> </div>

 然而一般来说，许多关于列表的有趣定理都需要用到归纳法来证明。 
</div>

<div class="doc">
<a name="lab80"></a><h2 class="section">一点点说教</h2>

<div class="paragraph"> </div>

 只是阅读证明的话，你不会获得什么特别有用的东西。搞清楚每一个细节非常重要，
    你应该在 Coq 中单步执行这些证明并思考每一步在整个证明中的作用，否则练习题将毫无用处。
    啰嗦完毕。 
</div>

<div class="doc">
<a name="lab81"></a><h2 class="section">对列表进行归纳</h2>

<div class="paragraph"> </div>

 比起对自然数的归纳，读者可能对归纳证明 <span class="inlinecode"><span class="id" type="var">natlist</span></span> 这样的数据类型更加陌生。
    不过基本思路同样简单。每个 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 声明定义了一组数据值，
    这些值可以用声明过的构造子来构造：布尔值可以用 <span class="inlinecode"><span class="id" type="var">true</span></span> 或 <span class="inlinecode"><span class="id" type="var">false</span></span> 来构造；
    自然数可以用 <span class="inlinecode"><span class="id" type="var">O</span></span> 或 <span class="inlinecode"><span class="id" type="var">S</span></span> 应用到另一个自然数上来构造；而列表可以用 <span class="inlinecode"><span class="id" type="var">nil</span></span>
    或者将 <span class="inlinecode"><span class="id" type="var">cons</span></span> 应用到一个自然数和另一个列表上来构造。

<div class="paragraph"> </div>

    除此以外，归纳定义的集合中元素的形式 <b>只能是</b> 构造子对其它项的应用；
    这一事实同时也给出了一种对归纳定义的集合进行论证的方法：一个自然数要么是
    <span class="inlinecode"><span class="id" type="var">O</span></span>，要么就是 <span class="inlinecode"><span class="id" type="var">S</span></span> 应用到某个<b>更小</b>的自然数上；一个列表要么是 <span class="inlinecode"><span class="id" type="var">nil</span></span>，
    要么就是 <span class="inlinecode"><span class="id" type="var">cons</span></span> 应用到某个数字和某个<b>更小</b>的列表上，诸如此类。
    所以，如果我们有某个命题 <span class="inlinecode"><span class="id" type="var">P</span></span> 涉及列表 <span class="inlinecode"><span class="id" type="var">l</span></span>，而我们想证明 <span class="inlinecode"><span class="id" type="var">P</span></span> 对 <b>一切</b>
    列表都成立，那么可以像这样推理：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 首先，证明当 <span class="inlinecode"><span class="id" type="var">l</span></span> 为 <span class="inlinecode"><span class="id" type="var">nil</span></span> 时 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> 成立。

<div class="paragraph"> </div>


</li>
<li> 然后，证明当 <span class="inlinecode"><span class="id" type="var">l</span></span> 为 <span class="inlinecode"><span class="id" type="var">cons</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">l'</span></span> 时 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> 成立，其中 <span class="inlinecode"><span class="id" type="var">n</span></span> 是某个自然数，<span class="inlinecode"><span class="id" type="var">l'</span></span>
      是某个更小的列表，假设 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">l'</span></span> 成立.

</li>
</ul>
    由于较大的列表只能通过较小的列表构造出来，最终这个较小的列表会变成
    <span class="inlinecode"><span class="id" type="var">nil</span></span>，这两点合在一起就完成了 <span class="inlinecode"><span class="id" type="var">P</span></span> 对一切列表 <span class="inlinecode"><span class="id" type="var">l</span></span> 成立的证明。下面是个具体的例子： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">app_assoc</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> <span class="id" type="var">l<sub>3</sub></span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">l<sub>1</sub></span> ++ <span class="id" type="var">l<sub>2</sub></span>) ++ <span class="id" type="var">l<sub>3</sub></span> = <span class="id" type="var">l<sub>1</sub></span> ++ (<span class="id" type="var">l<sub>2</sub></span> ++ <span class="id" type="var">l<sub>3</sub></span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> <span class="id" type="var">l<sub>3</sub></span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l<sub>1</sub>'</span> <span class="id" type="var">IHl1'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l<sub>1</sub>&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l<sub>1</sub>&nbsp;=&nbsp;cons&nbsp;n&nbsp;l<sub>1</sub>'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> → <span class="id" type="var">IHl1'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
注意，和归纳自然数时一样，此处 <span class="inlinecode"><span class="id" type="tactic">induction</span></span> 策略的 <span class="inlinecode"><span class="id" type="keyword">as</span>...</span> 从句为在
    “<span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 由构造子 <span class="inlinecode"><span class="id" type="var">cons</span></span> 构造而来”这一情况时出现的“更小的列表”和归纳假设取了名字。
    再次强调，如果你把 Coq 的证明当做静态的文档，那么可能不会有特别多的收获 ——
    如果你通过交互式的 Coq 会话来阅读证明，就能看到当前的目标和上下文，
    而这些状态在你阅读写下来的脚本时是不可见的。所以一份用自然语言写成的证明 ——
    写给人看的 —— 需要包含更多的提示来帮助读者理解当前的状态，
    比如第二种情况下的归纳假设到底是什么。 
<div class="paragraph"> </div>

 <b>定理</b>：对所有的列表 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>, <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>, 和 <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span>，
   <span class="inlinecode">(<span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode">(<span class="id" type="var">l<sub>2</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span>)</span>。

<div class="paragraph"> </div>

   <b>证明</b>: 通过对 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 使用归纳法。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 首先, 假设 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>。我们必须证明：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;([]&nbsp;++&nbsp;<span class="id" type="var">l<sub>2</sub></span>)&nbsp;++&nbsp;<span class="id" type="var">l<sub>3</sub></span>&nbsp;=&nbsp;[]&nbsp;++&nbsp;(<span class="id" type="var">l<sub>2</sub></span>&nbsp;++&nbsp;<span class="id" type="var">l<sub>3</sub></span>),
<div class="paragraph"> </div>

</div>
     这可以通过展开 <span class="inlinecode">++</span> 的定义得到。

<div class="paragraph"> </div>


</li>
<li> 然后, 假设 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span>::<span class="id" type="var">l<sub>1</sub>'</span></span>，有：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;(<span class="id" type="var">l<sub>1</sub>'</span>&nbsp;++&nbsp;<span class="id" type="var">l<sub>2</sub></span>)&nbsp;++&nbsp;<span class="id" type="var">l<sub>3</sub></span>&nbsp;=&nbsp;<span class="id" type="var">l<sub>1</sub>'</span>&nbsp;++&nbsp;(<span class="id" type="var">l<sub>2</sub></span>&nbsp;++&nbsp;<span class="id" type="var">l<sub>3</sub></span>)
<div class="paragraph"> </div>

</div>
     （归纳假设）。我们必须证明：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;((<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l<sub>1</sub>'</span>)&nbsp;++&nbsp;<span class="id" type="var">l<sub>2</sub></span>)&nbsp;++&nbsp;<span class="id" type="var">l<sub>3</sub></span>&nbsp;=&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l<sub>1</sub>'</span>)&nbsp;++&nbsp;(<span class="id" type="var">l<sub>2</sub></span>&nbsp;++&nbsp;<span class="id" type="var">l<sub>3</sub></span>).
<div class="paragraph"> </div>

</div>
     根据 <span class="inlinecode">++</span> 的定义, 上式等价于：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">n</span>&nbsp;::&nbsp;((<span class="id" type="var">l<sub>1</sub>'</span>&nbsp;++&nbsp;<span class="id" type="var">l<sub>2</sub></span>)&nbsp;++&nbsp;<span class="id" type="var">l<sub>3</sub></span>)&nbsp;=&nbsp;<span class="id" type="var">n</span>&nbsp;::&nbsp;(<span class="id" type="var">l<sub>1</sub>'</span>&nbsp;++&nbsp;(<span class="id" type="var">l<sub>2</sub></span>&nbsp;++&nbsp;<span class="id" type="var">l<sub>3</sub></span>)),
<div class="paragraph"> </div>

</div>
     该式可通过我们的归纳假设立即证得。  <span class="proofbox">&#9744;</span> 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab82"></a><h3 class="section">反转列表</h3>

<div class="paragraph"> </div>

 举一个更加深入的例子来说明对列表的归纳证明：假设我们使用 <span class="inlinecode"><span class="id" type="var">app</span></span>
    来定义一个列表反转函数 <span class="inlinecode"><span class="id" type="var">rev</span></span>： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">rev</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) : <span class="id" type="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span>    ⇒ <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> ⇒ <span class="id" type="var">rev</span> <span class="id" type="var">t</span> ++ [<span class="id" type="var">h</span>]<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_rev1</span>:            <span class="id" type="var">rev</span> [1;2;3] = [3;2;1].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_rev2</span>:            <span class="id" type="var">rev</span> <span class="id" type="var">nil</span> = <span class="id" type="var">nil</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab83"></a><h3 class="section"><span class="inlinecode"><span class="id" type="var">rev</span></span> 的性质</h3>

<div class="paragraph"> </div>

 Now, for something a bit more challenging than the proofs
    we've seen so far, let's prove that reversing a list does not
    change its length.  Our first attempt gets stuck in the successor
    case... 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">rev_length_firsttry</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l</span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">length</span> (<span class="id" type="var">rev</span> <span class="id" type="var">l</span>) = <span class="id" type="var">length</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l'</span> <span class="id" type="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;n&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;这种情况比较棘手。我们从一般的化简开始。&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;现在我们好像卡住了：目标是要证明涉及&nbsp;<span class="inlinecode">++</span>&nbsp;的等式，<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们在上下文和全局环境下并没有任何有用的等式！<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过用&nbsp;IH&nbsp;来重写目标，我们可以推进一点...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">IHl'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...但也仅此而已。&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
不妨单独提出引理，阐述 <span class="inlinecode">++</span> 与 <span class="inlinecode"><span class="id" type="var">length</span></span> 形成的等式关系，
    以推进证明。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">app_length</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">length</span> (<span class="id" type="var">l<sub>1</sub></span> ++ <span class="id" type="var">l<sub>2</sub></span>) = (<span class="id" type="var">length</span> <span class="id" type="var">l<sub>1</sub></span>) + (<span class="id" type="var">length</span> <span class="id" type="var">l<sub>2</sub></span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l<sub>1</sub>'</span> <span class="id" type="var">IHl1'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l<sub>1</sub>&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l<sub>1</sub>&nbsp;=&nbsp;cons&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> → <span class="id" type="var">IHl1'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
注意，为了让该引理尽可能 <b>通用</b>，我们不仅关心由 <span class="inlinecode"><span class="id" type="var">rev</span></span> 得到的列表，
    还要对 <b>所有</b> 的 <span class="inlinecode"><span class="id" type="var">natlist</span></span> 进行全称量化。这很自然，因为这个证明目标
    显然不依赖于被反转的列表。除此之外，证明这个更普遍的性质也更容易些。 
<div class="paragraph"> </div>

 现在我们可以完成最初的证明了。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">rev_length</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l</span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">length</span> (<span class="id" type="var">rev</span> <span class="id" type="var">l</span>) = <span class="id" type="var">length</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l'</span> <span class="id" type="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;cons&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> → <span class="id" type="var">app_length</span>, <span class="id" type="var">plus_comm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> → <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
作为对比，以下是这两个定理的非形式化证明：

<div class="paragraph"> </div>

    <b>定理</b>：对于所有的列表 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>，
       <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode">(<span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>.

<div class="paragraph"> </div>

    <b>证明</b>：对 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 进行归纳。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 首先，假设 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>。我们必须证明

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;([]&nbsp;++&nbsp;<span class="id" type="var">l<sub>2</sub></span>)&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;[]&nbsp;+&nbsp;<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l<sub>2</sub></span>,
<div class="paragraph"> </div>

</div>
      根据 <span class="inlinecode"><span class="id" type="var">length</span></span> 和 <span class="inlinecode">++</span> 的定义，上式显然可得。

<div class="paragraph"> </div>


</li>
<li> 其次，假设 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span>::<span class="id" type="var">l<sub>1</sub>'</span></span>，并且

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">l<sub>1</sub>'</span>&nbsp;++&nbsp;<span class="id" type="var">l<sub>2</sub></span>)&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l<sub>1</sub>'</span>&nbsp;+&nbsp;<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l<sub>2</sub></span>.
<div class="paragraph"> </div>

</div>
      我们必须证明

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;((<span class="id" type="var">n</span>::<span class="id" type="var">l<sub>1</sub>'</span>)&nbsp;++&nbsp;<span class="id" type="var">l<sub>2</sub></span>)&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">n</span>::<span class="id" type="var">l<sub>1</sub>'</span>)&nbsp;+&nbsp;<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l<sub>2</sub></span>).
<div class="paragraph"> </div>

</div>
      根据 <span class="inlinecode"><span class="id" type="var">length</span></span> 和 <span class="inlinecode">++</span> 的定义以及归纳假设，上式显然可得。 <span class="proofbox">&#9744;</span> 
</li>
</ul>

<div class="paragraph"> </div>

 <b>定理</b>: 对于所有的列表 <span class="inlinecode"><span class="id" type="var">l</span></span>，<span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode">(<span class="id" type="var">rev</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>。

<div class="paragraph"> </div>

    <b>证明</b>: 对 <span class="inlinecode"><span class="id" type="var">l</span></span> 进行归纳。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 首先，假设 <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>。我们必须证明

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;[])&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;[],
<div class="paragraph"> </div>

</div>
        根据 <span class="inlinecode"><span class="id" type="var">length</span></span> 和 <span class="inlinecode"><span class="id" type="var">rev</span></span> 的定义，上式显然可得。

<div class="paragraph"> </div>


</li>
<li> 其次，假设 <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span>::<span class="id" type="var">l'</span></span>，并且

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l'</span>)&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>.
<div class="paragraph"> </div>

</div>
        我们必须证明

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l'</span>))&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l'</span>).
<div class="paragraph"> </div>

</div>
        根据 <span class="inlinecode"><span class="id" type="var">rev</span></span> 的定义，上式来自于

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;((<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l'</span>)&nbsp;++&nbsp;[<span class="id" type="var">n</span>])&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>)
<div class="paragraph"> </div>

</div>
        根据之前的引理，此式等同于

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l'</span>)&nbsp;+&nbsp;<span class="id" type="var">length</span>&nbsp;[<span class="id" type="var">n</span>]&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>).
<div class="paragraph"> </div>

</div>
        根据归纳假设和 <span class="inlinecode"><span class="id" type="var">length</span></span> 的定义，上式显然可得。 <span class="proofbox">&#9744;</span> 
</li>
</ul>

<div class="paragraph"> </div>

 这些证明的风格实在是冗长而迂腐。几次练习之后，我们会发现减少细枝末节，
    详述不太显然的步骤更有助于我们理解证明。毕竟细节更容易在大脑中思考，
    必要时我们还可以在草稿纸上补全。下面我们以一种更加紧凑的方式呈现之前的证明： 
<div class="paragraph"> </div>

 <b>定理</b>：
     对于所有 <span class="inlinecode"><span class="id" type="var">l</span></span>，<span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode">(<span class="id" type="var">rev</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>。

<div class="paragraph"> </div>

    <b>证明</b>：首先，观察到 <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode">(<span class="id" type="var">l</span></span> <span class="inlinecode">++</span> <span class="inlinecode">[<span class="id" type="var">n</span>])</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span> 对一切 <span class="inlinecode"><span class="id" type="var">l</span></span> 成立
    （通过对 <span class="inlinecode"><span class="id" type="var">l</span></span> 的归纳直接可得）。当 <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n'</span>::<span class="id" type="var">l'</span></span> 时，通过再次对 <span class="inlinecode"><span class="id" type="var">l</span></span> 使用归纳，
    然后同时使用之前观察得到的性质和归纳假设即可证明。 <span class="proofbox">&#9744;</span> 
<div class="paragraph"> </div>

 一般而言，在不同的情况下合适的风格也会不同：读者对这个问题了解程度，
    以及当前的证明与读者熟悉的证明之间的相似度都会影响到这一点。
    对于我们现在的目的而言，最好先用更加冗长的方式。 
</div>

<div class="doc">
<a name="lab84"></a><h2 class="section"><span class="inlinecode"><span class="id" type="var">Search</span></span> 搜索</h2>

<div class="paragraph"> </div>

 我们已经见过很多需要使用之前证明过的结论（例如通过 <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>）来证明的定理了。
    但是在引用别的定理时，我们必须事先知道它们的名字。当然，即使是已被证明的定理本身
    我们都不能全部记住，更不用提它们的名字了。

<div class="paragraph"> </div>

    Coq 的 <span class="inlinecode"><span class="id" type="var">Search</span></span> 指令在这时就非常有用了。执行 <span class="inlinecode"><span class="id" type="var">Search</span></span> <span class="inlinecode"><span class="id" type="var">foo</span></span> 会让 Coq
    显示所有涉及到 <span class="inlinecode"><span class="id" type="var">foo</span></span> 的定理。例如，去掉下面的注释后，
    你会看到一个我们证明过的所有关于 <span class="inlinecode"><span class="id" type="var">rev</span></span> 的定理的列表： 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;&nbsp;Search&nbsp;rev.&nbsp;*)</span><br/>
</div>

<div class="doc">
在接下来的学习中，你要记得使用 <span class="inlinecode"><span class="id" type="var">Search</span></span>，它能为你节约大量的时间！

<div class="paragraph"> </div>

    如果你正在使用 ProofGeneral，那么可以用 <span class="inlinecode"><span class="id" type="var">C</span>-<span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">C</span>-<span class="id" type="var">a</span></span> <span class="inlinecode"><span class="id" type="var">C</span>-<span class="id" type="var">a</span></span> 来运行 <span class="inlinecode"><span class="id" type="var">Search</span></span>。
    通过 <span class="inlinecode"><span class="id" type="var">C</span>-<span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">C</span>-;</span> 可以将它返回的结果粘贴到缓冲区内。 
</div>

<div class="doc">
<a name="lab85"></a><h2 class="section">列表练习，第一部分</h2>

<div class="paragraph"> </div>

<a name="lab86"></a><h4 class="section">练习：3 星, standard (list_exercises)</h4>
 更多有关列表的实践： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">app_nil_r</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l</span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">l</span> ++ [] = <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">rev_app_distr</span>: <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">rev</span> (<span class="id" type="var">l<sub>1</sub></span> ++ <span class="id" type="var">l<sub>2</sub></span>) = <span class="id" type="var">rev</span> <span class="id" type="var">l<sub>2</sub></span> ++ <span class="id" type="var">rev</span> <span class="id" type="var">l<sub>1</sub></span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">rev_involutive</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l</span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">rev</span> (<span class="id" type="var">rev</span> <span class="id" type="var">l</span>) = <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
下面的练习有简短的解法，如果你开始发现情况已经复杂到你无法理清的程度，
    请后退一步并试着寻找更为简单的方法。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">app_assoc4</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> <span class="id" type="var">l<sub>3</sub></span> <span class="id" type="var">l<sub>4</sub></span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">l<sub>1</sub></span> ++ (<span class="id" type="var">l<sub>2</sub></span> ++ (<span class="id" type="var">l<sub>3</sub></span> ++ <span class="id" type="var">l<sub>4</sub></span>)) = ((<span class="id" type="var">l<sub>1</sub></span> ++ <span class="id" type="var">l<sub>2</sub></span>) ++ <span class="id" type="var">l<sub>3</sub></span>) ++ <span class="id" type="var">l<sub>4</sub></span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
一个关于你对 <span class="inlinecode"><span class="id" type="var">nonzeros</span></span> 的实现的练习： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">nonzeros_app</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">nonzeros</span> (<span class="id" type="var">l<sub>1</sub></span> ++ <span class="id" type="var">l<sub>2</sub></span>) = (<span class="id" type="var">nonzeros</span> <span class="id" type="var">l<sub>1</sub></span>) ++ (<span class="id" type="var">nonzeros</span> <span class="id" type="var">l<sub>2</sub></span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab87"></a><h4 class="section">练习：2 星, standard (eqblist)</h4>
 填写 <span class="inlinecode"><span class="id" type="var">eqblist</span></span> 的定义，它通过比较列表中的数字来判断是否相等。
    证明对于所有列表 <span class="inlinecode"><span class="id" type="var">l</span></span>，<span class="inlinecode"><span class="id" type="var">eqblist</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> 返回 <span class="inlinecode"><span class="id" type="var">true</span></span>。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">eqblist</span> (<span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <span class="id" type="var">natlist</span>) : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_eqblist1</span> :<br/>
&nbsp;&nbsp;(<span class="id" type="var">eqblist</span> <span class="id" type="var">nil</span> <span class="id" type="var">nil</span> = <span class="id" type="var">true</span>).<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_eqblist2</span> :<br/>
&nbsp;&nbsp;<span class="id" type="var">eqblist</span> [1;2;3] [1;2;3] = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_eqblist3</span> :<br/>
&nbsp;&nbsp;<span class="id" type="var">eqblist</span> [1;2;3] [1;2;4] = <span class="id" type="var">false</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">eqblist_refl</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">true</span> = <span class="id" type="var">eqblist</span> <span class="id" type="var">l</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab88"></a><h2 class="section">列表练习, 第二部分</h2>

<div class="paragraph"> </div>

 下面这组简单的定理用于证明你之前关于袋子的定义。 
<div class="paragraph"> </div>

<a name="lab89"></a><h4 class="section">练习：1 星, standard (count_member_nonzero)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">count_member_nonzero</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">s</span> : <span class="id" type="var">bag</span>),<br/>
&nbsp;&nbsp;1 &lt;=? (<span class="id" type="var">count</span> 1 (1 :: <span class="id" type="var">s</span>)) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 下面这条关于 <span class="inlinecode"><span class="id" type="var">leb</span></span> 的引理可助你完成下一个证明。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">leb_n_Sn</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> &lt;=? (<span class="id" type="var">S</span> <span class="id" type="var">n</span>) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">IHn'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;S&nbsp;n'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Before doing the next exercise, make sure you've filled in the
   definition of <span class="inlinecode"><span class="id" type="var">remove_one</span></span> above. <a name="lab90"></a><h4 class="section">练习：3 星, advanced (remove_does_not_increase_count)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">remove_does_not_increase_count</span>: <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">s</span> : <span class="id" type="var">bag</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">count</span> 0 (<span class="id" type="var">remove_one</span> 0 <span class="id" type="var">s</span>)) &lt;=? (<span class="id" type="var">count</span> 0 <span class="id" type="var">s</span>) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab91"></a><h4 class="section">练习：3 星, standard, optional (bag_count_sum)</h4>
 写下一个用到函数 <span class="inlinecode"><span class="id" type="var">count</span></span> 和 <span class="inlinecode"><span class="id" type="var">sum</span></span> 的，关于袋子的有趣定理 <span class="inlinecode"><span class="id" type="var">bag_count_sum</span></span>，
    然后证明它。（你可能会发现该证明的难度取决于你如何定义 <span class="inlinecode"><span class="id" type="var">count</span></span>！） 
</div>
<div class="code code-tight">
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab92"></a><h4 class="section">练习：4 星, advanced (rev_injective)</h4>
 求证 <span class="inlinecode"><span class="id" type="var">rev</span></span> 是单射函数，即：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">l<sub>1</sub></span>&nbsp;<span class="id" type="var">l<sub>2</sub></span>&nbsp;:&nbsp;<span class="id" type="var">natlist</span>),&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l<sub>1</sub></span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l<sub>2</sub></span>&nbsp;→&nbsp;<span class="id" type="var">l<sub>1</sub></span>&nbsp;=&nbsp;<span class="id" type="var">l<sub>2</sub></span>.
<div class="paragraph"> </div>

</div>
    （这个问题既可以用简单的方式解决也可以用繁琐的方式来解决。） 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">manual_grade_for_rev_injective</span> : <span class="id" type="var">option</span> (<span class="id" type="var">nat</span>*<span class="id" type="var">string</span>) := <span class="id" type="var">None</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab93"></a><h1 class="section">Options 可选类型</h1>

<div class="paragraph"> </div>

 假设我们想要写一个返回某个列表中第 <span class="inlinecode"><span class="id" type="var">n</span></span> 个元素的函数。如果我们为它赋予类型
    <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">natlist</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>，那么当列表太短时我们仍须返回某个数... 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">nth_bad</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> ⇒ 42  <span class="comment">(*&nbsp;任意值！&nbsp;*)</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">a</span> :: <span class="id" type="var">l'</span> ⇒ <span class="id" type="keyword">match</span> <span class="id" type="var">n</span> =? <span class="id" type="var">O</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">nth_bad</span> <span class="id" type="var">l'</span> (<span class="id" type="var">pred</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
这种方案并不好：如果 <span class="inlinecode"><span class="id" type="var">nth_bad</span></span> 返回了 <span class="inlinecode">42</span>，那么不经过进一步处理的话，
    我们无法得知该值是否真的出现在了输入中。（译注：我们无法判断是什么因素让它返回了
    <span class="inlinecode">42</span>，因为它可能是列表过短时的返回值，同时也可能是（此时列表足够长）在列表中找到的值）
    一种更好的方式是改变 <span class="inlinecode"><span class="id" type="var">nth_bad</span></span> 的返回类型，使其包含一个错误值作为可能的结果。
    我们将此类型命名为 <span class="inlinecode"><span class="id" type="var">natoption</span></span>。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <span class="id" type="var">natoption</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">None</span>.<br/>
</div>

<div class="doc">
然后我们可以修改前面 <span class="inlinecode"><span class="id" type="var">nth_bad</span></span> 的定义，使其在列表太短时返回 <span class="inlinecode"><span class="id" type="var">None</span></span>，
    在列表足够长且 <span class="inlinecode"><span class="id" type="var">a</span></span> 在 <span class="inlinecode"><span class="id" type="var">n</span></span> 处时返回 <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span>。我们将这个新函数称为
    <span class="inlinecode"><span class="id" type="var">nth_error</span></span> 来表明它可以产生带错误的结果。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">nth_error</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">a</span> :: <span class="id" type="var">l'</span> ⇒ <span class="id" type="keyword">match</span> <span class="id" type="var">n</span> =? <span class="id" type="var">O</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">Some</span> <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">nth_error</span> <span class="id" type="var">l'</span> (<span class="id" type="var">pred</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nth_error1</span> : <span class="id" type="var">nth_error</span> [4;5;6;7] 0 = <span class="id" type="var">Some</span> 4.<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nth_error2</span> : <span class="id" type="var">nth_error</span> [4;5;6;7] 3 = <span class="id" type="var">Some</span> 7.<br/>
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nth_error3</span> : <span class="id" type="var">nth_error</span> [4;5;6;7] 9 = <span class="id" type="var">None</span>.<br/>
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
（在 HTML 版本中隐藏了这些老套的证明。若你想看它请点击小方格。）

<div class="paragraph"> </div>

    本例也是个介绍 Coq 编程语言更多细微特性的机会，比如条件表达式... 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">nth_error'</span> (<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">a</span> :: <span class="id" type="var">l'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">n</span> =? <span class="id" type="var">O</span> <span class="id" type="keyword">then</span> <span class="id" type="var">Some</span> <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">nth_error'</span> <span class="id" type="var">l'</span> (<span class="id" type="var">pred</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Coq 的条件语句和其它语言中的一样，不过加上了一点更为一般化的特性。
    由于布尔类型不是内建的，因此 Coq 实际上支持在<b>任何</b>带有两个构造子的，
    归纳定义的类型上使用条件表达式。当断言（guard）求值为 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>
    定义中的第一个构造子时，它被认为是真的；当它被求值到第二个构造子时，
    则被认为是假的。 
<div class="paragraph"> </div>

 以下函数从 <span class="inlinecode"><span class="id" type="var">natoption</span></span> 中取出一个 <span class="inlinecode"><span class="id" type="var">nat</span></span>，在遇到 <span class="inlinecode"><span class="id" type="var">None</span></span> 时它将返回提供的默认值。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">option_elim</span> (<span class="id" type="var">d</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">o</span> : <span class="id" type="var">natoption</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">o</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">d</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab94"></a><h4 class="section">练习：2 星, standard (hd_error)</h4>
 用同样的思路修正之前的 <span class="inlinecode"><span class="id" type="var">hd</span></span> 函数，使我们无需为 <span class="inlinecode"><span class="id" type="var">nil</span></span> 的情况提供默认元素。  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">hd_error</span> (<span class="id" type="var">l</span> : <span class="id" type="var">natlist</span>) : <span class="id" type="var">natoption</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_hd_error1</span> : <span class="id" type="var">hd_error</span> [] = <span class="id" type="var">None</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_hd_error2</span> : <span class="id" type="var">hd_error</span> [1] = <span class="id" type="var">Some</span> 1.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_hd_error3</span> : <span class="id" type="var">hd_error</span> [5;6] = <span class="id" type="var">Some</span> 5.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab95"></a><h4 class="section">练习：1 星, standard, optional (option_elim_hd)</h4>
 此练习能帮助你在新的 <span class="inlinecode"><span class="id" type="var">hd_error</span></span> 和旧的 <span class="inlinecode"><span class="id" type="var">hd</span></span> 之间建立联系。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <span class="id" type="var">option_elim_hd</span> : <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">l</span>:<span class="id" type="var">natlist</span>) (<span class="id" type="var">default</span>:<span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">hd</span> <span class="id" type="var">default</span> <span class="id" type="var">l</span> = <span class="id" type="var">option_elim</span> <span class="id" type="var">default</span> (<span class="id" type="var">hd_error</span> <span class="id" type="var">l</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">

<span class="id" type="keyword">End</span> <span class="id" type="var">NatList</span>.<br/>
</div>

<div class="doc">
<a name="lab96"></a><h1 class="section">偏映射（Partial Maps）</h1>

<div class="paragraph"> </div>

 最后演示一下如何在 Coq 中定义基础的数据结构。这是一个简单的
    <b>偏映射</b> 数据类型，它类似于大多数编程语言中的映射或字典数据结构。 
<div class="paragraph"> </div>

 首先，我们定义一个新的归纳数据类型 <span class="inlinecode"><span class="id" type="var">id</span></span> 来用作偏映射的“键”。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <span class="id" type="var">id</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">Id</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>).<br/>
</div>

<div class="doc">
本质上来说，<span class="inlinecode"><span class="id" type="var">id</span></span> 只是一个数。但通过 <span class="inlinecode"><span class="id" type="var">Id</span></span> 标签封装自然数来引入新的类型，
    能让定义变得更加可读，同时我们也可以灵活地按需修改它的定义。 
<div class="paragraph"> </div>

 我们还需要一个 <span class="inlinecode"><span class="id" type="var">id</span></span> 的相等关系测试： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">eqb_id</span> (<span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span> : <span class="id" type="var">id</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">x<sub>1</sub></span>, <span class="id" type="var">x<sub>2</sub></span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Id</span> <span class="id" type="var">n<sub>1</sub></span>, <span class="id" type="var">Id</span> <span class="id" type="var">n<sub>2</sub></span> ⇒ <span class="id" type="var">n<sub>1</sub></span> =? <span class="id" type="var">n<sub>2</sub></span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab97"></a><h4 class="section">练习：1 星, standard (eqb_id_refl)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">eqb_id_refl</span> : <span style='font-size:120%;'>&forall;</span><span class="id" type="var">x</span>, <span class="id" type="var">true</span> = <span class="id" type="var">eqb_id</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 现在我们定义偏映射的类型： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <span class="id" type="var">PartialMap</span>.<br/>
<span class="id" type="keyword">Export</span> <span class="id" type="var">NatList</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">partial_map</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">empty</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">record</span> (<span class="id" type="var">i</span> : <span class="id" type="var">id</span>) (<span class="id" type="var">v</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">m</span> : <span class="id" type="var">partial_map</span>).<br/>
</div>

<div class="doc">
此声明可以读作：“有两种方式可以构造一个 <span class="inlinecode"><span class="id" type="var">partial_map</span></span>：用构造子 <span class="inlinecode"><span class="id" type="var">empty</span></span>
    表示一个空的偏映射，或通过将构造子 <span class="inlinecode"><span class="id" type="var">record</span></span> 应用到一个键、一个值和一个既有的
    <span class="inlinecode"><span class="id" type="var">partial_map</span></span> 来构造一个带“键-值”映射 的 <span class="inlinecode"><span class="id" type="var">partial_map</span></span>。”
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">update</span></span> 函数在部分映射中覆盖给定的键以取缔原值（如该键尚不存在，
    则新建其记录）。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">update</span> (<span class="id" type="var">d</span> : <span class="id" type="var">partial_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">x</span> : <span class="id" type="var">id</span>) (<span class="id" type="var">value</span> : <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">partial_map</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">record</span> <span class="id" type="var">x</span> <span class="id" type="var">value</span> <span class="id" type="var">d</span>.<br/>
</div>

<div class="doc">
最后，<span class="inlinecode"><span class="id" type="var">find</span></span> 函数按照给定的键搜索一个 <span class="inlinecode"><span class="id" type="var">partial_map</span></span>。若该键无法找到，
    它就返回 <span class="inlinecode"><span class="id" type="var">None</span></span>；若该键与 <span class="inlinecode"><span class="id" type="var">val</span></span> 相关联，则返回 <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode"><span class="id" type="var">val</span></span>。
    若同一个键被映到多个值，<span class="inlinecode"><span class="id" type="var">find</span></span> 就会返回它遇到的第一个值。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">find</span> (<span class="id" type="var">x</span> : <span class="id" type="var">id</span>) (<span class="id" type="var">d</span> : <span class="id" type="var">partial_map</span>) : <span class="id" type="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">d</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">empty</span>         ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">record</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span> <span class="id" type="var">d'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">eqb_id</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <span class="id" type="var">Some</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">find</span> <span class="id" type="var">x</span> <span class="id" type="var">d'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab98"></a><h4 class="section">练习：1 星, standard (update_eq)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">update_eq</span> :<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">d</span> : <span class="id" type="var">partial_map</span>) (<span class="id" type="var">x</span> : <span class="id" type="var">id</span>) (<span class="id" type="var">v</span>: <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">x</span> (<span class="id" type="var">update</span> <span class="id" type="var">d</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>) = <span class="id" type="var">Some</span> <span class="id" type="var">v</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab99"></a><h4 class="section">练习：1 星, standard (update_neq)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">update_neq</span> :<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">d</span> : <span class="id" type="var">partial_map</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">id</span>) (<span class="id" type="var">o</span>: <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">eqb_id</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> = <span class="id" type="var">false</span> → <span class="id" type="var">find</span> <span class="id" type="var">x</span> (<span class="id" type="var">update</span> <span class="id" type="var">d</span> <span class="id" type="var">y</span> <span class="id" type="var">o</span>) = <span class="id" type="var">find</span> <span class="id" type="var">x</span> <span class="id" type="var">d</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">
<span class="id" type="keyword">End</span> <span class="id" type="var">PartialMap</span>.<br/>
</div>

<div class="doc">
<a name="lab100"></a><h4 class="section">练习：2 星, standard (baz_num_elts)</h4>
 考虑以下归纳定义： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <span class="id" type="var">baz</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">Baz1</span> (<span class="id" type="var">x</span> : <span class="id" type="var">baz</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">Baz2</span> (<span class="id" type="var">y</span> : <span class="id" type="var">baz</span>) (<span class="id" type="var">b</span> : <span class="id" type="var">bool</span>).<br/>
</div>

<div class="doc">
有<b>多少</b>个表达式具备类型 <span class="inlinecode"><span class="id" type="var">baz</span></span>？（以注释说明。） 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">manual_grade_for_baz_num_elts</span> : <span class="id" type="var">option</span> (<span class="id" type="var">nat</span>*<span class="id" type="var">string</span>) := <span class="id" type="var">None</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">

<span class="comment">(*&nbsp;Fri&nbsp;Jul&nbsp;19&nbsp;00:32:19&nbsp;UTC&nbsp;2019&nbsp;*)</span><br/>
</div>
</div>



</div>

</body>
</html>