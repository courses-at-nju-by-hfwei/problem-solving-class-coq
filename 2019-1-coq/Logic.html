<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Logic</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href="https://github.com/hengxin/problem-solving-class-coq">
<img src="common/media/image/sf_logo_sm.png"></a>
<br><span class="booktitleinheader">Volume 1: 逻辑基础</span><br><br>
<ul id="menu">
   <a href="toc.html"><li class="section_name">目录</li></a>
   <a href="deps.html"><li class="section_name">路线</li></a>
</ul>
</div>


<div id="main">

<h1 class="libtitle">Library Logic</h1>

<div class="code code-tight">
</div>

<div class="doc">
<a name="lab98"></a><h1 class="section">Logic: Coq 中的逻辑系统</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  本节依赖于 <span class="inlinecode"><span class="id" type="var">Basics.v</span></span> (你需要先阅读它)。
  你需要先编译 <span class="inlinecode"><span class="id" type="var">Basics.v</span></span> 得到 <span class="inlinecode"><span class="id" type="var">Basics.vo</span></span>。
  编译方法：在 CoqIDE 中打开 <span class="inlinecode"><span class="id" type="var">Basics.v</span></span>，
  执行 "Compile" 菜单中的 "Compile Buffer" 命令。

<div class="paragraph"> </div>

  (TODO (@ant-hengxin): How to "Make"?)

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Set</span> <span class="id" type="var">Warnings</span> "-notation-overridden,-parsing".<br/>
<span class="id" type="keyword">From</span> <span class="id" type="var">LF</span> <span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <span class="id" type="var">Basics</span>.<br/>

<br/>
</div>

<div class="doc">
  "逻辑是不可战胜的，因为反对逻辑还得使用逻辑。"
  (Logic is invincible because in order to combat logic 
  it is necessary to use logic.) By Pierre Boutroux.

<div class="paragraph"> </div>

  本节介绍一阶谓词逻辑 
  (说它是一阶谓词逻辑并不严格，我们以后讨论。) 
  的 <b>自然推理系统</b> (Natural Deduction System)。
  系统，封闭之结构也;
  推理，证明之路径也;
  自然，“无他，但手熟尔”。
  这个推理系统，我们基本每天都在使用 (或者误用)。
  本节只不过是告诉你如何在 Coq 中使用这个推理系统证明定理 
  (有 Coq 盯着你，你就再也不会误用它们了)。

<div class="paragraph"> </div>

  在一阶谓词逻辑中，我们会考虑各种 <b>命题</b> (Proposition)，包括
  <b>合取</b> (Conjunctive) 命题、<b>析取</b> (Disjunctive) 命题、
  <b>否定</b> (Negative) 命题、<b>蕴含_ (Implication)' 命题、
  <b>等价</b> (Equivalence) 命题、<b>相等性</b> (Equality) 命题、
  <b>存在</b> (Existence) 命题以及 <b>全称</b> (Forall) 命题。 

<div class="paragraph"> </div>

  关于逻辑，首先需要介绍的一个概念就是 <b>命题</b> (Proposition)。
  什么是命题? 命题就是可以判断真假的语句。
  什么是语句? 语句是不含自由变量的公式。
  什么是真? 什么是假? 这个问题就深了。我不敢妄言。
  在这里，我们采用直觉的定义方式，不深究真与假的概念。
  所谓命题，就是可以判断真假的不含自由变量的公式。
  (又有学生问: 什么是变量? 什么是自由变量? 什么是公式?)
  我们之前证明过的 <span class="inlinecode"><span class="id" type="keyword">Example</span></span>、<span class="inlinecode"><span class="id" type="keyword">Lemma</span></span>、<span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> 都是命题。
  如果这个定义还是让你疑惑重重，你不妨采取下面这种定义方式:
  "我不知道什么是命题，但是当我见到它的时候，我就知道了"
  ("I Know It When I See It")

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在 Coq 中，作为一个表达式，命题也是有类型的。
  它的类型是 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>，即 <b>命题类型</b>。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">n</span>.<br/>

<br/>
<span class="id" type="keyword">Check</span> 2 = 2.<br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 2.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <b>是</b>一个命题与该命题<b>为真</b> (或者说，<b>可被证明</b> (Provable)) 是两回事。
  后者是计算机科学与数理逻辑的重要研究对象。 

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在 Coq 中，命题是 <b>一等对象</b> (First-Class Object)'，
  我们可以像操作其它实体那样操作命题，比如:
<ul class="doclist">
<li> (1) 为命题命名，并在之后引用它的名字。

</li>
<li> (2) 命题可以作为函数的返回值。 

</li>
</ul>

<div class="paragraph"> </div>

 (1) 我们可以用 <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> 为命题命名，并在之后引用它的名字。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">plus_fact</span> : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;2 + 2 = 4.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">plus_fact</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_fact_is_true</span> :<br/>
&nbsp;&nbsp;<span class="id" type="var">plus_fact</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  (2) 命题可以作为函数的返回值。这类函数接受某些类型的参数，返回一个命题。
  实际上，这类函数定义了其参数的某种<b>性质</b> (Property)。 

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  例如，函数 <span class="inlinecode"><span class="id" type="var">is_three</span></span> 接受自然数 <span class="inlinecode"><span class="id" type="var">n</span></span>，返回一个命题断言该数字等于 3。
  它定义了自然数的"是否等于3"的性质 (是的，这个性质很无聊)。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">is_three</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = 3.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">is_three</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">three_is_three</span> :<br/>
&nbsp;&nbsp;<span class="id" type="var">is_three</span>(3).<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">is_three</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们还没有介绍过 <span class="inlinecode"><span class="id" type="tactic">unfold</span></span> 证明策略。但是聪明的你应该能猜出它的含义与用法。
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  函数 <span class="inlinecode"><span class="id" type="var">injective</span></span> 定义了一个函数是否是 <b>单射函数</b> (Injective Functions)。
  定义中的 "<span class="inlinecode">{<span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">B</span>}</span>" 表示 <span class="inlinecode"><span class="id" type="var">A</span></span>、<span class="inlinecode"><span class="id" type="var">B</span></span> 是两个参数化类型，
  我们会在后续介绍，这里可以当作它们不存在。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">injective</span> {<span class="id" type="var">A</span> <span class="id" type="var">B</span>} (<span class="id" type="var">f</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">A</span>, <span class="id" type="var">f</span> <span class="id" type="var">x</span> = <span class="id" type="var">f</span> <span class="id" type="var">y</span> -&gt; <span class="id" type="var">x</span> = <span class="id" type="var">y</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  相等关系运算符 <span class="inlinecode">=</span> 也是一个返回 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> 的函数。
  表达式 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> 只是 <span class="inlinecode"><span class="id" type="var">eq</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> 的 <b>语法糖</b> (Syntactic Sugar)。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> @<span class="id" type="var">eq</span>. 
<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  你可以使用 <span class="inlinecode"><span class="id" type="keyword">Print</span></span> <span class="inlinecode"><span class="id" type="var">eq</span></span> 提前偷窥一下 <span class="inlinecode"><span class="id" type="var">eq</span></span> 的定义。
  怎么样? 看不懂吧。稍安勿躁。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">eq</span>.<br/>
</div>

<div class="doc">
<a name="lab99"></a><h1 class="section">逻辑联结词</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  自然推理系统中的规则有很好的对称性。
  它为每个逻辑联结词引入两个规则，
  一个是 introduction 规则，一个是 elimination 规则。
  introduction 规则用于证明含有相应逻辑联结词的目标，
  而 elimination 规则用于消除前提中含有的相应逻辑联结词。

<div class="paragraph"> </div>

  强烈建议: 请结合以下资料阅读并练习本节后续内容。
<ul class="doclist">
<li> https://www.cs.cornell.edu/courses/cs3110/2013sp/lectures/lec15-logic-contd/lec15.html

</li>
<li> https://leanprover.github.io/logic_and_proof/natural_deduction_for_propositional_logic.html

</li>
<li> https://leanprover.github.io/logic_and_proof/natural_deduction_for_first_order_logic.html 

</li>
</ul>

</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab100"></a><h2 class="section">合取</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  命题 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 表示命题 <span class="inlinecode"><span class="id" type="var">A</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span> 的<b>合取</b>（即<b>逻辑与</b>）
  <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 为真当且仅当 <span class="inlinecode"><span class="id" type="var">A</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span> 均为真。
  <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 是 <span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span> 的语法糖。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">and</span>.<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">and</span>. 
<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  要证明 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" type="var">B</span></span>，只需分别证明 <span class="inlinecode"><span class="id" type="var">A</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span>。
  在 Coq 中，<span class="inlinecode"><span class="id" type="tactic">split</span></span> 策略会为目标 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 生成两个子目标 <span class="inlinecode"><span class="id" type="var">A</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span>。 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">and_example</span> : 3 + 4 = 7 /\ 2 * 2 = 4.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  对于任意命题 <span class="inlinecode"><span class="id" type="var">A</span></span> 和 <span class="inlinecode"><span class="id" type="var">B</span></span>，如果 <span class="inlinecode"><span class="id" type="var">A</span></span> 为真且 <span class="inlinecode"><span class="id" type="var">B</span></span> 为真，则 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 也为真。
  这个推理规则被称为 "/\-intro"。
  "intro" 表示在推导过程中 _引入_ 了 "and"。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_intro</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Prop</span>, <span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span> -&gt; <span class="id" type="var">A</span> /\ <span class="id" type="var">B</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">HA</span> <span class="id" type="var">HB</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">HB</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  在上面的证明中，我们使用了一种新的证明策略 <span class="inlinecode"><span class="id" type="tactic">apply</span></span>。
  当证明目标 G 与上下文中的某个前提 H 完全相同时，
  我们就可以使用 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> 完成证明 
  (也可以使用 <span class="inlinecode"><span class="id" type="tactic">exact</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> 或者 <span class="inlinecode"><span class="id" type="tactic">assumption</span></span>)。
  关于 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> 的其余用法，我们在后续介绍。

<div class="paragraph"> </div>

<a name="lab101"></a><h4 class="section">练习：2 星, standard (and_exercise)</h4>
 TODO: (@ant-hengxin) 用到了后面才介绍的 <span class="inlinecode"><span class="id" type="tactic">discriminate</span></span> 策略。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">and_exercise</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0 -&gt; <span class="id" type="var">n</span> = 0 /\ <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  如果当前 _证明上下文_ 中存在形如 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 的前提 <span class="inlinecode"><span class="id" type="var">H</span></span>，
  我们可以使用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[<span class="id" type="var">HA</span></span> <span class="inlinecode"><span class="id" type="var">HB</span>]</span> 将 <span class="inlinecode"><span class="id" type="var">H</span></span> 转化为 <span class="inlinecode"><span class="id" type="var">HA</span></span> 和 <span class="inlinecode"><span class="id" type="var">HB</span></span>
  两个新的前提。这样，我们就可以单独使用 <span class="inlinecode"><span class="id" type="var">A</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span> 进行证明了。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_example2</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 /\ <span class="id" type="var">m</span> = 0 -&gt; <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
你是否还记得 "intro pattern"? 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_example2'</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 /\ <span class="id" type="var">m</span> = 0 -&gt; <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> [<span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>]. &nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab102"></a><h4 class="section">练习：2 星, standard (and_example3)</h4>

<div class="paragraph"> </div>

  证明如下定理。你可以需要使用 <span class="inlinecode"><span class="id" type="var">and_exercise</span></span> 定理与 <span class="inlinecode"><span class="id" type="tactic">assert</span></span> 策略 
  (又忘了吧? 不要沮丧。学习就是不断重复、不断升华的过程。)。 

</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_example3</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0 -&gt; <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  显然，<span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">/\</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 蕴含 <span class="inlinecode"><span class="id" type="var">A</span></span>，也蕴含 <span class="inlinecode"><span class="id" type="var">B</span></span>。
  接下来两个引理 (<span class="inlinecode"><span class="id" type="var">and_elim_left</span></span> 与 <span class="inlinecode"><span class="id" type="var">and_elim_right</span></span>)
  构成 "/\-elimination" 规则。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_elim_left</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> /\ <span class="id" type="var">Q</span> -&gt; <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab103"></a><h4 class="section">练习：1 星, standard, optional (proj2)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_elim_right</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> /\ <span class="id" type="var">Q</span> -&gt; <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">and</span></span> 满足交换律。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">and_commut</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> /\ <span class="id" type="var">Q</span> -&gt; <span class="id" type="var">Q</span> /\ <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab104"></a><h4 class="section">练习：2 星, standard (and_assoc)</h4>

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">and</span></span>满足结合律。请完成定理 <span class="inlinecode"><span class="id" type="var">and_assoc</span></span> 的证明。
  请注意学习 <span class="inlinecode"><span class="id" type="tactic">intros</span></span> <span class="inlinecode">[<span class="id" type="var">HP</span></span> <span class="inlinecode">[<span class="id" type="var">HQ</span></span> <span class="inlinecode"><span class="id" type="var">HR</span>]]</span> 的用法。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">and_assoc</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> /\ (<span class="id" type="var">Q</span> /\ <span class="id" type="var">R</span>) -&gt; (<span class="id" type="var">P</span> /\ <span class="id" type="var">Q</span>) /\ <span class="id" type="var">R</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> [<span class="id" type="var">HP</span> [<span class="id" type="var">HQ</span> <span class="id" type="var">HR</span>]].<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab105"></a><h2 class="section">析取</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  命题 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">\/</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 表示 <span class="inlinecode"><span class="id" type="var">A</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span> 的 <b>析取</b> (即 _逻辑或_)。
  <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">\/</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 为真当且仅当 <span class="inlinecode"><span class="id" type="var">A</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span> 中至少有一个为真。
  <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">\/</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 是 <span class="inlinecode"><span class="id" type="var">or</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span> 的语法糖。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">or</span>. <span class="id" type="keyword">Print</span> <span class="id" type="var">or</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  要证明 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">\/</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 成立，只需要证明 <span class="inlinecode"><span class="id" type="var">A</span></span> 成立或者 <span class="inlinecode"><span class="id" type="var">B</span></span> 成立。
  这就是 <span class="inlinecode">\/-<span class="id" type="tactic">intro</span>-<span class="id" type="tactic">left</span></span> 与 <span class="inlinecode">\/-<span class="id" type="tactic">intro</span>-<span class="id" type="tactic">right</span></span> 规则。
  在 Coq 中，我们可以分别使用 <span class="inlinecode"><span class="id" type="tactic">left</span></span> 与 <span class="inlinecode"><span class="id" type="tactic">right</span></span> 策略选择要证明的子目标。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">or_intro_left</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Prop</span>, <span class="id" type="var">A</span> -&gt; <span class="id" type="var">A</span> \/ <span class="id" type="var">B</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">left</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HA</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab106"></a><h4 class="section">练习：1 星, standard (or_intro_right)</h4>

</div>
<div class="code code-tight">
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 引理 <span class="inlinecode"><span class="id" type="var">zero_or_succ</span></span> 需要同时使用 <span class="inlinecode"><span class="id" type="tactic">left</span></span> 和 <span class="inlinecode"><span class="id" type="tactic">right</span></span>。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">zero_or_succ</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 \/ <span class="id" type="var">n</span> = <span class="id" type="var">S</span> (<span class="id" type="var">pred</span> <span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [ | <span class="id" type="var">n</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">right</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab107"></a><h4 class="section">练习：1 星, standard (mult_eq_0)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">mult_eq_0</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0 -&gt; <span class="id" type="var">n</span> = 0 \/ <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  如果已知 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>，我们想证明目标 <span class="inlinecode"><span class="id" type="var">R</span></span>。
  我们只需证明 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">R</span></span> 以及 <span class="inlinecode"><span class="id" type="var">Q</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">R</span></span>。
  这就是 "\/-elimination" 规则，类似于分情形讨论。
  是的，在 Coq 中，我们可以使用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 或者 <span class="inlinecode"><span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">pattern</span></span>
  将"已知 <span class="inlinecode"><span class="id" type="var">P</span>\/</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>，证明目标 <span class="inlinecode"><span class="id" type="var">G</span></span>" 转变成两个任务:
<ul class="doclist">
<li> 已知 <span class="inlinecode"><span class="id" type="var">P</span></span>，证明 <span class="inlinecode"><span class="id" type="var">G</span></span>

</li>
<li> 已知 <span class="inlinecode"><span class="id" type="var">Q</span></span>，证明 <span class="inlinecode"><span class="id" type="var">G</span></span>。

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">or_example</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 \/ <span class="id" type="var">m</span> = 0 -&gt; <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> [<span class="id" type="var">Hn</span> | <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>. <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">mult_n_O</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab108"></a><h4 class="section">练习：1 星, standard (or_commut)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_commut</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> \/ <span class="id" type="var">Q</span>  -&gt; <span class="id" type="var">Q</span> \/ <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab109"></a><h2 class="section">假命题与否定</h2>

  很多时候，我们需要证明某个命题 <span class="inlinecode"><span class="id" type="var">A</span></span> 不成立，
  即证明 <span class="inlinecode">~<span class="id" type="var">A</span></span> 成立。
  <span class="inlinecode">~<span class="id" type="var">A</span></span> 是 <span class="inlinecode"><span class="id" type="var">not</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> 的语法糖。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">not</span>. <span class="id" type="keyword">Print</span> <span class="id" type="var">not</span>. </div>

<div class="doc">
  ===&gt; not = fun A : Prop =&gt; A -&gt; False

<div class="paragraph"> </div>

  我们来解释一下这个定义。
<ul class="doclist">
<li> 首先，<span class="inlinecode"><span class="id" type="var">not</span></span> 是一个函数 <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">False</span></span>。

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">False</span></span> 是匿名函数 (没有函数名)，
    接受一个命题 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>，返回 (=&gt;) 一个命题 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">False</span></span>。

</li>
</ul>
  因此，<span class="inlinecode">~<span class="id" type="var">A</span></span> 就是 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">False</span></span>。
  换句话说，Coq 使用 <span class="inlinecode"><span class="id" type="var">A</span></span> 能蕴含 False，来表示 <span class="inlinecode"><span class="id" type="var">A</span></span> 不成立。

<div class="paragraph"> </div>

  那么，<span class="inlinecode"><span class="id" type="var">False</span></span> 是什么呢?
  <span class="inlinecode"><span class="id" type="var">False</span></span> 是 Coq 标准库中定义的矛盾性命题。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">False</span>. <span class="id" type="keyword">Print</span> <span class="id" type="var">False</span>. </div>

<div class="doc">
  ===&gt; Inductive False : Prop :=

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">False</span></span> 的定义为空。
  这意味着，你无法在 Coq 中证明它。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  定理 <span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span> (拉丁文) 描述了 <span class="inlinecode"><span class="id" type="var">False</span>-<span class="id" type="var">elimination</span></span> 规则，
  它的含义是 "从谬误出发，你能够证明任何命题。"
  (王小波关于"荒诞的年代"的那句话是怎么说的来着?)

<div class="paragraph"> </div>

  如果 <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">False</span></span> 作为前提出现在上下文中，
  那么我们就可以使用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> 来完成任何待证目标。 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ex_falso_quodlibet</span> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">False</span> -&gt; <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">contra</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">ex</span></span> <span class="inlinecode"><span class="id" type="var">falso</span></span> <span class="inlinecode"><span class="id" type="var">quodlibet</span></span> (缩写 EFQ) 也称为 _"Principle of Explosion"_。
  形象地讲，<span class="inlinecode"><span class="id" type="var">False</span></span> 是枚炸弹，<span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">False</span></span> 就是在拆炸弹。
  然后，Bang ……

<div class="paragraph"> </div>

  因此，一旦我们设法向上下文中引入了 <span class="inlinecode"><span class="id" type="var">False</span></span>，我们也就完成了证明。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_False</span> :<br/>
&nbsp;&nbsp;~ <span class="id" type="var">False</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. &nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. &nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_neg</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> -&gt; ~~<span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">G</span>. &nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">G</span>. &nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  定理 <span class="inlinecode"><span class="id" type="var">double_neg</span></span> 的证明使用了 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> 策略的另一种用法。

<div class="paragraph"> </div>

  之前，当待证明的目标 <span class="inlinecode"><span class="id" type="keyword">Goal</span></span> 与上下文中的某个前提 <span class="inlinecode"><span class="id" type="var">A</span></span> 完全一样时，
  我们使用 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> 即可完成证明。

<div class="paragraph"> </div>

  在上面的证明中，<span class="inlinecode"><span class="id" type="var">G</span></span> 是一个蕴含式 <span class="inlinecode"><span class="id" type="var">G</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">False</span></span>，
  当前待证目标 <span class="inlinecode"><span class="id" type="keyword">Goal</span></span> 是 <span class="inlinecode"><span class="id" type="keyword">Goal</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">False</span></span>。
  注意到待证目标与蕴含式 <span class="inlinecode"><span class="id" type="var">G</span></span> 中的结论相同 
  (更宽泛地讲，只需要它们可以匹配)，
  此时，<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">G</span></span> 将 <span class="inlinecode"><span class="id" type="var">G</span></span> 作用到当前待证目标上，
  其效果相当于 _逆向 (Backward)_ 使用蕴含式 <span class="inlinecode"><span class="id" type="var">G</span></span>:
  它将待证目标 <span class="inlinecode"><span class="id" type="var">False</span></span> 转化为 <span class="inlinecode"><span class="id" type="var">P</span></span>。
  背后的推理是: 要证明 <span class="inlinecode"><span class="id" type="var">False</span></span> 成立，根据前提 <span class="inlinecode"><span class="id" type="var">G</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">False</span></span>，
  只需证明 <span class="inlinecode"><span class="id" type="var">P</span></span> 成立。
  这实际上是 <span class="inlinecode">-&gt;-<span class="id" type="var">elimination</span></span> 规则，也就是 <b>modus ponens</b> 规则，
  后面会有介绍。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">contradiction_implies_anything</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> /\ ~<span class="id" type="var">P</span>) -&gt; <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HNP</span>]. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="tactic">in</span> <span class="id" type="var">HNP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HNP</span> <span class="id" type="tactic">in</span> <span class="id" type="var">HP</span>. &nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">HP</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  上面的证明使用了 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> 策略的第三种用法:
  <span class="inlinecode"><span class="id" type="var">HNP</span></span> 是蕴含式 <span class="inlinecode"><span class="id" type="var">HNP</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">False</span></span>。
  <span class="inlinecode"><span class="id" type="var">HP</span></span> 是 <span class="inlinecode"><span class="id" type="var">HP</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span>。
  注意到 <span class="inlinecode"><span class="id" type="var">HP</span></span> 与 <span class="inlinecode"><span class="id" type="var">HNP</span></span> 的前件相同，
  此时，<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">HNP</span></span> <span class="inlinecode"><span class="id" type="tactic">in</span></span> <span class="inlinecode"><span class="id" type="var">HP</span></span> 是在正向应用 modus ponens 规则:
  已知 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">False</span></span> 与 <span class="inlinecode"><span class="id" type="var">P</span></span>，推导出 <span class="inlinecode"><span class="id" type="var">False</span></span>。

<div class="paragraph"> </div>

  注意: <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">I</span></span> <span class="inlinecode"><span class="id" type="tactic">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> 会改变 <span class="inlinecode"><span class="id" type="var">H</span></span>。
  如果不想改变 <span class="inlinecode"><span class="id" type="var">H</span></span>，可以使用 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">I</span></span> <span class="inlinecode"><span class="id" type="tactic">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">...</span> 变体。

<div class="paragraph"> </div>

<a name="lab110"></a><h4 class="section">练习：2 星, standard, optional (not_implies_our_not)</h4>

<div class="paragraph"> </div>

  了解了 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> 的用法，现在你可以证明定理 
  <span class="inlinecode"><span class="id" type="var">not_implies_our_not</span></span> 了。
  它实际上指出了 <span class="inlinecode"><span class="id" type="var">not</span></span> 的另一种定义方法:
  我们可以使用 "<span class="inlinecode"><span class="id" type="var">P</span></span> 可以蕴含一切命题 (<span class="inlinecode"><span class="id" type="var">Q</span></span>)" 定义 <span class="inlinecode"><span class="id" type="var">not</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span>。  

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fact</span> <span class="id" type="var">not_implies_forall_implication</span> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;~ <span class="id" type="var">P</span> -&gt; (<span class="id" type="keyword">forall</span> (<span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>), <span class="id" type="var">P</span> -&gt; <span class="id" type="var">Q</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fact</span> <span class="id" type="var">forall_implication_implies_not</span> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> (<span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>), <span class="id" type="var">P</span> -&gt; <span class="id" type="var">Q</span>) -&gt; (~ <span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">PQ</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intro</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">PQ</span> <span class="id" type="var">False</span>). &nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab111"></a><h4 class="section">练习：2 星, standard, recommended (contrapositive)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">contrapositive</span> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> -&gt; <span class="id" type="var">Q</span>) -&gt; (~<span class="id" type="var">Q</span> -&gt; ~<span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab112"></a><h4 class="section">练习：1 星, standard (not_both_true_and_false)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_both_true_and_false</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~ (<span class="id" type="var">P</span> /\ ~<span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  我们用 <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" type="var">y</span></span> 表示 (~ (x = y))。
  Notation "x &lt;&gt; y" := (~(x = y)).

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_true_is_false</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> &lt;&gt; <span class="id" type="var">true</span> -&gt; <span class="id" type="var">b</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [] <span class="id" type="var">H</span>. &nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="tactic">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">ex_falso_quodlibet</span>. &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Coq 为 <span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span> 提供了内建的策略 <span class="inlinecode"><span class="id" type="var">exfalso</span></span>。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">exfalso</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_true_is_false'</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> &lt;&gt; <span class="id" type="var">true</span> -&gt; <span class="id" type="var">b</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [] <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="tactic">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">exfalso</span>. &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab113"></a><h2 class="section">真值</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">True</span></span> 也是 Coq 预定义的命题，它代表真。
  我们已经知道 <span class="inlinecode"><span class="id" type="var">False</span></span> 的定义为空，那么 <span class="inlinecode"><span class="id" type="var">True</span></span> 的定义是什么呢?

</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">True</span>.<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">True</span>.<br/>
</div>

<div class="doc">
  ===&gt; <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" type="var">True</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" type="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">True</span></span>

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">True</span></span> 只有一种构造方式，那就是 <span class="inlinecode"><span class="id" type="var">I</span></span>。
  因此，要证明 <span class="inlinecode"><span class="id" type="var">True</span></span>，我们只需要 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">I</span></span> 即可。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">True_is_true</span> : <span class="id" type="var">True</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">I</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">True</span></span> 作为前提不携带任何有用的信息，
  因此没有必要引入 <span class="inlinecode"><span class="id" type="var">True</span>-<span class="id" type="var">elimination</span></span> 规则。

</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab114"></a><h2 class="section">蕴含</h2>

<div class="paragraph"> </div>

  命题 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 表示命题 <span class="inlinecode"><span class="id" type="var">A</span></span> 蕴含命题 <span class="inlinecode"><span class="id" type="var">B</span></span>。
  <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 为真当且仅当 <span class="inlinecode"><span class="id" type="var">A</span></span> 为假或者 <span class="inlinecode"><span class="id" type="var">A</span></span>、<span class="inlinecode"><span class="id" type="var">B</span></span>均为真。
  我们已经见识过一些涉及蕴含的命题与证明了。
  这里，我们从自然推理系统的角度重新审视之前使用的证明策略。

<div class="paragraph"> </div>

  要证明 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span>，我们通常将 <span class="inlinecode"><span class="id" type="var">A</span></span> 作为假设加入到上下文中，
  然后在假设 <span class="inlinecode"><span class="id" type="var">A</span></span> 成立的前提下，证明 <span class="inlinecode"><span class="id" type="var">B</span></span>。
  这就是对 "-&gt;-intro" 规则的逆向使用。
  注意: 当我们应用该规则时，新加入的假设 <span class="inlinecode"><span class="id" type="var">A</span></span> 被 discharged 了。
  (discharged，"放电"? "释放"? "撤销"? 我找不到合适的译法。大家意会吧。)

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ABA</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Prop</span>, <span class="id" type="var">A</span> -&gt; (<span class="id" type="var">B</span> -&gt; <span class="id" type="var">A</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">HA</span> <span class="id" type="var">HB</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HA</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  如果当前证明上下文中存在形如 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 的前提 <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span>，
  并且存在前提 <span class="inlinecode"><span class="id" type="var">Q</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span></span>，那么我们可以使用 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="tactic">in</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>，得到 <span class="inlinecode"><span class="id" type="var">B</span></span>。
  这就是 "-&gt;-elimination" 规则，
  也就是常说的 _分离规则_ (modus ponens; MP)。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ABBC</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;((<span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span>) /\ (<span class="id" type="var">B</span> -&gt; <span class="id" type="var">C</span>)) -&gt; (<span class="id" type="var">A</span> -&gt; <span class="id" type="var">C</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span> [<span class="id" type="var">HAB</span> <span class="id" type="var">HBC</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HAB</span> <span class="id" type="tactic">in</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HBC</span> <span class="id" type="tactic">in</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HA</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab115"></a><h4 class="section">练习：1 星, standard, recommended (implies)</h4>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">A_or_BA</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">A</span> \/ (<span class="id" type="var">B</span> /\ <span class="id" type="var">A</span>)) -&gt; <span class="id" type="var">A</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ABC</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;((<span class="id" type="var">A</span> -&gt; (<span class="id" type="var">B</span> -&gt; <span class="id" type="var">C</span>)) /\ <span class="id" type="var">B</span>) -&gt; (<span class="id" type="var">A</span> -&gt; <span class="id" type="var">C</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab116"></a><h2 class="section">逻辑等价</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  命题 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">&lt;-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 表示 <span class="inlinecode"><span class="id" type="var">A</span></span> 成立当且仅当 <span class="inlinecode"><span class="id" type="var">B</span></span> 成立。
  <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">&lt;-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 是 <span class="inlinecode"><span class="id" type="var">iff</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span> 的语法糖。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">iff</span>.<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">iff</span>.<br/>
</div>

<div class="doc">
  ===&gt; iff = fun A B : Prop =&gt; (A -&gt; B) /\ (B -&gt; A)

<div class="paragraph"> </div>

  我们详细讲解过 <span class="inlinecode"><span class="id" type="var">not</span></span> 的定义。
  现在，你应该能独立理解 <span class="inlinecode"><span class="id" type="var">iff</span></span> 的定义了。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在 Coq 中，<span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">&lt;-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 即为 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">A</span></span> 的合取。
<ul class="doclist">
<li> 当 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">&lt;-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 作为前提 <span class="inlinecode"><span class="id" type="var">H</span></span> 出现在上下文中时，
    我们可以使用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[<span class="id" type="var">HAB</span></span> <span class="inlinecode"><span class="id" type="var">HBA</span>]</span> 
    将它拆成两个前提 <span class="inlinecode"><span class="id" type="var">HAB</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 与 <span class="inlinecode"><span class="id" type="var">HBA</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">A</span></span>。

</li>
<li> 当 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">&lt;-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 作为目标时，
    我们可以使用 <span class="inlinecode"><span class="id" type="tactic">split</span></span> 将它拆成两个子目标
    <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">B</span></span> 与 <span class="inlinecode"><span class="id" type="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">A</span></span>。

</li>
</ul>

<div class="paragraph"> </div>

  依照上述证明方法，我们可以证明 <span class="inlinecode"><span class="id" type="var">iff</span></span> 具有对称性 (定理 <span class="inlinecode"><span class="id" type="var">iff_sym</span></span>)。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_sym</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> &lt;-&gt; <span class="id" type="var">Q</span>) -&gt; (<span class="id" type="var">Q</span> &lt;-&gt; <span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HAB</span> <span class="id" type="var">HBA</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">apply</span> <span class="id" type="var">HBA</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">apply</span> <span class="id" type="var">HAB</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">not_true_iff_false</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> &lt;&gt; <span class="id" type="var">true</span> &lt;-&gt; <span class="id" type="var">b</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">apply</span> <span class="id" type="var">not_true_is_false</span>.<br/>
&nbsp;&nbsp;-  <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">discriminate</span> <span class="id" type="var">H'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  在上面证明的最后，我们使用了 <span class="inlinecode"><span class="id" type="tactic">discriminate</span></span> <span class="inlinecode"><span class="id" type="var">H'</span></span> 完成证明。
  此时，<span class="inlinecode"><span class="id" type="var">H'</span>:</span> <span class="inlinecode"><span class="id" type="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>。<span class="inlinecode"><span class="id" type="var">false</span></span> 与 <span class="inlinecode"><span class="id" type="var">true</span></span> 是 <span class="inlinecode"><span class="id" type="var">bool</span></span> 类型的两个构造函数。
  在归纳定义中，不同的构造函数构造出的值一定是不同的。
  如果上下文出现类似 <span class="inlinecode"><span class="id" type="var">H'</span></span> 的假设，则可以立即使用 <span class="inlinecode"><span class="id" type="tactic">discriminate</span></span> 完成证明。
  关于 <span class="inlinecode"><span class="id" type="tactic">discriminate</span></span> 的详细介绍，我们留到 <span class="inlinecode"><span class="id" type="var">Induction.v</span></span> 中。 

<div class="paragraph"> </div>

<a name="lab117"></a><h4 class="section">练习：1 星, standard, optional (iff_properties)</h4>

<div class="paragraph"> </div>

  请证明 <span class="inlinecode"><span class="id" type="var">iff</span></span> 具有自反性 (定理 <span class="inlinecode"><span class="id" type="var">iff_refl</span></span>) 与传递性 (iff_trans)。
  (你可能还不知道什么是自反性，什么是对称性，什么是传递性。不要紧。
  我们会在后续课程介绍。)

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_refl</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> &lt;-&gt; <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_trans</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> &lt;-&gt; <span class="id" type="var">Q</span>) -&gt; (<span class="id" type="var">Q</span> &lt;-&gt; <span class="id" type="var">R</span>) -&gt; (<span class="id" type="var">P</span> &lt;-&gt; <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab118"></a><h4 class="section">练习：3 星, standard (or_distributes_over_and)</h4>
 请证明如下分配律。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_distributes_over_and</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> \/ (<span class="id" type="var">Q</span> /\ <span class="id" type="var">R</span>) &lt;-&gt; (<span class="id" type="var">P</span> \/ <span class="id" type="var">Q</span>) /\ (<span class="id" type="var">P</span> \/ <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  我们之前介绍过的 <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> 和 <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 
  不仅可以用于相等关系，还可用于 <span class="inlinecode"><span class="id" type="var">iff</span></span> 命题。
  为了开启此行为，我们需要导入库 Setoids.Setoid。

</div>
<div class="code code-tight">
<span class="id" type="keyword">From</span> <span class="id" type="var">Coq</span> <span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Setoids.Setoid</span>.<br/>

<br/>
</div>

<div class="doc">
  为了演示 <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>、<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 在 <span class="inlinecode"><span class="id" type="var">iff</span></span> 上的作用，
  我们先做一些准备工作。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">mult_0</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0 &lt;-&gt; <span class="id" type="var">n</span> = 0 \/ <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">mult_eq_0</span>. &nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">or_example</span>. <span class="id" type="keyword">Qed</span>. 
<br/>
</div>

<div class="doc">
  我们将定理 <span class="inlinecode"><span class="id" type="var">or_assoc</span></span> 的证明留作练习。
  一点提示: <span class="inlinecode"><span class="id" type="tactic">intro</span></span> <span class="inlinecode">[<span class="id" type="var">HP</span></span> <span class="inlinecode">|</span> <span class="inlinecode">[<span class="id" type="var">HQ</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">HR</span>]]</span>。

</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">or_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>, <span class="id" type="var">P</span> \/ (<span class="id" type="var">Q</span> \/ <span class="id" type="var">R</span>) &lt;-&gt; (<span class="id" type="var">P</span> \/ <span class="id" type="var">Q</span>) \/ <span class="id" type="var">R</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  现在，我们利用 <span class="inlinecode"><span class="id" type="var">mult_0</span></span> 与 <span class="inlinecode"><span class="id" type="var">or_assoc</span></span> 证明 <span class="inlinecode"><span class="id" type="var">mult_0_3</span></span>。
  注意，我们可以对 <span class="inlinecode"><span class="id" type="var">iff</span></span> 命题使用 <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> 与 <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">mult_0_3</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <span class="id" type="var">n</span> * <span class="id" type="var">m</span> * <span class="id" type="var">p</span> = 0 &lt;-&gt; <span class="id" type="var">n</span> = 0 \/ <span class="id" type="var">m</span> = 0 \/ <span class="id" type="var">p</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">mult_0</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">mult_0</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">or_assoc</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  此外，<span class="inlinecode"><span class="id" type="tactic">apply</span></span> 策略也可以用在 <span class="inlinecode">&lt;-&gt;</span> 上。
  这时，Coq 会尝试应用正确的方向。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">apply_iff_example</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0 -&gt; <span class="id" type="var">n</span> = 0 \/ <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">mult_0</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab119"></a><h2 class="section">存在量词</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  命题 <span class="inlinecode"><span class="id" type="tactic">exists</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> 表示存在类型为 <span class="inlinecode"><span class="id" type="var">T</span></span> 的 <span class="inlinecode"><span class="id" type="var">x</span></span>，
  使得性质 <span class="inlinecode"><span class="id" type="var">P</span></span> 对 <span class="inlinecode"><span class="id" type="var">x</span></span> 成立 (或说，<span class="inlinecode"><span class="id" type="var">x</span></span> 满足性质 <span class="inlinecode"><span class="id" type="var">P</span></span>)。
  <span class="inlinecode"><span class="id" type="tactic">exists</span></span> 是 <b>存在量词</b>。
  (如果 Coq 能从上下文中推断出 <span class="inlinecode"><span class="id" type="var">x</span></span> 的类型，那么 <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> 也可以省略。
  但并不建议初学者这么做。)

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  要证明形如 <span class="inlinecode"><span class="id" type="tactic">exists</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> 的命题，
  我们只需(而且"必须"; 下一节 "ConsLogic.v" 解释)
  证明 <span class="inlinecode"><span class="id" type="var">P</span></span> 对于某个特定的 <span class="inlinecode"><span class="id" type="var">x</span></span> 成立。
  我们称 <span class="inlinecode"><span class="id" type="var">x</span></span> 为 <span class="inlinecode"><span class="id" type="tactic">exists</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> 的例证。 
  这对应于 (逆用) "exists-intro" 规则。

<div class="paragraph"> </div>

  在 Coq 中，上述证明分为两步:
<ul class="doclist">
<li> 使用 <span class="inlinecode"><span class="id" type="tactic">exists</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> 策略告诉 Coq 我们认为 <span class="inlinecode"><span class="id" type="var">t</span></span> 是满足要求的 <span class="inlinecode"><span class="id" type="var">x</span></span>。
    此时，证明目标变成 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>。

</li>
<li> 证明新目标 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>。

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">four_is_even</span> : <span class="id" type="tactic">exists</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, 4 = <span class="id" type="var">n</span> + <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">exists</span> 2. &nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  如果形如 <span class="inlinecode"><span class="id" type="var">H</span>:</span> <span class="inlinecode"><span class="id" type="tactic">exists</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> 的命题作为前提出现在上下文中，
  我们可以使用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[<span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">Px</span>]</span> (或者 intros) 将它拆分成
  一个例证 <span class="inlinecode"><span class="id" type="var">x</span></span> 与 <span class="inlinecode"><span class="id" type="var">x</span></span> 满足性质 <span class="inlinecode"><span class="id" type="var">P</span></span> 的前提 <span class="inlinecode"><span class="id" type="var">Px</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>。
  在之后的证明中，我们就可以使用 <span class="inlinecode"><span class="id" type="var">x</span></span> 与前提 <span class="inlinecode"><span class="id" type="var">Px</span></span> 了。
  这对应于 "exists-elimination" 规则。
  (新引入的前提 <span class="inlinecode"><span class="id" type="var">Px</span></span> 在使用 "exists-elimination"规则时
  会被 discharged 掉。)

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">exists_example_2</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">exists</span> <span class="id" type="var">m</span>, <span class="id" type="var">n</span> = 4 + <span class="id" type="var">m</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">exists</span> <span class="id" type="var">o</span>, <span class="id" type="var">n</span> = 2 + <span class="id" type="var">o</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> [<span class="id" type="var">m</span> <span class="id" type="var">Hm</span>]. &nbsp;&nbsp;<span class="id" type="tactic">exists</span> (2 + <span class="id" type="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Hm</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab120"></a><h4 class="section">练习：1 星, standard, recommended (dist_not_exists)</h4>

<div class="paragraph"> </div>

  请证明定理 <span class="inlinecode"><span class="id" type="var">dist_not_exists</span></span>:
  "<span class="inlinecode"><span class="id" type="var">P</span></span> 对所有 <span class="inlinecode"><span class="id" type="var">x</span></span> 成立" 蕴含 "不存在 <span class="inlinecode"><span class="id" type="var">x</span></span> 使得 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> 不成立"。

<div class="paragraph"> </div>

  另外，请思考如何证明另一个方向的蕴含关系?
  在 "ConsLogic.v" 中，我们会给出答案
  (TODO: (@ant-hengxin) 什么时候写这一节呢?)。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">dist_not_exists</span> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">X</span> -&gt; <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span>) -&gt; ~ (<span class="id" type="tactic">exists</span> <span class="id" type="var">x</span>, ~ <span class="id" type="var">P</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab121"></a><h4 class="section">练习：2 星, standard (dist_exists_or)</h4>
 请证明定理 <span class="inlinecode"><span class="id" type="var">dist_exists_or</span></span>: "存在"对"析取"满足分配律。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">dist_exists_or</span> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="var">X</span> -&gt; <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">exists</span> <span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span> \/ <span class="id" type="var">Q</span> <span class="id" type="var">x</span>) &lt;-&gt; (<span class="id" type="tactic">exists</span> <span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span>) \/ (<span class="id" type="tactic">exists</span> <span class="id" type="var">x</span>, <span class="id" type="var">Q</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab122"></a><h2 class="section">全称量词</h2>

<div class="paragraph"> </div>

  命题 <span class="inlinecode"><span class="id" type="keyword">forall</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> 表示对于所有的类型为 <span class="inlinecode"><span class="id" type="var">T</span></span> 的 <span class="inlinecode"><span class="id" type="var">x</span></span>，
  性质<span class="inlinecode"><span class="id" type="var">P</span></span> 都对 <span class="inlinecode"><span class="id" type="var">x</span></span> 成立 (或者说，<span class="inlinecode"><span class="id" type="var">x</span></span> 都满足性质 <span class="inlinecode"><span class="id" type="var">P</span></span>)。
  我们已经见识过很多涉及全称量词的命题与证明了。
  这里，我们从自然推理系统的角度重新审视之前使用的证明策略。

<div class="paragraph"> </div>

  在证明涉及全称量词的命题 <span class="inlinecode"><span class="id" type="keyword">forall</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> 时，
  我们通常的做法是: 先任取 <span class="inlinecode"><span class="id" type="var">x</span></span>，然后证明对于这个任取的 <span class="inlinecode"><span class="id" type="var">x</span></span>，<span class="inlinecode"><span class="id" type="var">P</span></span> 成立。
  这就是在使用 "forall-intro" 规则。
  比如我们之前证明过的 <span class="inlinecode"><span class="id" type="var">and_elim_left</span></span>.

</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_elim_left'</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> /\ <span class="id" type="var">Q</span> -&gt; <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>. &nbsp;&nbsp;<span class="id" type="tactic">intros</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab123"></a><h4 class="section">练习：3 星, standard (combine_odd_even)</h4>

  函数 <span class="inlinecode"><span class="id" type="var">combine_odd_even</span></span> 接受两个定义在自然数上的性质 
  (类型为 <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>) <span class="inlinecode"><span class="id" type="var">Podd</span></span> 与 <span class="inlinecode"><span class="id" type="var">Peven</span></span>，
  返回性质 (类型为 <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>) <span class="inlinecode"><span class="id" type="var">P</span></span>，
  使得当 <span class="inlinecode"><span class="id" type="var">n</span></span> 为奇数时 <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 等价于 <span class="inlinecode"><span class="id" type="var">Podd</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>，否则等价于 <span class="inlinecode"><span class="id" type="var">Peven</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">combine_odd_even</span> (<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> -&gt; <span class="id" type="keyword">Prop</span>) : <span class="id" type="var">nat</span> -&gt; <span class="id" type="keyword">Prop</span><br/>
&nbsp;&nbsp;:= (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; (<span class="id" type="keyword">if</span> (<span class="id" type="var">oddb</span> <span class="id" type="var">n</span>) <span class="id" type="keyword">then</span> <span class="id" type="var">Podd</span> <span class="id" type="var">n</span> <span class="id" type="keyword">else</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  请证明以下三个关于 <span class="inlinecode"><span class="id" type="var">combine_odd_even</span></span> 的定理。
  注意定理的命名 (intro, elimination)。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_intro</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> -&gt; <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> -&gt; <span class="id" type="var">Podd</span> <span class="id" type="var">n</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">false</span> -&gt; <span class="id" type="var">Peven</span> <span class="id" type="var">n</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_elim_odd</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> -&gt; <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Podd</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_elim_even</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> -&gt; <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">false</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Peven</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab124"></a><h4 class="section">练习：2 星, standard (logical_connectives)</h4>


<div class="paragraph"> </div>

    以下引理将本章中讨论的命题联结词与对应的布尔操作关联了起来。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">orb_true_iff</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b1</span> || <span class="id" type="var">b2</span> = <span class="id" type="var">true</span> &lt;-&gt; <span class="id" type="var">b1</span> = <span class="id" type="var">true</span> \/ <span class="id" type="var">b2</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">
</div>
</div>

</div>

</body>
</html>