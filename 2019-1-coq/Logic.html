<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Logic</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Logic</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Logic: Coq 中的逻辑系统</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Warnings</span> "-notation-overridden,-parsing".<br/>
</div>

<div class="doc">
From LF Require Export Tactics. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  "逻辑是不可战胜的，因为要想战胜它，你也要依靠逻辑" By 谁说的来着?

<div class="paragraph"> </div>

  本节介绍一阶谓词逻辑 
  (说它是一阶谓词逻辑并不严格，我们在本节的最后部分讨论) 
  的 <i>'自然推理系统' (Natural Inference? System)_。
  系统，封闭之结构也;
  推理，证明之路径也;
  自然，“无它，唯手熟尔???”。
  这个推理系统，我们基本每天都在使用 (或者误用)。
  本节只不过是告诉你如何在 Coq 中使用这个推理系统证明定理 
  (有 Coq 盯着你，你就再也不会误用它们了)。

<div class="paragraph"> </div>

  在一阶谓词逻辑中，我们会考虑各种 <i>'命题' (Proposition)_，包括
  <i>'合取' (Conjunctive?)_ 命题、<i>'析取' (Disjunctive)_ 命题、
  <i>'否定' (Negative)_ 命题、<i>'蕴含 (Implication)'</i> 命题、
  <i>'等价' (Equivalence)_ 命题、<i>'相等性' (Equality)_ 命题、
  <i>'存在' (Existence)_ 命题 以及 <i>'全称' (Forall)_ 命题。 

<div class="paragraph"> </div>

  关于逻辑，首先需要介绍的一个概念就是 <i>'命题' (Proposition)_。
  什么是命题? 命题就是可以判断真假的语句。
  什么是语句? 语句是不含自由变量的公式。
  什么是真? 什么是假? 这个问题就深了。我不敢妄言。
  在这里，我们采用直觉的定义方式，不深究真与假的概念。
  所谓命题，就是可以判断真假的不含自由变量的公式。
  (又有学生问: 什么是变量? 什么是自由变量? 什么是公式?)
  我们之前证明过的 <span class="inlinecode"><span class="id" title="keyword">Example</span></span>、<span class="inlinecode"><span class="id" title="keyword">Lemma</span></span>、<span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> 都是命题。
  如果这个定义还是让你疑惑重重，你不妨采取下面这种定义方式:
  "我不知道什么是命题，但是当我见到它的时候，我就知道了"
  ("I Know It When I See It")

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在 Coq 中，作为一个表达式，命题也是有类型的。
  它的类型是 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>，即 <i>'命题类型'</i>。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> 2 = 2.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 2.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  <i>'是'</i>一个命题与该命题<i>'为真'</i> (或者说，<i>'可被证明' (Provable)_) 是两回事。
  后者是计算机科学与数理逻辑的重要研究对象。 

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  在 Coq 中，命题是 <i>'一等对象（First-Class Object）'</i>，
  我们可以像操作其它实体那样操作命题，比如:
<ul class="doclist">
<li> (1) 为命题命名，并在之后引用它的名字。

</li>
<li> (2) 命题可以作为函数的返回值。 

</li>
</ul>

<div class="paragraph"> </div>

 (1) 我们可以用 <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> 为命题命名，并在之后引用它的名字。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">plus_fact</span> : <span class="id" title="keyword">Prop</span> := <br/>
&nbsp;&nbsp;2 + 2 = 4.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">plus_fact</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_fact_is_true</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">plus_fact</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  (2) 命题可以作为函数的返回值。这类函数接受某些类型的参数，返回一个命题。
  实际上，这类函数定义了其参数的某种<i>'性质' (Property)_。 

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  例如，函数 <span class="inlinecode"><span class="id" title="var">is_three</span></span> 接受自然数 <span class="inlinecode"><span class="id" title="var">n</span></span>，返回一个命题断言该数字等于 3。
  它定义了自然数的"是否等于3"的性质 (是的，这个性质很无聊)。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">is_three</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> = 3.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">is_three</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">three_is_three</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">is_three</span>(3).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">is_three</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们还没有介绍过 <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> 证明策略。但是聪明的你应该能猜出它的含义与用法。
<div class="paragraph"> </div>


<div class="paragraph"> </div>

  函数 <span class="inlinecode"><span class="id" title="var">injective</span></span> 定义了一个函数是否是 <i>'单射函数' (Injective Functions)_。
  定义中的 "<span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span>}</span>" 表示 <span class="inlinecode"><span class="id" title="var">A</span></span>、<span class="inlinecode"><span class="id" title="var">B</span></span> 是两个参数化类型，
  我们会在后续介绍，这里可以当作它们不存在。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">injective</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">y</span> → <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  相等关系运算符 <span class="inlinecode">=</span> 也是一个返回 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> 的函数。
  表达式 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 只是 <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> 的 <i>'语法糖' (Syntax Sugar?)_。

</div>
<div class="code">
<span class="id" title="keyword">Check</span> @<span class="id" title="var">eq</span>. 
<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  你可以使用 <span class="inlinecode"><span class="id" title="keyword">Print</span></span> <span class="inlinecode"><span class="id" title="var">eq</span></span> 提前偷窥一下 <span class="inlinecode"><span class="id" title="var">eq</span></span> 的定义。
  怎么样? 看不懂吧。稍安勿躁。

</div>
<div class="code">
<span class="id" title="keyword">Print</span> <span class="id" title="var">eq</span>.<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">逻辑联结词</h1>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab3"></a><h2 class="section">合取</h2>

<div class="paragraph"> </div>

 命题 <span class="inlinecode"><span class="id" title="var">A</span></span> 与 <span class="inlinecode"><span class="id" title="var">B</span></span> 的<i>'合取'</i>（即<i>'逻辑与'</i>）写作 <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">B</span></span>，表示一个
    <span class="inlinecode"><span class="id" title="var">A</span></span> 与 <span class="inlinecode"><span class="id" title="var">B</span></span> 均为真的断言。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">and_example</span> : 3 + 4 = 7 ∧ 2 × 2 = 4.<br/>

<br/>
</div>

<div class="doc">
证明合取的命题通常使用 <span class="inlinecode"><span class="id" title="tactic">split</span></span> 策略。它会分别为语句的两部分生成两个子目标： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
对于任意命题 <span class="inlinecode"><span class="id" title="var">A</span></span> 和 <span class="inlinecode"><span class="id" title="var">B</span></span>，如果我们假设 <span class="inlinecode"><span class="id" title="var">A</span></span> 为真且 <span class="inlinecode"><span class="id" title="var">B</span></span> 为真，
    那么就能得出 <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">B</span></span> 也为真的结论。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and_intro</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">A</span> ∧ <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">HA</span> <span class="id" title="var">HB</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">HA</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">HB</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
由于按照前提对某个目标应用定理会产生与该定理的前提一样多的子目标。
    因此我们可以应用 <span class="inlinecode"><span class="id" title="var">and_intro</span></span> 来达到和 <span class="inlinecode"><span class="id" title="tactic">split</span></span> 一样的效果。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">and_example'</span> : 3 + 4 = 7 ∧ 2 × 2 = 4.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">and_intro</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h4 class="section">练习：2 星, standard (and_exercise)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">and_exercise</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = 0 → <span class="id" title="var">n</span> = 0 ∧ <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 以上就是证明合取语句的方法。要反过来使用，即<i>'使用'</i>合取前提来帮助证明时，
    我们会采用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 策略。

<div class="paragraph"> </div>

    如果当前证明上下文中存在形如 <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">B</span></span> 的前提 <span class="inlinecode"><span class="id" title="var">H</span></span>，那么
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[<span class="id" title="var">HA</span></span> <span class="inlinecode"><span class="id" title="var">HB</span>]</span> 将会从上下文中移除 <span class="inlinecode"><span class="id" title="var">H</span></span> 并增加 <span class="inlinecode"><span class="id" title="var">HA</span></span> 和 <span class="inlinecode"><span class="id" title="var">HB</span></span>
    两个新的前提，前者断言 <span class="inlinecode"><span class="id" title="var">A</span></span> 为真，而后者断言 <span class="inlinecode"><span class="id" title="var">B</span></span> 为真。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and_example2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 0 ∧ <span class="id" title="var">m</span> = 0 → <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
和往常一样，我们也可以在引入 <span class="inlinecode"><span class="id" title="var">H</span></span> 的同时对其进行解构，
    而不必先引入然后再解构： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and_example2'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 0 ∧ <span class="id" title="var">m</span> = 0 → <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> [<span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
为什么我们要麻烦地将 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> 这两个前提放一条合取语句中呢？
    完全可以用两条独立的前提来陈述此定理啊： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and_example2''</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 0 → <span class="id" title="var">m</span> = 0 → <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
就此定理而言，两种方式都可以。不过理解如何证明合取前提非常重要，
    因为合取语句通常会在证明的中间步骤中出现，特别是在做大型开发的时候。
    下面是个简单的例子： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and_example3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = 0 → <span class="id" title="var">n</span> × <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <span class="id" title="var">n</span> = 0 ∧ <span class="id" title="var">m</span> = 0).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">and_exercise</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H'</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
另一种经常遇到合取语句的场景是，我们已经知道了 <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">B</span></span>，
    但在某些上下文中只需要 <span class="inlinecode"><span class="id" title="var">A</span></span> 或者 <span class="inlinecode"><span class="id" title="var">B</span></span>。此时以下引理会很有用： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">proj1</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> → <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> [<span class="id" title="var">HP</span> <span class="id" title="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h4 class="section">练习：1 星, standard, optional (proj2)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">proj2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> → <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 最后，我们有时需要重新排列合取语句的顺序，或者对多部分的合取语句进行分组。
    此时使用下面的交换律和结合律会很方便。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">and_commut</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> → <span class="id" title="var">Q</span> ∧ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> [<span class="id" title="var">HP</span> <span class="id" title="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-  <span class="id" title="tactic">apply</span> <span class="id" title="var">HQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-  <span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h4 class="section">练习：2 星, standard (and_assoc)</h4>


<div class="paragraph"> </div>

    （在以下结合律的证明中，注意<i>'嵌套'</i>的 <span class="inlinecode"><span class="id" title="tactic">intros</span></span> 模式是如何将
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode">(<span class="id" title="var">Q</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">R</span>)</span> 拆分为 <span class="inlinecode"><span class="id" title="var">HP</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span>、<span class="inlinecode"><span class="id" title="var">HQ</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> 和 <span class="inlinecode"><span class="id" title="var">HR</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">R</span></span> 的。
    请从那里开始完成证明。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">and_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∧ (<span class="id" title="var">Q</span> ∧ <span class="id" title="var">R</span>) → (<span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span>) ∧ <span class="id" title="var">R</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> [<span class="id" title="var">HP</span> [<span class="id" title="var">HQ</span> <span class="id" title="var">HR</span>]].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 顺便一提，中缀记法 <span class="inlinecode">∧</span> 只是 <span class="inlinecode"><span class="id" title="var">and</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> 的语法糖而已；
    <span class="inlinecode"><span class="id" title="var">and</span></span> 是 Coq 中将两个命题合并成一个命题的运算符。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">and</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab7"></a><h2 class="section">析取</h2>

<div class="paragraph"> </div>

 另一个重要的联结词是_析取_，即两个命题的<i>'逻辑或'</i>：若 <span class="inlinecode"><span class="id" title="var">A</span></span> 或 <span class="inlinecode"><span class="id" title="var">B</span></span>
    二者之一为真，则 <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">B</span></span> 为真。（这中中缀记法表示 <span class="inlinecode"><span class="id" title="var">or</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>，其中
    <span class="inlinecode"><span class="id" title="var">or</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>。） 
<div class="paragraph"> </div>

 为了在证明中使用析取前提，我们需要分类讨论，它与 <span class="inlinecode"><span class="id" title="var">nat</span></span>
    或其它数据类型一样，都可以显示地通过 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 或隐式地通过 <span class="inlinecode"><span class="id" title="tactic">intros</span></span>
    模式来拆分： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">or_example</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 0 ∨ <span class="id" title="var">m</span> = 0 → <span class="id" title="var">n</span> × <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> [<span class="id" title="var">Hn</span> | <span class="id" title="var">Hm</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hm</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">mult_n_O</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
相应地，要证明某个析取命题成立，我们需要证明其任意一边的命题成立。
    我们可以用 <span class="inlinecode"><span class="id" title="tactic">left</span></span> 和 <span class="inlinecode"><span class="id" title="tactic">right</span></span> 策略来选取命题。顾名思义，<span class="inlinecode"><span class="id" title="tactic">left</span></span>
    会选取待析取证命题的左边，而 <span class="inlinecode"><span class="id" title="tactic">right</span></span> 则会选取它的右边。
    下面是一种平凡的用法... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">or_intro</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> → <span class="id" title="var">A</span> ∨ <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">HA</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">left</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">HA</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
...而这个更有趣的例子则同时需要 <span class="inlinecode"><span class="id" title="tactic">left</span></span> 和 <span class="inlinecode"><span class="id" title="tactic">right</span></span>： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">zero_or_succ</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = 0 ∨ <span class="id" title="var">n</span> = <span class="id" title="var">S</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [|<span class="id" title="var">n</span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">right</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab8"></a><h4 class="section">练习：1 星, standard (mult_eq_0)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mult_eq_0</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> × <span class="id" title="var">m</span> = 0 → <span class="id" title="var">n</span> = 0 ∨ <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab9"></a><h4 class="section">练习：1 星, standard (or_commut)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">or_commut</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span>  → <span class="id" title="var">Q</span> ∨ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab10"></a><h2 class="section">假命题与否定</h2>


<div class="paragraph"> </div>

    目前为止，我们主要都在证明某些东西是<i>'真'</i>的：加法满足结合律，
    列表的连接满足结合律，等等。当然，我们也关心<i>'否定'</i>的结果，
    即证明某些给定的命题<i>'不是'</i>真的。在 Coq 中，这样的否定语句使用否定运算符
    <span class="inlinecode">¬</span> 来表达。 
<div class="paragraph"> </div>

 为了理解否定背后的原理，我们需要回想一下<span class="inlinecode"><span class="id" title="var">Tactics</span></span>一章中的<i>'爆炸原理'</i>。
    爆炸原理断言，当我们假设了矛盾存在时，就能推出任何命题。

<div class="paragraph"> </div>

    遵循这一直觉，我们可以可以将 <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="var">P</span></span>（即非 <span class="inlinecode"><span class="id" title="var">P</span></span>）定义为 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">Q</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>。

<div class="paragraph"> </div>

    不过 Coq 选择了稍有些不同（但等价）的做法，它将 <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="var">P</span></span> 定义为 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">False</span></span>，而
    <span class="inlinecode"><span class="id" title="var">False</span></span> 是在标准库中特别定义的矛盾性命题。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyNot</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">not</span> (<span class="id" title="var">P</span>:<span class="id" title="keyword">Prop</span>) := <span class="id" title="var">P</span> → <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;~ x" := (<span class="id" title="var">not</span> <span class="id" title="var">x</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">not</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyNot</span>.<br/>

<br/>
</div>

<div class="doc">
由于 <span class="inlinecode"><span class="id" title="var">False</span></span> 是个矛盾性命题，因此爆炸原理对它也适用。如果我们让 <span class="inlinecode"><span class="id" title="var">False</span></span>
    进入到了证明的上下文中，可以对它使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 来完成任何待证目标。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ex_falso_quodlibet</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span>:<span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">False</span> → <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">contra</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
拉丁文 <i>'ex falso quodlibet'</i> 的字面意思是“从谬误出发，
    你能够证明任何你想要的”，这也是爆炸原理的另一个广为人知的名字。 
<div class="paragraph"> </div>

<a name="lab11"></a><h4 class="section">练习：2 星, standard, optional (not_implies_our_not)</h4>


<div class="paragraph"> </div>

    证明 Coq 对否定的定义蕴含前面提到的直觉上的定义： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fact</span> <span class="id" title="var">not_implies_our_not</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span>:<span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;¬ <span class="id" title="var">P</span> → (<span class="id" title="keyword">∀</span> (<span class="id" title="var">Q</span>:<span class="id" title="keyword">Prop</span>), <span class="id" title="var">P</span> → <span class="id" title="var">Q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 不等性是十分常见的否定句的例子，，它有一个特别的记法 <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" title="var">y</span></span>：

<div class="paragraph"> </div>

      Notation "x &lt;&gt; y" := (~(x = y)).

<div class="paragraph"> </div>

 我们可以用 <span class="inlinecode"><span class="id" title="var">not</span></span> 来陈述 <span class="inlinecode">0</span> 和 <span class="inlinecode">1</span> 是不同的 <span class="inlinecode"><span class="id" title="var">nat</span></span> 元素： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_not_one</span> : 0 ≠ 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
性质 <span class="inlinecode">0</span> <span class="inlinecode">≠</span> <span class="inlinecode">1</span> 就是 <span class="inlinecode">~(0</span> <span class="inlinecode">=</span> <span class="inlinecode">1)</span>，即 <span class="inlinecode"><span class="id" title="var">not</span></span> <span class="inlinecode">(0</span> <span class="inlinecode">=</span> <span class="inlinecode">1)</span>，
      它会展开为 <span class="inlinecode">(0</span> <span class="inlinecode">=</span> <span class="inlinecode">1)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">False</span></span>。（这里显式地用 <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> <span class="inlinecode"><span class="id" title="var">not</span></span>
      展示了这一点，不过一般可以忽略。 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>.<br/>
</div>

<div class="doc">
要证明不等性，我们可以反过来假设其相等... 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">contra</span>.<br/>
</div>

<div class="doc">
... 然后从中推出矛盾。在这里，等式 <span class="inlinecode"><span class="id" title="var">O</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span> 与构造子 <span class="inlinecode"><span class="id" title="var">O</span></span> 和 <span class="inlinecode"><span class="id" title="var">S</span></span>
      的不交性相矛盾，因此用 <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span> 就能解决它。 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">discriminate</span> <span class="id" title="var">contra</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
为了习惯用 Coq 处理否定命题，我们需要一些练习。
    即便你十分清楚为什么某个否定命题成立，但一下就找到让 Coq 理解的方式
    有点棘手。以下常见事实的证明留给你热身。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">not_False</span> :<br/>
&nbsp;&nbsp;¬ <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">contradiction_implies_anything</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> ∧ ¬<span class="id" title="var">P</span>) → <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> [<span class="id" title="var">HP</span> <span class="id" title="var">HNA</span>]. <span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> <span class="id" title="var">HNA</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">HNA</span> <span class="id" title="tactic">in</span> <span class="id" title="var">HP</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">HP</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">double_neg</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> → ~~<span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">G</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">G</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h4 class="section">练习：2 星, advanced (double_neg_inf)</h4>


<div class="paragraph"> </div>

    请写出 <span class="inlinecode"><span class="id" title="var">double_neg</span></span> 的非形式化证明：

<div class="paragraph"> </div>

   <i>'定理'</i>：对于任何命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 而言，<span class="inlinecode"><span class="id" title="var">P</span></span> 蕴含 <span class="inlinecode">~~<span class="id" title="var">P</span></span>。 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">manual_grade_for_double_neg_inf</span> : <span class="id" title="var">option</span> (<span class="id" title="var">nat</span>×<span class="id" title="var">string</span>) := <span class="id" title="var">None</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab13"></a><h4 class="section">练习：2 星, standard, recommended (contrapositive)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">contrapositive</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> → <span class="id" title="var">Q</span>) → (~<span class="id" title="var">Q</span> → ¬<span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab14"></a><h4 class="section">练习：1 星, standard (not_both_true_and_false)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">not_both_true_and_false</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;¬ (<span class="id" title="var">P</span> ∧ ¬<span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab15"></a><h4 class="section">练习：1 星, advanced (informal_not_PNP)</h4>


<div class="paragraph"> </div>

    请写出 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode">~(<span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode">¬<span class="id" title="var">P</span>)</span> 的非形式化证明。 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">manual_grade_for_informal_not_PNP</span> : <span class="id" title="var">option</span> (<span class="id" title="var">nat</span>×<span class="id" title="var">string</span>) := <span class="id" title="var">None</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 类似地，由于不等性包含一个否定，因此在能够熟练地使用它前也需要一些练习。
    这里有个有用的技巧：如果你需要证明某个目标不可能时（例如当前的目标陈述为
    <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>），请使用 <span class="inlinecode"><span class="id" title="var">ex_falso_quodlibet</span></span> 将该目标转换为 <span class="inlinecode"><span class="id" title="var">False</span></span>。
    如果在当前上下文中存在形如 <span class="inlinecode">¬<span class="id" title="var">P</span></span> 的假设（特别是形如 <span class="inlinecode"><span class="id" title="var">x</span>≠<span class="id" title="var">y</span></span> 的假设），
    那么此技巧会让这些假设用起来更容易些。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">not_true_is_false</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">b</span> ≠ <span class="id" title="var">true</span> → <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [] <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ex_falso_quodlibet</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
由于用 <span class="inlinecode"><span class="id" title="var">ex_falso_quodlibet</span></span> 推理十分常用，因此 Coq 提供了内建的策略
    <span class="inlinecode"><span class="id" title="var">exfalso</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">not_true_is_false'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">b</span> ≠ <span class="id" title="var">true</span> → <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [] <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">exfalso</span>. &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h2 class="section">真值</h2>

<div class="paragraph"> </div>

 除 <span class="inlinecode"><span class="id" title="var">False</span></span> 外，Coq 的标准库中还定义了 <span class="inlinecode"><span class="id" title="var">True</span></span>，一个明显真的命题。
    为了证明它，我们使用了预定义的常量 <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">True</span></span>： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">True_is_true</span> : <span class="id" title="var">True</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">I</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
与经常使用的 <span class="inlinecode"><span class="id" title="var">False</span></span> 不同，<span class="inlinecode"><span class="id" title="var">True</span></span> 很少使用，因为它作为证明目标来说过于平凡，
    而作为前提又不携带任何有用的信息。 

<div class="paragraph"> </div>

    然而在使用条件从句定义复杂的 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>，或者作为高阶 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> 的参数时，
    它还是挺有用的。之后我们会看到 <span class="inlinecode"><span class="id" title="var">True</span></span> 的这类用法。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h2 class="section">逻辑等价</h2>

<div class="paragraph"> </div>

 联结词“当且仅当”用起来十分方便，它是两个蕴含式的合取，
    断言了两个命题拥有同样的真值。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">MyIff</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">iff</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) := (<span class="id" title="var">P</span> → <span class="id" title="var">Q</span>) ∧ (<span class="id" title="var">Q</span> → <span class="id" title="var">P</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;P &lt;-&gt; Q" := (<span class="id" title="var">iff</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 95, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MyIff</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">iff_sym</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> ↔ <span class="id" title="var">Q</span>) → (<span class="id" title="var">Q</span> ↔ <span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> [<span class="id" title="var">HAB</span> <span class="id" title="var">HBA</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">apply</span> <span class="id" title="var">HBA</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">apply</span> <span class="id" title="var">HAB</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">not_true_iff_false</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">b</span> ≠ <span class="id" title="var">true</span> ↔ <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">apply</span> <span class="id" title="var">not_true_is_false</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">discriminate</span> <span class="id" title="var">H'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab18"></a><h4 class="section">练习：1 星, standard, optional (iff_properties)</h4>


<div class="paragraph"> </div>

    参照上面对 <span class="inlinecode">↔</span> 对称性（<span class="inlinecode"><span class="id" title="var">iff_sym</span></span>）的证明，
    请证明它同时也有自反性和传递性。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">iff_refl</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ↔ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">iff_trans</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> ↔ <span class="id" title="var">Q</span>) → (<span class="id" title="var">Q</span> ↔ <span class="id" title="var">R</span>) → (<span class="id" title="var">P</span> ↔ <span class="id" title="var">R</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab19"></a><h4 class="section">练习：3 星, standard (or_distributes_over_and)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">or_distributes_over_and</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∨ (<span class="id" title="var">Q</span> ∧ <span class="id" title="var">R</span>) ↔ (<span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span>) ∧ (<span class="id" title="var">P</span> ∨ <span class="id" title="var">R</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Coq 的某些策略会特殊对待 <span class="inlinecode"><span class="id" title="var">iff</span></span> 语句，以此来避免操作某些底层的证明状态。
    特别来说，<span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> 和 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 不仅可以用于相等关系，还可用于
    <span class="inlinecode"><span class="id" title="var">iff</span></span> 语句。为了开启此行为，我们需要导入一个 Coq 的库来支持它： 
</div>
<div class="code">

<br/>
<span class="id" title="var">From</span> <span class="id" title="var">Coq</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Setoids.Setoid</span>.<br/>

<br/>
</div>

<div class="doc">
下面是一个简单的例子，它展示了这些策略如何使用 <span class="inlinecode"><span class="id" title="var">iff</span></span>。
    首先，我们来证明一些基本的 <span class="inlinecode"><span class="id" title="var">iff</span></span> 等价关系命题... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mult_0</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> × <span class="id" title="var">m</span> = 0 ↔ <span class="id" title="var">n</span> = 0 ∨ <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">mult_eq_0</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">or_example</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">or_assoc</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> ∨ (<span class="id" title="var">Q</span> ∨ <span class="id" title="var">R</span>) ↔ (<span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span>) ∨ <span class="id" title="var">R</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">H</span> | [<span class="id" title="var">H</span> | <span class="id" title="var">H</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">left</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">left</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [[<span class="id" title="var">H</span> | <span class="id" title="var">H</span>] | <span class="id" title="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">left</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">right</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">right</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
现在我们可以用这些事实配合 <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> 与 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    对涉及等价关系的陈述给出流畅的证明了。以下是之前 <span class="inlinecode"><span class="id" title="var">mult_0</span></span>
    包含三个变量的版本： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mult_0_3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>, <span class="id" title="var">n</span> × <span class="id" title="var">m</span> × <span class="id" title="var">p</span> = 0 ↔ <span class="id" title="var">n</span> = 0 ∨ <span class="id" title="var">m</span> = 0 ∨ <span class="id" title="var">p</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">mult_0</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">mult_0</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">or_assoc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">apply</span></span> 策略也可以用在 <span class="inlinecode">↔</span> 上。当给定一个等价关系命题作为
    <span class="inlinecode"><span class="id" title="tactic">apply</span></span> 的参数时，它会试图应用正确的方向。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">apply_iff_example</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> × <span class="id" title="var">m</span> = 0 → <span class="id" title="var">n</span> = 0 ∨ <span class="id" title="var">m</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">mult_0</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab20"></a><h2 class="section">存在量化</h2>

<div class="paragraph"> </div>

 <i>'存在量化'</i>也是十分重要的逻辑联结词。我们说存在某个类型为 <span class="inlinecode"><span class="id" title="var">T</span></span>
    的 <span class="inlinecode"><span class="id" title="var">x</span></span>，使得某些性质 <span class="inlinecode"><span class="id" title="var">P</span></span> 对于 <span class="inlinecode"><span class="id" title="var">x</span></span> 成立，写作 <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span>。
    和 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> 一样，如果 Coq 能从上下文中推断出 <span class="inlinecode"><span class="id" title="var">x</span></span> 的类型，那么类型标注
    <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> 就可以省略。
<div class="paragraph"> </div>

 为了证明形如 <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> 的语句，我们必须证明 <span class="inlinecode"><span class="id" title="var">P</span></span> 对于某些特定的
    <span class="inlinecode"><span class="id" title="var">x</span></span> 成立，这些特定的 <span class="inlinecode"><span class="id" title="var">x</span></span> 被称作存在性的<i>'例证'</i>。证明分为两步：
    首先，我们调用 <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> 策略向 Coq 指出已经知道了使 <span class="inlinecode"><span class="id" title="var">P</span></span>
    成立的例证 <span class="inlinecode"><span class="id" title="var">t</span></span>，然后证明将所有出现的 <span class="inlinecode"><span class="id" title="var">x</span></span> 替换成 <span class="inlinecode"><span class="id" title="var">t</span></span> 的命题 <span class="inlinecode"><span class="id" title="var">P</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">four_is_even</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 4 = <span class="id" title="var">n</span> + <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> 2. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
反之，如果我们的的上下文中有形如 <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> 的存在前提，
    可以将其解构得到一个例证 <span class="inlinecode"><span class="id" title="var">x</span></span> 和一个陈述 <span class="inlinecode"><span class="id" title="var">P</span></span> 对于 <span class="inlinecode"><span class="id" title="var">x</span></span> 成立的前提。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">exists_example_2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">∃</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> = 4 + <span class="id" title="var">m</span>) →<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">∃</span> <span class="id" title="var">o</span>, <span class="id" title="var">n</span> = 2 + <span class="id" title="var">o</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">m</span> <span class="id" title="var">Hm</span>]. &nbsp;&nbsp;<span class="id" title="tactic">∃</span> (2 + <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Hm</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab21"></a><h4 class="section">练习：1 星, standard, recommended (dist_not_exists)</h4>


<div class="paragraph"> </div>

    请证明“<span class="inlinecode"><span class="id" title="var">P</span></span> 对所有 <span class="inlinecode"><span class="id" title="var">x</span></span> 成立”蕴含“不存在 <span class="inlinecode"><span class="id" title="var">x</span></span> 使 <span class="inlinecode"><span class="id" title="var">P</span></span> 不成立。”
    （提示：<span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[<span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">E</span>]</span> 可以用于存在假设！） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">dist_not_exists</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>) → ¬ (<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, ¬ <span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab22"></a><h4 class="section">练习：2 星, standard (dist_exists_or)</h4>


<div class="paragraph"> </div>

    请证明存在量化对析取满足分配律。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">dist_exists_or</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> ∨ <span class="id" title="var">Q</span> <span class="id" title="var">x</span>) ↔ (<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>) ∨ (<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">Q</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab23"></a><h1 class="section">使用命题编程</h1>

<div class="paragraph"> </div>

 我们学过的逻辑联结词为我们提供了丰富的用简单命题构造复杂命题的词汇。
    为了说明，我们来看一下如何表达“元素 <span class="inlinecode"><span class="id" title="var">x</span></span> 出现在列表 <span class="inlinecode"><span class="id" title="var">l</span></span> 中”这一断言。
    注意此性质有着简单的递归结构： 

<div class="paragraph"> </div>

<ul class="doclist">
<li> 若 <span class="inlinecode"><span class="id" title="var">l</span></span> 为空列表，则 <span class="inlinecode"><span class="id" title="var">x</span></span> 无法在其中出现，因此性质“<span class="inlinecode"><span class="id" title="var">x</span></span> 出现在 <span class="inlinecode"><span class="id" title="var">l</span></span> 中”
         为假。 

<div class="paragraph"> </div>


</li>
<li> 否则，若 <span class="inlinecode"><span class="id" title="var">l</span></span> 的形式为 <span class="inlinecode"><span class="id" title="var">x'</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">l'</span></span>，此时 <span class="inlinecode"><span class="id" title="var">x</span></span> 是否出现在 <span class="inlinecode"><span class="id" title="var">l</span></span> 中，
         取决于它是否等于 <span class="inlinecode"><span class="id" title="var">x'</span></span> 或出现在 <span class="inlinecode"><span class="id" title="var">l'</span></span> 中。 
</li>
</ul>

<div class="paragraph"> </div>

 我们可以将此定义直接翻译成递归函数，它接受一个元素和一个列表，
    返回一个命题： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">In</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" title="var">False</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">x'</span> :: <span class="id" title="var">l'</span> ⇒ <span class="id" title="var">x'</span> = <span class="id" title="var">x</span> ∨ <span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">l'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
当 <span class="inlinecode"><span class="id" title="var">In</span></span> 应用于具体的列表时，它会被展开为一系列具体的析取式。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">In_example_1</span> : <span class="id" title="var">In</span> 4 [1; 2; 3; 4; 5].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">In_example_2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">In</span> <span class="id" title="var">n</span> [2; 4] →<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">n'</span>, <span class="id" title="var">n</span> = 2 × <span class="id" title="var">n'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">H</span> | [<span class="id" title="var">H</span> | []]].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">∃</span> 1. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">∃</span> 2. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
（注意我们用空模式<i>'无视'</i>了最后一种情况。） 
<div class="paragraph"> </div>

 我们也可证明关于 <span class="inlinecode"><span class="id" title="var">In</span></span> 的更一般，更高阶的引理。

<div class="paragraph"> </div>

    注意，接下来会 <span class="inlinecode"><span class="id" title="var">In</span></span> 被应用到一个变量上，只有当我们对它进行分类讨论时，
    它才会被展开： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">In_map</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">In</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">x'</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> [].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> [<span class="id" title="var">H</span> | <span class="id" title="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
虽然递归定义命题在某些情况下会很方便，但这种方式也有其劣势。特别是，
    这类命题会受到 Coq 对递归函数要求的限制，例如，在 Coq 中递归函数必须是
    “明显会终止”的。在下一章中，我们会了解如何<i>'归纳地'</i>定义命题，
    这是一种与之不同的技巧，有着其独特的优势和限制。 
<div class="paragraph"> </div>

<a name="lab24"></a><h4 class="section">练习：2 星, standard (In_map_iff)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">In_map_iff</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">y</span> : <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">y</span> (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span>) ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span> ∧ <span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab25"></a><h4 class="section">练习：2 星, standard (In_app_iff)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">In_app_iff</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">l</span> <span class="id" title="var">l'</span> (<span class="id" title="var">a</span>:<span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">a</span> (<span class="id" title="var">l</span>++<span class="id" title="var">l'</span>) ↔ <span class="id" title="var">In</span> <span class="id" title="var">a</span> <span class="id" title="var">l</span> ∨ <span class="id" title="var">In</span> <span class="id" title="var">a</span> <span class="id" title="var">l'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab26"></a><h4 class="section">练习：3 星, standard, recommended (All)</h4>


<div class="paragraph"> </div>

    回忆一下，返回命题的函数可以视作对其参数<i>'性质'</i>的定义。例如，若
    <span class="inlinecode"><span class="id" title="var">P</span></span> 的类型为 <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>，那么 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 就陈述了性质 <span class="inlinecode"><span class="id" title="var">P</span></span> 对 <span class="inlinecode"><span class="id" title="var">n</span></span> 成立。

<div class="paragraph"> </div>

    以 <span class="inlinecode"><span class="id" title="var">In</span></span> 作为参考，请写出递归函数 <span class="inlinecode"><span class="id" title="keyword">All</span></span>，它陈述某个 <span class="inlinecode"><span class="id" title="var">P</span></span> 对列表 <span class="inlinecode"><span class="id" title="var">l</span></span>
    中的所有元素成立。为了确定你的定义是正确的，请在下方证明 <span class="inlinecode"><span class="id" title="var">All_In</span></span> 引理。
    （当然，你的定义<i>'不应该'</i>为了通过测试就把 <span class="inlinecode"><span class="id" title="var">All_In</span></span> 的左边复述一遍。 ） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="keyword">All</span> {<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">T</span> → <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">All_In</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> (<span class="id" title="var">P</span> : <span class="id" title="var">T</span> → <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> → <span class="id" title="var">P</span> <span class="id" title="var">x</span>) ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">All</span> <span class="id" title="var">P</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab27"></a><h4 class="section">练习：3 星, standard (combine_odd_even)</h4>


<div class="paragraph"> </div>

    完成以下 <span class="inlinecode"><span class="id" title="var">combine_odd_even</span></span> 函数的定义。它接受两个对数字成立的性质
    <span class="inlinecode"><span class="id" title="var">Podd</span></span> 与 <span class="inlinecode"><span class="id" title="var">Peven</span></span>，返回性质 <span class="inlinecode"><span class="id" title="var">P</span></span> 使得当 <span class="inlinecode"><span class="id" title="var">n</span></span> 为奇数时 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 等价于 <span class="inlinecode"><span class="id" title="var">Podd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>，
    否则等价于 <span class="inlinecode"><span class="id" title="var">Peven</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">combine_odd_even</span> (<span class="id" title="var">Podd</span> <span class="id" title="var">Peven</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
为了测试你的定义，请证明以下事实： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">combine_odd_even_intro</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">Podd</span> <span class="id" title="var">Peven</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">oddb</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> → <span class="id" title="var">Podd</span> <span class="id" title="var">n</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">oddb</span> <span class="id" title="var">n</span> = <span class="id" title="var">false</span> → <span class="id" title="var">Peven</span> <span class="id" title="var">n</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">combine_odd_even</span> <span class="id" title="var">Podd</span> <span class="id" title="var">Peven</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">combine_odd_even_elim_odd</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">Podd</span> <span class="id" title="var">Peven</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">combine_odd_even</span> <span class="id" title="var">Podd</span> <span class="id" title="var">Peven</span> <span class="id" title="var">n</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">oddb</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Podd</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">combine_odd_even_elim_even</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">Podd</span> <span class="id" title="var">Peven</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">combine_odd_even</span> <span class="id" title="var">Podd</span> <span class="id" title="var">Peven</span> <span class="id" title="var">n</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">oddb</span> <span class="id" title="var">n</span> = <span class="id" title="var">false</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Peven</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab28"></a><h1 class="section">对参数应用定理</h1>

<div class="paragraph"> </div>

 Coq 拥有一个不同于其它的证明助理（如 ACL2 和 Isabelle）的特性，
    即它将<i>'证明'</i>本身也作为一等对象。

<div class="paragraph"> </div>

    关于这一点有很多地方值得着墨，不过了解所有的细节对于使用 Coq 来说不是必须的。
    本节点到为止，深入的探讨参见 <span class="inlinecode"><span class="id" title="var">ProofObjects</span></span> 和 <span class="inlinecode"><span class="id" title="var">IndPrinciples</span></span>。 
<div class="paragraph"> </div>

 我们已经知道 <span class="inlinecode"><span class="id" title="keyword">Check</span></span> 可以用来显式表达式的类型了，
    不过它还可以用来查找某个标识符所指代的定理。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">plus_comm</span>.<br/>

<br/>
</div>

<div class="doc">
在显示对定理 <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> 的<i>'陈述'</i>时，Coq 使用了与显示某项的<i>'类型'</i>一样的方式。
    这是为什么？ 
<div class="paragraph"> </div>

 原因在于标识符 <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> 其实指代的是被称作<i>'证明对象'</i>的数据结构，
    它表示在命题 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> 的真实性上建立的逻辑推导。
    此对象的类型<i>'就是'</i>其所证命题的陈述。 
<div class="paragraph"> </div>

 从直觉上来说，这很有道理，因为对定理的陈述说明了该定理可用来做什么，
    正如可计算对象的类型告诉了我们可以对它做什么。例如，若我们有一个类型为
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 的项，就可以给它两个 <span class="inlinecode"><span class="id" title="var">nat</span></span> 作为参数并得到一个 <span class="inlinecode"><span class="id" title="var">nat</span></span>。
    类似地，如果我们有一个类型为 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 的对象，
    就能为它提供一个类型为 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 的“参数”并推导出 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>。 
<div class="paragraph"> </div>

 从操作上来说，这种类比可以更进一步：由于定理可以作为函数应用到对应类型的前提上，
    我们就可以直接产生结论而不必使用中间出现的 <span class="inlinecode"><span class="id" title="tactic">assert</span></span> 了。例如，假设我们想要证明以下结论： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">x</span> + (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>) = (<span class="id" title="var">z</span> + <span class="id" title="var">y</span>) + <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
乍看起来，我们似乎可以用 <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> 改写两次使两边匹配来证明它。
    然而问题是，第二次 <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> 会抵消第一次的效果。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
利用我们已知的工具，修复它的一种简单方法是使用 <span class="inlinecode"><span class="id" title="tactic">assert</span></span> 导出一个
    <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> 的特殊版本，这样我们就能用它按照预期来改写。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm3_take2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">x</span> + (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>) = (<span class="id" title="var">z</span> + <span class="id" title="var">y</span>) + <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">y</span> + <span class="id" title="var">z</span> = <span class="id" title="var">z</span> + <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>. <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
一种更优雅的方式是直接把我们想要实例化的参数应用到 <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> 上，
    正如我们将一个多态函数应用到类型参数上那样。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm3_take3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">x</span> + (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>) = (<span class="id" title="var">z</span> + <span class="id" title="var">y</span>) + <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们来展示另一个像函数那样使用定理或引理的例子。以下定理说明：
    任何包含元素的列表 <span class="inlinecode"><span class="id" title="var">l</span></span> 一定非空。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">Hl</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">l</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">Hl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
有趣的地方是一个量化的变量（<span class="inlinecode"><span class="id" title="var">x</span></span>）没有出现在结论（<span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">≠</span> <span class="inlinecode">[]</span>）中。 
<div class="paragraph"> </div>

 我们可以用此引理来证明 <span class="inlinecode"><span class="id" title="var">x</span></span> 为 <span class="inlinecode">42</span> 的特殊情况。直接用 <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">in_not_nil</span></span>
    会失败，因为它无法推出 <span class="inlinecode"><span class="id" title="var">x</span></span> 的值。有一些方法可以绕开它... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">in_not_nil</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42_take2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">in_not_nil</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span> := 42).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42_take3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">in_not_nil</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42_take4</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">in_not_nil</span> <span class="id" title="var">nat</span> 42).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42_take5</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">in_not_nil</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
对于几乎所有将定理名作为参数的策略而言，你都可以“将定理作为函数”来使用。
    注意，定理应用与函数应用使用了同样的类型推导机制，所以你可以将通配符作为定理的参数，
    或者为定理声明默认的隐式前提。这些特性在以下证明中展示。（此证明如何工作的细节
    不必关心，这里的目标只是为了展示它的用途。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">lemma_application_ex</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} {<span class="id" title="var">ns</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">n</span> (<span class="id" title="var">map</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> ⇒ <span class="id" title="var">m</span> × 0) <span class="id" title="var">ns</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">ns</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">proj1</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">In_map_iff</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> [<span class="id" title="var">m</span> [<span class="id" title="var">Hm</span> <span class="id" title="var">_</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">mult_0_r</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hm</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Hm</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
在以后的章节中我们将会看到更多这方面的例子。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab29"></a><h1 class="section">Coq vs. 集合论</h1>

<div class="paragraph"> </div>

 Coq 的逻辑核心，即<i>'归纳构造演算（Calculus of Inductive Constructions）'</i>系统，
    在很多重要的方面不同于数学家用来写下精确而严谨的证明的形式化系统。
    例如，在主流的纸笔数学家中使用最普遍的<i>'策梅洛-弗兰克尔集合论（ZFC）'</i>中，
    一个数学对象可同时属于不同的集合；而在 Coq 的逻辑中，一个项最多只属于一个类型。
    这些不同之处需要人们用稍微不同的方式来描述非形式化的数学概念，但总的来说，
    它们都是非常自然而易于使用的。例如，在 Coq 中我们一般不说某个自然数 <span class="inlinecode"><span class="id" title="var">n</span></span>
    属于偶数集合，而是说 <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 成立，其中的 <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> 描述了偶数的性质。

<div class="paragraph"> </div>

    然而在某些情况下，将标准的数学论证翻译到 Coq 中会十分繁琐甚至是不可能的，
    除非我们引入新的公理来丰富其逻辑核心。作为本章的结尾，
    我们将探讨这两个世界之间最显著的区别。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab30"></a><h2 class="section">函数的外延性</h2>

<div class="paragraph"> </div>

 目前为止我们所看见的相等关系断言基本上都只考虑了归纳类型的元素
    （如 <span class="inlinecode"><span class="id" title="var">nat</span></span>、<span class="inlinecode"><span class="id" title="var">bool</span></span> 等等）。然而由于 Coq 的相等关系运算符是多态的，
    因此它们并不是唯一的可能。特别是，我们可以写出宣称<i>'两个函数相等'</i>的命题： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">function_equality_ex1</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ 3 + <span class="id" title="var">x</span>) = (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ (<span class="id" title="var">pred</span> 4) + <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
在一般的数学研究中，对于任意的两个函数 <span class="inlinecode"><span class="id" title="var">f</span></span> 和 <span class="inlinecode"><span class="id" title="var">g</span></span>，只要它们产生的结果相等，
    那么它们就被认为相等：

<div class="paragraph"> </div>

    (forall x, f x = g x) -&gt; f = g

<div class="paragraph"> </div>

    这被称作<i>'函数的外延性原理'</i>。 
<div class="paragraph"> </div>

 不甚严谨地说，所谓“外延性”是指某个对象可观察到的行为。
    因此，函数的外延性就是指函数的标识完全由其行为来决定。
    用 Coq 的术语来说，就是函数的身份视其被应用后的结果而定。 
<div class="paragraph"> </div>

 函数的外延性并不在 Coq 的基本公理之内，因此某些“合理”的命题是不可证明的： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">function_equality_ex2</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">plus</span> <span class="id" title="var">x</span> 1) = (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">plus</span> 1 <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
然而，我们可以用 <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> 指令将函数的外延性添加到 Coq 的核心逻辑系统中。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">functional_extensionality</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span>: <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">X</span> → <span class="id" title="var">Y</span>},<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span>:<span class="id" title="var">X</span>), <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">x</span>) → <span class="id" title="var">f</span> = <span class="id" title="var">g</span>.<br/>

<br/>
</div>

<div class="doc">
使用 <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> 的效果与陈述一个定理并用 <span class="inlinecode"><span class="id" title="var">Admitted</span></span> 跳过其证明相同，
    不过它会提醒读者这是一个公理，我们无需证明！
<div class="paragraph"> </div>

 现在我们可以在证明中调用函数的外延性了： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">function_equality_ex2</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">plus</span> <span class="id" title="var">x</span> 1) = (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">plus</span> 1 <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">plus_comm</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
当然，在为 Coq 添加公理时必须十分小心，因为这有可能会导致系统
    <i>'不一致'</i>，而当系统不一致的，任何命题都能在其中证明，包括 <span class="inlinecode"><span class="id" title="var">False</span></span>
    和 <span class="inlinecode">2+2=5</span>！

<div class="paragraph"> </div>

    不幸的是，并没有一种简单的方式能够判断添加某条公理是否安全：
    一般来说，确认任何一组公理的一致性都需要训练有素的专家付出艰辛的努力。

<div class="paragraph"> </div>

    然而，我们已经知道了添加函数外延性后的公理系统<i>'确实是'</i>一致的。 
<div class="paragraph"> </div>

 我们可以用 <span class="inlinecode"><span class="id" title="keyword">Print</span></span> <span class="inlinecode"><span class="id" title="keyword">Assumptions</span></span> 指令查看某个证明依赖的所有附加公理。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="keyword">Assumptions</span> <span class="id" title="var">function_equality_ex2</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab31"></a><h4 class="section">练习：4 星, standard (tr_rev_correct)</h4>


<div class="paragraph"> </div>

    列表反转函数 <span class="inlinecode"><span class="id" title="var">rev</span></span> 的定义有一个问题，它会在每一步都执行一次 <span class="inlinecode"><span class="id" title="var">app</span></span>
    调用，而运行 <span class="inlinecode"><span class="id" title="var">app</span></span> 所需时间与列表的大小线性渐近，也就是说 <span class="inlinecode"><span class="id" title="var">rev</span></span>
    的时间复杂度与列表长度成平方关系。我们可以用以下定义来改进它： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">rev_append</span> {<span class="id" title="var">X</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) : <span class="id" title="var">list</span> <span class="id" title="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">x</span> :: <span class="id" title="var">l1'</span> ⇒ <span class="id" title="var">rev_append</span> <span class="id" title="var">l1'</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">l2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tr_rev</span> {<span class="id" title="var">X</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) : <span class="id" title="var">list</span> <span class="id" title="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">rev_append</span> <span class="id" title="var">l</span> [].<br/>

<br/>
</div>

<div class="doc">
此版本是<i>'尾递归的'</i>，因为对函数自身的递归调用是需要执行的最后一步操作
    （即，在递归调用之后我们并不执行  <span class="inlinecode">++</span> ）。
    一个足够好的编译器会对此生成十分高效的代码。请证明以下两个定义等价。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">tr_rev_correct</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">X</span>, @<span class="id" title="var">tr_rev</span> <span class="id" title="var">X</span> = @<span class="id" title="var">rev</span> <span class="id" title="var">X</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab32"></a><h2 class="section">命题与布尔值</h2>

<div class="paragraph"> </div>

 我们已经知道在 Coq 中有两种编码逻辑事实的方式了，即使用<i>'布尔值'</i>
    （类型为 <span class="inlinecode"><span class="id" title="var">bool</span></span>）和<i>'命题'</i>（类型为 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>）。

<div class="paragraph"> </div>

    例如，我们可以通过以下两种方式来断言 <span class="inlinecode"><span class="id" title="var">n</span></span> 为偶数： 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 求值为 <span class="inlinecode"><span class="id" title="var">true</span></span>： 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">even_42_bool</span> : <span class="id" title="var">evenb</span> 42 = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
或者存在某个 <span class="inlinecode"><span class="id" title="var">k</span></span> 使得 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>： 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">even_42_prop</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>, 42 = <span class="id" title="var">double</span> <span class="id" title="var">k</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">∃</span> 21. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
当然，如果二者刻画的偶数性描述的不是同一个自然数集合，那么会非常奇怪！
    幸运的是，我们确实可以证明二者相同... 
<div class="paragraph"> </div>

 首先我们需要两个辅助引理。 
</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evenb_double</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">k</span>, <span class="id" title="var">evenb</span> (<span class="id" title="var">double</span> <span class="id" title="var">k</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">k</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">k'</span> <span class="id" title="var">IHk'</span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHk'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab33"></a><h4 class="section">练习：3 星, standard (evenb_double_conv)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evenb_double_conv</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>, <span class="id" title="var">n</span> = <span class="id" title="keyword">if</span> <span class="id" title="var">evenb</span> <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">double</span> <span class="id" title="var">k</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">S</span> (<span class="id" title="var">double</span> <span class="id" title="var">k</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_bool_prop</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">evenb</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> ↔ <span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>, <span class="id" title="var">n</span> = <span class="id" title="var">double</span> <span class="id" title="var">k</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">evenb_double_conv</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">Hk</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hk</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">k</span> <span class="id" title="var">Hk</span>]. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hk</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">evenb_double</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
此定理说明，逻辑命题 <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span> 的真伪对应布尔计算 <span class="inlinecode"><span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    的真值。 
<div class="paragraph"> </div>

 类似地，以下两种 <span class="inlinecode"><span class="id" title="var">n</span></span> 与 <span class="inlinecode"><span class="id" title="var">m</span></span> 相等的表述等价：
<ul class="doclist">
<li> (1) <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 值为 <span class="inlinecode"><span class="id" title="var">true</span></span>；

</li>
<li> (2) <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>。

</li>
</ul>
    同样，二者的记法也等价。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eqb_eq</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n1</span> =? <span class="id" title="var">n2</span> = <span class="id" title="var">true</span> ↔ <span class="id" title="var">n1</span> = <span class="id" title="var">n2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">eqb_true</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">eqb_refl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
然而，即便布尔值和某个断言的命题式在逻辑上是等价的，但它们在<i>'操作上'</i>
    也可能不一样。 
<div class="paragraph"> </div>

 在前面的偶数例子中，证明 <span class="inlinecode"><span class="id" title="var">even_bool_prop</span></span> 的反向部分（即
    <span class="inlinecode"><span class="id" title="var">evenb_double</span></span>，从命题到布尔表达式的方向）时，我们对
    <span class="inlinecode"><span class="id" title="var">k</span></span> 进行了简单的归纳。而反方向的证明（即练习 <span class="inlinecode"><span class="id" title="var">evenb_double_conv</span></span>）
    则需要一种聪明的一般化方法，因为我们无法直接证明
    <span class="inlinecode">(<span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>。 
<div class="paragraph"> </div>

 对于这些例子来说，命题式的声明比与之对应的布尔表达式要更为有用，
    但并非总是如此。例如，我们无法在函数的定义中测试一般的命题是否为真，
    因此以下代码片段会被拒绝： 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">is_even_prime</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> = 2 <span class="id" title="keyword">then</span> <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">false</span>.<br/>

<br/>
</div>

<div class="doc">
Coq 会抱怨 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> 的类型是 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>，而它想要一个 <span class="inlinecode"><span class="id" title="var">bool</span></span>
    类型的元素（或其它带有两个元素的归纳类型）。此错误信息的原因与 Coq
    核心语言的<i>'计算性'</i>特质有关，即它能表达的所有函数都是可计算且完全的。
    这样设计的的原因之一是为了能从 Coq 开发的代码中提取出可执行程序。
    因此，在 Coq 中 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <i>'并没有'</i>一种通用的情况分析操作来确定
    任意给定的命题是否为真，一旦存在这种操作，我们就能写出不可计算的函数。

<div class="paragraph"> </div>

    尽管一般的不可计算性质无法表述为布尔计算，但值得注意的是，很多
    <i>'可计算的'</i>性质更容易通过 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> 而非 <span class="inlinecode"><span class="id" title="var">bool</span></span> 来表达，因为在 Coq
    中定义递归函数中会受到很大的限制。例如，下一章会展示如何用 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    来定义“某个正则表达式可以匹配给定的字符串”这一性质。如果使用
    <span class="inlinecode"><span class="id" title="var">bool</span></span> 来定义，就需要写一个真正的正则表达式匹配器了，这样会更加复杂，
    更难以理解，也更难以对它进行推理。

<div class="paragraph"> </div>

    另一方面，通过布尔值来陈述事实会带来一点重要的优势，即通过对 Coq
    中的项进行计算可以实现一些自动推理，这种技术被称为<i>'互映证明（Proof
    by Reflection）'</i>。考虑以下陈述： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">even_1000</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>, 1000 = <span class="id" title="var">double</span> <span class="id" title="var">k</span>.<br/>

<br/>
</div>

<div class="doc">
对此命题而言，最直接的证明方式就是直接给出 <span class="inlinecode"><span class="id" title="var">k</span></span> 的值。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">∃</span> 500. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
而使用与之对应的布尔语句的证明则更加简单： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">even_1000'</span> : <span class="id" title="var">evenb</span> 1000 = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
有趣的是，由于这两种定义是等价的，因此我们无需显式地给出 500，
    而是使用布尔等价式来证明彼此： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">even_1000''</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>, 1000 = <span class="id" title="var">double</span> <span class="id" title="var">k</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">even_bool_prop</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
尽管此例的证明脚本的长度并未因此而减少，然而更大的证明通常可通过
    这种互映的方式来显著化简。举一个极端的例子，在用 Coq 证明著名的
    <i>'四色定理'</i>时，人们使用互映技巧将几百种不同的情况归约成了一个布尔计算。 
<div class="paragraph"> </div>

 另一点明显的不同是“布尔事实”的否定可以被直白地陈述并证明，
    只需翻转预期的布尔值结果即可。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">not_even_1001</span> : <span class="id" title="var">evenb</span> 1001 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
相反，命题的否定形式可能更难以掌握。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">not_even_1001'</span> : ~(<span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>, 1001 = <span class="id" title="var">double</span> <span class="id" title="var">k</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">even_bool_prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">discriminate</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
相等性补充了另一个例子。在涉及 <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">m</span></span> 的证明中，知道 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>
    通常没什么直接的帮助。然而如果我们将该语句转换为等价的 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 形式，
    则可利用该等式改写证明目标。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_eqb_example</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> =? <span class="id" title="var">m</span> = <span class="id" title="var">true</span> → <span class="id" title="var">n</span> + <span class="id" title="var">p</span> =? <span class="id" title="var">m</span> + <span class="id" title="var">p</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_eq</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_eq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们不会详细地介绍互映技巧，然而对于展示布尔计算与一般命题的互补优势而言，
    它是个很好的例子。 
<div class="paragraph"> </div>

<a name="lab34"></a><h4 class="section">练习：2 星, standard (logical_connectives)</h4>


<div class="paragraph"> </div>

    以下引理将本章中讨论的命题联结词与对应的布尔操作关联了起来。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_true_iff</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>:<span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">b1</span> &amp;&amp; <span class="id" title="var">b2</span> = <span class="id" title="var">true</span> ↔ <span class="id" title="var">b1</span> = <span class="id" title="var">true</span> ∧ <span class="id" title="var">b2</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_true_iff</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">b1</span> || <span class="id" title="var">b2</span> = <span class="id" title="var">true</span> ↔ <span class="id" title="var">b1</span> = <span class="id" title="var">true</span> ∨ <span class="id" title="var">b2</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab35"></a><h4 class="section">练习：1 星, standard (eqb_neq)</h4>


<div class="paragraph"> </div>

    以下定理为等价式 <span class="inlinecode"><span class="id" title="var">eqb_eq</span></span> 的“否定”版本，
    在某些场景中使用它会更方便些（后面的章节中会讲到这方面的例子）。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eqb_neq</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">x</span> =? <span class="id" title="var">y</span> = <span class="id" title="var">false</span> ↔ <span class="id" title="var">x</span> ≠ <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab36"></a><h4 class="section">练习：3 星, standard (eqb_list)</h4>


<div class="paragraph"> </div>

    给定一个用于测试类型为 <span class="inlinecode"><span class="id" title="var">A</span></span> 的元素相等关系的布尔操作符 <span class="inlinecode"><span class="id" title="var">eqb</span></span>，
    我们可以定义函数 <span class="inlinecode"><span class="id" title="var">eqb_list</span></span> 来测试元素类型为 <span class="inlinecode"><span class="id" title="var">A</span></span> 的列表的相等关系。
    请完成以下 <span class="inlinecode"><span class="id" title="var">eqb_list</span></span> 函数的定义。要确定你的定义是否正确，请证明引理
    <span class="inlinecode"><span class="id" title="var">eqb_list_true_iff</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">eqb_list</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">eqb</span> : <span class="id" title="var">A</span> → <span class="id" title="var">A</span> → <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eqb_list_true_iff</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> (<span class="id" title="var">eqb</span> : <span class="id" title="var">A</span> → <span class="id" title="var">A</span> → <span class="id" title="var">bool</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">a1</span> <span class="id" title="var">a2</span>, <span class="id" title="var">eqb</span> <span class="id" title="var">a1</span> <span class="id" title="var">a2</span> = <span class="id" title="var">true</span> ↔ <span class="id" title="var">a1</span> = <span class="id" title="var">a2</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>, <span class="id" title="var">eqb_list</span> <span class="id" title="var">eqb</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> = <span class="id" title="var">true</span> ↔ <span class="id" title="var">l1</span> = <span class="id" title="var">l2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab37"></a><h4 class="section">练习：2 星, standard, recommended (All_forallb)</h4>


<div class="paragraph"> </div>

    回忆一下<span class="inlinecode"><span class="id" title="var">Tactics</span></span>一章中练习 <span class="inlinecode"><span class="id" title="var">forall_exists_challenge</span></span> 的函数
    <span class="inlinecode"><span class="id" title="var">forallb</span></span>： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">forallb</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">test</span> : <span class="id" title="var">X</span> → <span class="id" title="var">bool</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">x</span> :: <span class="id" title="var">l'</span> ⇒ <span class="id" title="var">andb</span> (<span class="id" title="var">test</span> <span class="id" title="var">x</span>) (<span class="id" title="var">forallb</span> <span class="id" title="var">test</span> <span class="id" title="var">l'</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
请证明以下定理，它将 <span class="inlinecode"><span class="id" title="var">forallb</span></span> 与之前练习中 <span class="inlinecode"><span class="id" title="keyword">All</span></span> 的性质关联了起来。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">forallb_true_iff</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">X</span> <span class="id" title="var">test</span> (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">forallb</span> <span class="id" title="var">test</span> <span class="id" title="var">l</span> = <span class="id" title="var">true</span> ↔ <span class="id" title="keyword">All</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">test</span> <span class="id" title="var">x</span> = <span class="id" title="var">true</span>) <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
函数 <span class="inlinecode"><span class="id" title="var">forallb</span></span> 是否还存在尚未被此规范捕获的重要性质？ 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab38"></a><h2 class="section">经典逻辑 vs. 构造逻辑</h2>

<div class="paragraph"> </div>

 我们已经知道了，在定义 Coq 函数时是无法判断命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 是否成立。
    然而<i>'证明'</i>也存在类似的限制！换句话说，以下推理原则即便符合直觉，
    不过在 Coq 中它是不可证明的： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">excluded_middle</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∨ ¬ <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
为了在操作上理解为何如此, 回忆一下，在证明形如 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>
    的陈述时，我们使用了 <span class="inlinecode"><span class="id" title="tactic">left</span></span> 与 <span class="inlinecode"><span class="id" title="tactic">right</span></span> 策略，它们能够有效地知道析取的哪边成立。
    然而在 <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span> 中，<span class="inlinecode"><span class="id" title="var">P</span></span> 是被全称量化的<i>'任意'</i>命题，我们对它一无所知。
    我们没有足够的信息来选择使用 <span class="inlinecode"><span class="id" title="tactic">left</span></span> 或 <span class="inlinecode"><span class="id" title="tactic">right</span></span> 中的哪一个。就像 Coq
    因为缺乏信息而无法在函数内部机械地确定 <span class="inlinecode"><span class="id" title="var">P</span></span> 是否成立一样。 
<div class="paragraph"> </div>

 然而，如果我们恰好知道 <span class="inlinecode"><span class="id" title="var">P</span></span> 与某个布尔项互映，那么就能很轻易地知道它是否成立了：
    我们只需检查 <span class="inlinecode"><span class="id" title="var">b</span></span> 的值即可。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">restricted_excluded_middle</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> ↔ <span class="id" title="var">b</span> = <span class="id" title="var">true</span>) → <span class="id" title="var">P</span> ∨ ¬ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> [] <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">left</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">right</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">discriminate</span> <span class="id" title="var">contra</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
特别来说，对于自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">m</span></span> 的 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 而言，排中律是成立的。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">restricted_excluded_middle_eq</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> ∨ <span class="id" title="var">n</span> ≠ <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">restricted_excluded_middle</span> (<span class="id" title="var">n</span> = <span class="id" title="var">m</span>) (<span class="id" title="var">n</span> =? <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eqb_eq</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
通用的排中律默认在 Coq 中并不可用，这一点或许很奇怪，毕竟，
    任何给定的断言都是非真即假的。尽管如此，不假设排中律的成立仍有其有限：
    Coq 中的陈述可以构造出比标准数学中同样陈述更强的断言。特别是，
    如果存在 <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> 的 Coq 证明，那么我们就能直接给出一个使 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>
    得证的值 <span class="inlinecode"><span class="id" title="var">x</span></span>。换言之，任何关于存在性的证明必定是<i>'构造性'</i>的。 
<div class="paragraph"> </div>

 像 Coq 一样不假设排中律成立的逻辑系统被称作<i>'构造逻辑'</i>。

<div class="paragraph"> </div>

    像 ZFC 这样更加传统的，排中律对于任何命题都成立的逻辑系统则被称作<i>'经典逻辑'</i>。 
<div class="paragraph"> </div>

 以下示例展示了为何假设排中律成立会导致非构造性证明：

<div class="paragraph"> </div>

    <i>'命题'</i>：存在无理数 <span class="inlinecode"><span class="id" title="var">a</span></span> 和 <span class="inlinecode"><span class="id" title="var">b</span></span> 使得 <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">b</span></span> 为有理数。

<div class="paragraph"> </div>

    <i>'证明'</i>：易知 <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> 为无理数。若 <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> 为有理数，
    那么可以取 <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> 证明结束；否则 <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> 为无理数。
    此时，我们可以取 <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> 和 <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span>，因为
    <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode">(<span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>.  <font size=-2>&#9744;</font>

<div class="paragraph"> </div>

    看到发生什么了吗？我们使用排中律在不知道 <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span>
    是否为有理数的情况下就分别考虑了这两种情况！因此，我们知道了这样的
    <span class="inlinecode"><span class="id" title="var">a</span></span> 和 <span class="inlinecode"><span class="id" title="var">b</span></span> 存在，但却无法确切知道它们的值（至少使用此论据来说如此）。

<div class="paragraph"> </div>

    即便构造逻辑很有用，它也有自身的限制：存在很多容易用经典逻辑证明的命题，
    用构造证明会更加复杂，而对于某些已知的命题而言这样的构造性证明甚至不存在！
    幸运的是，排中律和函数外延性一样都是与 Coq 的逻辑系统兼容的，
    我们可以安全地将它作为公理添加到 Coq 中。然而，在本书中我们不必如此：
    我们所涉及的结构都可以完全用构造逻辑得到，所需的额外代价则微不足道。

<div class="paragraph"> </div>

    我们需要一定的实践才能理解哪些证明技巧不应在构造推理中使用，
    而其中的反证法尤为臭名昭著，因为它会导向非构造性证明。这里有个典型的例子：
    假设我们想要证明存在 <span class="inlinecode"><span class="id" title="var">x</span></span> 具有某种性质 <span class="inlinecode"><span class="id" title="var">P</span></span>，即存在 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>。我们先假设结论为假，
    也就是说 <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>。根据此前提，不难推出 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>。
    如果我们能够根据此中间事实得到矛盾，就能得到一个存在性证明而完全不必指出一个
    <span class="inlinecode"><span class="id" title="var">x</span></span> 的值使得 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> 成立！

<div class="paragraph"> </div>

    从构造性的角度来看，这里存在着技术上的瑕疵，即我们试图通过对
    <span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> 的证明来证明 <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>。从以下练习中我们会看到，
    允许自己从任意陈述中去掉双重否定等价于引入排中律。因此，只要我们不引入排中律，
    就无法在 Coq 中编码此推理。 
<div class="paragraph"> </div>

<a name="lab39"></a><h4 class="section">练习：3 星, standard (excluded_middle_irrefutable)</h4>


<div class="paragraph"> </div>

    证明通用排中律公理与 Coq 的一致性需要复杂的推理，而且并不能在 Coq
    自身中进行。然而，以下定理蕴含了假设可判定性公理（即排中律的一个特例）
    成立对于任何<i>'具体的'</i>命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 而言总是安全的。之所以如此，
    是因为我们无法证明这类公理的否定命题。假如我们可以的话，就会同时有
    <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode">¬<span class="id" title="var">P</span>)</span> 和 <span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode">¬<span class="id" title="var">P</span>)</span>（因为根据以下练习， <span class="inlinecode"><span class="id" title="var">P</span></span> 蕴含 <span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="var">P</span></span>），
    而这会产生矛盾。但因为我们不能，所以将 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode">¬<span class="id" title="var">P</span></span> 作为公理加入是安全的。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">excluded_middle_irrefutable</span>: <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span>:<span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;¬ ¬ (<span class="id" title="var">P</span> ∨ ¬ <span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab40"></a><h4 class="section">练习：3 星, advanced (not_exists_dist)</h4>


<div class="paragraph"> </div>

    在经典逻辑中有这样一条定理，它断言以下两条命题是等价的：

<div class="paragraph"> </div>

    ~ (exists x, ~ P x)
    forall x, P x

<div class="paragraph"> </div>

    之前的 <span class="inlinecode"><span class="id" title="var">dist_not_exists</span></span> 证明了此等价式的一个方向。有趣的是，
    我们无法用构造逻辑证明另一个方向。你的任务就是证明排中律蕴含此方向的证明。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">not_exists_dist</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">excluded_middle</span> →<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;¬ (<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, ¬ <span class="id" title="var">P</span> <span class="id" title="var">x</span>) → (<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab41"></a><h4 class="section">练习：5 星, standard, optional (classical_axioms)</h4>


<div class="paragraph"> </div>

    对于喜欢挑战的读者，以下练习来自于 Bertot 与 Casteran 所著的
    Coq'Art 一书中第 123 页。以下四条陈述的每一条，加上 <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span>
    可以认为刻画了经典逻辑。我们无法在 Coq 中证明其中的任意一条，
    不过如果我们希望在经典逻辑下工作的话，可以安全地将其中任意一条作为公理添加到
    Coq 中而不会造成不一致性。

<div class="paragraph"> </div>

    请证明所有五个命题都是等价的（这四个再加上 <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span>）。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">peirce</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>: <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;((<span class="id" title="var">P</span>→<span class="id" title="var">Q</span>)-&gt;<span class="id" title="var">P</span>)-&gt;<span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">double_negation_elimination</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span>:<span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~~<span class="id" title="var">P</span> → <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">de_morgan_not_and_not</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>:<span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~(~<span class="id" title="var">P</span> ∧ ¬<span class="id" title="var">Q</span>) → <span class="id" title="var">P</span>∨<span class="id" title="var">Q</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">implies_to_or</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>:<span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span>→<span class="id" title="var">Q</span>) → (~<span class="id" title="var">P</span>∨<span class="id" title="var">Q</span>).<br/>

<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>